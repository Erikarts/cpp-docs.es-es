---
title: CDaoRecordset (clase)
ms.date: 08/27/2018
f1_keywords:
- CDaoRecordset
- AFXDAO/CDaoRecordset
- AFXDAO/CDaoRecordset::CDaoRecordset
- AFXDAO/CDaoRecordset::AddNew
- AFXDAO/CDaoRecordset::CanAppend
- AFXDAO/CDaoRecordset::CanBookmark
- AFXDAO/CDaoRecordset::CancelUpdate
- AFXDAO/CDaoRecordset::CanRestart
- AFXDAO/CDaoRecordset::CanScroll
- AFXDAO/CDaoRecordset::CanTransact
- AFXDAO/CDaoRecordset::CanUpdate
- AFXDAO/CDaoRecordset::Close
- AFXDAO/CDaoRecordset::Delete
- AFXDAO/CDaoRecordset::DoFieldExchange
- AFXDAO/CDaoRecordset::Edit
- AFXDAO/CDaoRecordset::FillCache
- AFXDAO/CDaoRecordset::Find
- AFXDAO/CDaoRecordset::FindFirst
- AFXDAO/CDaoRecordset::FindLast
- AFXDAO/CDaoRecordset::FindNext
- AFXDAO/CDaoRecordset::FindPrev
- AFXDAO/CDaoRecordset::GetAbsolutePosition
- AFXDAO/CDaoRecordset::GetBookmark
- AFXDAO/CDaoRecordset::GetCacheSize
- AFXDAO/CDaoRecordset::GetCacheStart
- AFXDAO/CDaoRecordset::GetCurrentIndex
- AFXDAO/CDaoRecordset::GetDateCreated
- AFXDAO/CDaoRecordset::GetDateLastUpdated
- AFXDAO/CDaoRecordset::GetDefaultDBName
- AFXDAO/CDaoRecordset::GetDefaultSQL
- AFXDAO/CDaoRecordset::GetEditMode
- AFXDAO/CDaoRecordset::GetFieldCount
- AFXDAO/CDaoRecordset::GetFieldInfo
- AFXDAO/CDaoRecordset::GetFieldValue
- AFXDAO/CDaoRecordset::GetIndexCount
- AFXDAO/CDaoRecordset::GetIndexInfo
- AFXDAO/CDaoRecordset::GetLastModifiedBookmark
- AFXDAO/CDaoRecordset::GetLockingMode
- AFXDAO/CDaoRecordset::GetName
- AFXDAO/CDaoRecordset::GetParamValue
- AFXDAO/CDaoRecordset::GetPercentPosition
- AFXDAO/CDaoRecordset::GetRecordCount
- AFXDAO/CDaoRecordset::GetSQL
- AFXDAO/CDaoRecordset::GetType
- AFXDAO/CDaoRecordset::GetValidationRule
- AFXDAO/CDaoRecordset::GetValidationText
- AFXDAO/CDaoRecordset::IsBOF
- AFXDAO/CDaoRecordset::IsDeleted
- AFXDAO/CDaoRecordset::IsEOF
- AFXDAO/CDaoRecordset::IsFieldDirty
- AFXDAO/CDaoRecordset::IsFieldNull
- AFXDAO/CDaoRecordset::IsFieldNullable
- AFXDAO/CDaoRecordset::IsOpen
- AFXDAO/CDaoRecordset::Move
- AFXDAO/CDaoRecordset::MoveFirst
- AFXDAO/CDaoRecordset::MoveLast
- AFXDAO/CDaoRecordset::MoveNext
- AFXDAO/CDaoRecordset::MovePrev
- AFXDAO/CDaoRecordset::Open
- AFXDAO/CDaoRecordset::Requery
- AFXDAO/CDaoRecordset::Seek
- AFXDAO/CDaoRecordset::SetAbsolutePosition
- AFXDAO/CDaoRecordset::SetBookmark
- AFXDAO/CDaoRecordset::SetCacheSize
- AFXDAO/CDaoRecordset::SetCacheStart
- AFXDAO/CDaoRecordset::SetCurrentIndex
- AFXDAO/CDaoRecordset::SetFieldDirty
- AFXDAO/CDaoRecordset::SetFieldNull
- AFXDAO/CDaoRecordset::SetFieldValue
- AFXDAO/CDaoRecordset::SetFieldValueNull
- AFXDAO/CDaoRecordset::SetLockingMode
- AFXDAO/CDaoRecordset::SetParamValue
- AFXDAO/CDaoRecordset::SetParamValueNull
- AFXDAO/CDaoRecordset::SetPercentPosition
- AFXDAO/CDaoRecordset::Update
- AFXDAO/CDaoRecordset::m_bCheckCacheForDirtyFields
- AFXDAO/CDaoRecordset::m_nFields
- AFXDAO/CDaoRecordset::m_nParams
- AFXDAO/CDaoRecordset::m_pDAORecordset
- AFXDAO/CDaoRecordset::m_pDatabase
- AFXDAO/CDaoRecordset::m_strFilter
- AFXDAO/CDaoRecordset::m_strSort
helpviewer_keywords:
- CDaoRecordset [MFC], CDaoRecordset
- CDaoRecordset [MFC], AddNew
- CDaoRecordset [MFC], CanAppend
- CDaoRecordset [MFC], CanBookmark
- CDaoRecordset [MFC], CancelUpdate
- CDaoRecordset [MFC], CanRestart
- CDaoRecordset [MFC], CanScroll
- CDaoRecordset [MFC], CanTransact
- CDaoRecordset [MFC], CanUpdate
- CDaoRecordset [MFC], Close
- CDaoRecordset [MFC], Delete
- CDaoRecordset [MFC], DoFieldExchange
- CDaoRecordset [MFC], Edit
- CDaoRecordset [MFC], FillCache
- CDaoRecordset [MFC], Find
- CDaoRecordset [MFC], FindFirst
- CDaoRecordset [MFC], FindLast
- CDaoRecordset [MFC], FindNext
- CDaoRecordset [MFC], FindPrev
- CDaoRecordset [MFC], GetAbsolutePosition
- CDaoRecordset [MFC], GetBookmark
- CDaoRecordset [MFC], GetCacheSize
- CDaoRecordset [MFC], GetCacheStart
- CDaoRecordset [MFC], GetCurrentIndex
- CDaoRecordset [MFC], GetDateCreated
- CDaoRecordset [MFC], GetDateLastUpdated
- CDaoRecordset [MFC], GetDefaultDBName
- CDaoRecordset [MFC], GetDefaultSQL
- CDaoRecordset [MFC], GetEditMode
- CDaoRecordset [MFC], GetFieldCount
- CDaoRecordset [MFC], GetFieldInfo
- CDaoRecordset [MFC], GetFieldValue
- CDaoRecordset [MFC], GetIndexCount
- CDaoRecordset [MFC], GetIndexInfo
- CDaoRecordset [MFC], GetLastModifiedBookmark
- CDaoRecordset [MFC], GetLockingMode
- CDaoRecordset [MFC], GetName
- CDaoRecordset [MFC], GetParamValue
- CDaoRecordset [MFC], GetPercentPosition
- CDaoRecordset [MFC], GetRecordCount
- CDaoRecordset [MFC], GetSQL
- CDaoRecordset [MFC], GetType
- CDaoRecordset [MFC], GetValidationRule
- CDaoRecordset [MFC], GetValidationText
- CDaoRecordset [MFC], IsBOF
- CDaoRecordset [MFC], IsDeleted
- CDaoRecordset [MFC], IsEOF
- CDaoRecordset [MFC], IsFieldDirty
- CDaoRecordset [MFC], IsFieldNull
- CDaoRecordset [MFC], IsFieldNullable
- CDaoRecordset [MFC], IsOpen
- CDaoRecordset [MFC], Move
- CDaoRecordset [MFC], MoveFirst
- CDaoRecordset [MFC], MoveLast
- CDaoRecordset [MFC], MoveNext
- CDaoRecordset [MFC], MovePrev
- CDaoRecordset [MFC], Open
- CDaoRecordset [MFC], Requery
- CDaoRecordset [MFC], Seek
- CDaoRecordset [MFC], SetAbsolutePosition
- CDaoRecordset [MFC], SetBookmark
- CDaoRecordset [MFC], SetCacheSize
- CDaoRecordset [MFC], SetCacheStart
- CDaoRecordset [MFC], SetCurrentIndex
- CDaoRecordset [MFC], SetFieldDirty
- CDaoRecordset [MFC], SetFieldNull
- CDaoRecordset [MFC], SetFieldValue
- CDaoRecordset [MFC], SetFieldValueNull
- CDaoRecordset [MFC], SetLockingMode
- CDaoRecordset [MFC], SetParamValue
- CDaoRecordset [MFC], SetParamValueNull
- CDaoRecordset [MFC], SetPercentPosition
- CDaoRecordset [MFC], Update
- CDaoRecordset [MFC], m_bCheckCacheForDirtyFields
- CDaoRecordset [MFC], m_nFields
- CDaoRecordset [MFC], m_nParams
- CDaoRecordset [MFC], m_pDAORecordset
- CDaoRecordset [MFC], m_pDatabase
- CDaoRecordset [MFC], m_strFilter
- CDaoRecordset [MFC], m_strSort
ms.assetid: 2322067f-1027-4662-a5d7-aa2fc7488630
ms.openlocfilehash: 96118645aa656e97fcb93a0fd223045208ab03a3
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/16/2020
ms.locfileid: "79424540"
---
# <a name="cdaorecordset-class"></a>CDaoRecordset (clase)

Representa un conjunto de registros seleccionados de un origen de datos.

## <a name="syntax"></a>Sintaxis

```
class CDaoRecordset : public CObject
```

## <a name="members"></a>Members

### <a name="public-constructors"></a>Constructores públicos

|Nombre|Descripción|
|----------|-----------------|
|[CDaoRecordset:: CDaoRecordset](#cdaorecordset)|Construye un objeto `CDaoRecordset`.|

### <a name="public-methods"></a>Métodos públicos

|Nombre|Descripción|
|----------|-----------------|
|[CDaoRecordset:: AddNew](#addnew)|Prepara para agregar un nuevo registro. Llame a [Update](#update) para completar la adición.|
|[CDaoRecordset:: CanAppend](#canappend)|Devuelve un valor distinto de cero si se pueden agregar nuevos registros al conjunto de registros a través de la función miembro [AddNew](#addnew) .|
|[CDaoRecordset:: CanBookmark](#canbookmark)|Devuelve un valor distinto de cero si el conjunto de registros admite marcadores.|
|[CDaoRecordset:: CancelUpdate](#cancelupdate)|Cancela cualquier actualización pendiente debido a una operación de [edición](#edit) o de [AddNew](#addnew) .|
|[CDaoRecordset:: CanRestart](#canrestart)|Devuelve un valor distinto de cero si se puede llamar a [Requery](#requery) para volver a ejecutar la consulta del conjunto de registros.|
|[CDaoRecordset:: CanScroll](#canscroll)|Devuelve un valor distinto de cero si puede desplazarse por los registros.|
|[CDaoRecordset:: CanTransact](#cantransact)|Devuelve un valor distinto de cero si el origen de datos admite transacciones.|
|[CDaoRecordset:: CanUpdate](#canupdate)|Devuelve un valor distinto de cero si el conjunto de registros se puede actualizar (puede Agregar, actualizar o eliminar registros).|
|[CDaoRecordset:: Close](#close)|Cierra el conjunto de registros.|
|[CDaoRecordset::D iminar](#delete)|Elimina el registro actual del conjunto de registros. Debe desplazarse explícitamente a otro registro después de la eliminación.|
|[CDaoRecordset::D oFieldExchange](#dofieldexchange)|Se llama para intercambiar datos (en ambas direcciones) entre los miembros de datos de campo del conjunto de registros y el registro correspondiente en el origen de datos. Implementa el intercambio de campos de registros (DFX) de DAO.|
|[CDaoRecordset:: Edit](#edit)|Prepara los cambios en el registro actual. Llame a `Update` para completar la edición.|
|[CDaoRecordset:: FillCache](#fillcache)|Rellena toda o parte de una caché local para un objeto de conjunto de registros que contiene datos de un origen de datos ODBC.|
|[CDaoRecordset:: Find](#find)|Busca la primera, siguiente, anterior o última ubicación de una cadena determinada en un conjunto de registros de tipo Dynaset que cumpla los criterios especificados y haga que registre el registro actual.|
|[CDaoRecordset:: FindFirst](#findfirst)|Busca el primer registro de un conjunto de registros de tipo Dynaset o de instantánea que cumpla los criterios especificados y hace que registre el registro actual.|
|[CDaoRecordset:: FindLast](#findlast)|Busca el último registro de un conjunto de registros de tipo Dynaset o de instantánea que cumpla los criterios especificados y hace que registre el registro actual.|
|[CDaoRecordset:: FindNext](#findnext)|Busca el Registro siguiente en un conjunto de registros de tipo Dynaset o de instantánea que cumpla los criterios especificados y hace que registre el registro actual.|
|[CDaoRecordset:: FindPrev](#findprev)|Busca el registro anterior en un conjunto de registros de tipo Dynaset o de instantánea que cumpla los criterios especificados y hace que registre el registro actual.|
|[CDaoRecordset:: GetAbsolutePosition](#getabsoluteposition)|Devuelve el número de registro del registro actual de un objeto de conjunto de registros.|
|[CDaoRecordset:: GetBookmark](#getbookmark)|Devuelve un valor que representa el marcador de un registro.|
|[CDaoRecordset:: GetCacheSize](#getcachesize)|Devuelve un valor que especifica el número de registros de un conjunto de registros de tipo Dynaset que contiene los datos que se van a almacenar en caché localmente desde un origen de datos ODBC.|
|[CDaoRecordset:: GetCacheStart](#getcachestart)|Devuelve un valor que especifica el marcador del primer registro del conjunto de registros que se va a almacenar en caché.|
|[CDaoRecordset:: GetCurrentIndex](#getcurrentindex)|Devuelve un `CString` que contiene el nombre del índice usado más recientemente en una `CDaoRecordset`indizada de tipo tabla.|
|[CDaoRecordset:: GetDateCreated](#getdatecreated)|Devuelve la fecha y hora en que se creó la tabla base subyacente a un objeto `CDaoRecordset`|
|[CDaoRecordset:: GetDateLastUpdated](#getdatelastupdated)|Devuelve la fecha y hora del cambio más reciente realizado en el diseño de una tabla base subyacente de un objeto `CDaoRecordset`.|
|[CDaoRecordset:: GetDefaultDBName](#getdefaultdbname)|Devuelve el nombre del origen de datos predeterminado.|
|[CDaoRecordset:: GetDefaultSQL](#getdefaultsql)|Se llama para obtener la cadena SQL predeterminada que se va a ejecutar.|
|[CDaoRecordset:: GetEditMode](#geteditmode)|Devuelve un valor que indica el estado de edición del registro actual.|
|[CDaoRecordset:: GetFieldCount](#getfieldcount)|Devuelve un valor que representa el número de campos de un conjunto de registros.|
|[CDaoRecordset:: GetFieldInfo](#getfieldinfo)|Devuelve tipos específicos de información sobre los campos del conjunto de registros.|
|[CDaoRecordset:: GetFieldValue](#getfieldvalue)|Devuelve el valor de un campo de un conjunto de registros.|
|[CDaoRecordset:: GetIndexCount](#getindexcount)|Recupera el número de índices de una tabla subyacente de un conjunto de registros.|
|[CDaoRecordset:: GetIndexInfo](#getindexinfo)|Devuelve varios tipos de información sobre un índice.|
|[CDaoRecordset:: GetLastModifiedBookmark](#getlastmodifiedbookmark)|Se usa para determinar el registro agregado o actualizado más recientemente.|
|[CDaoRecordset:: GetLockingMode](#getlockingmode)|Devuelve un valor que indica el tipo de bloqueo que está en vigor durante la edición.|
|[CDaoRecordset:: GetName](#getname)|Devuelve un `CString` que contiene el nombre del conjunto de registros.|
|[CDaoRecordset:: GetParamValue](#getparamvalue)|Recupera el valor actual del parámetro especificado almacenado en el objeto DAOParameter subyacente.|
|[CDaoRecordset:: GetPercentPosition](#getpercentposition)|Devuelve la posición del registro actual como un porcentaje del número total de registros.|
|[CDaoRecordset:: GetRecordCount](#getrecordcount)|Devuelve el número de registros a los que se tiene acceso en un objeto de conjunto de registros.|
|[CDaoRecordset:: GetSQL](#getsql)|Obtiene la cadena de SQL utilizada para seleccionar los registros del conjunto de registros.|
|[CDaoRecordset:: GetType](#gettype)|Se llama para determinar el tipo de un conjunto de registros: tipo de tabla, tipo de Dynaset o tipo de instantánea.|
|[CDaoRecordset:: GetValidationRule](#getvalidationrule)|Devuelve un `CString` que contiene el valor que valida los datos a medida que se escriben en un campo.|
|[CDaoRecordset:: GetValidationText](#getvalidationtext)|Recupera el texto que se muestra cuando no se cumple una regla de validación.|
|[CDaoRecordset:: IsBOF](#isbof)|Devuelve un valor distinto de cero si el conjunto de registros se ha colocado antes del primer registro. No hay ningún registro actual.|
|[CDaoRecordset:: IsDeleted](#isdeleted)|Devuelve un valor distinto de cero si el conjunto de registros está colocado en un registro eliminado.|
|[CDaoRecordset:: IsEOF](#iseof)|Devuelve un valor distinto de cero si el conjunto de registros se ha colocado después del último registro. No hay ningún registro actual.|
|[CDaoRecordset:: IsFieldDirty](#isfielddirty)|Devuelve un valor distinto de cero si se ha cambiado el campo especificado en el registro actual.|
|[CDaoRecordset:: IsFieldNull](#isfieldnull)|Devuelve un valor distinto de cero si el campo especificado en el registro actual es null (no tiene ningún valor).|
|[CDaoRecordset:: IsFieldNullable](#isfieldnullable)|Devuelve un valor distinto de cero si el campo especificado del registro actual se puede establecer en null (no tiene ningún valor).|
|[CDaoRecordset:: IsOpen](#isopen)|Devuelve un valor distinto de cero si se ha llamado previamente a [Open](#open) .|
|[CDaoRecordset:: Move](#move)|Coloca el conjunto de registros en un número especificado de registros del registro actual en cualquier dirección.|
|[CDaoRecordset:: MoveFirst](#movefirst)|Coloca el registro actual en el primer registro del conjunto de registros.|
|[CDaoRecordset:: MoveLast](#movelast)|Coloca el registro actual en el último registro del conjunto de registros.|
|[CDaoRecordset:: MoveNext](#movenext)|Coloca el registro actual en el Registro siguiente del conjunto de registros.|
|[CDaoRecordset:: MovePrev](#moveprev)|Coloca el registro actual en el registro anterior del conjunto de registros.|
|[CDaoRecordset:: Open](#open)|Crea un nuevo conjunto de registros a partir de una tabla, Dynaset o instantánea.|
|[CDaoRecordset:: Requery](#requery)|Vuelve a ejecutar la consulta del conjunto de registros para actualizar los registros seleccionados.|
|[CDaoRecordset:: Seek](#seek)|Localiza el registro de un objeto de conjunto de registros de tipo tabla indizado que cumple los criterios especificados para el índice actual y hace que registre el registro actual.|
|[CDaoRecordset:: SetAbsolutePosition](#setabsoluteposition)|Establece el número de registro del registro actual de un objeto de conjunto de registros.|
|[CDaoRecordset:: SetBookmark](#setbookmark)|Coloca el conjunto de registros en un registro que contiene el marcador especificado.|
|[CDaoRecordset:: SetCacheSize](#setcachesize)|Establece un valor que especifica el número de registros de un conjunto de registros de tipo Dynaset que contiene los datos que se van a almacenar en caché localmente desde un origen de datos ODBC.|
|[CDaoRecordset:: SetCacheStart](#setcachestart)|Establece un valor que especifica el marcador del primer registro del conjunto de registros que se va a almacenar en caché.|
|[CDaoRecordset:: SetCurrentIndex](#setcurrentindex)|Se llama para establecer un índice en un conjunto de registros de tipo tabla.|
|[CDaoRecordset:: SetFieldDirty](#setfielddirty)|Marca el campo especificado en el registro actual como modificado.|
|[CDaoRecordset:: SetFieldNull](#setfieldnull)|Establece el valor del campo especificado en el registro actual en null (sin valor).|
|[CDaoRecordset:: SetFieldValue](#setfieldvalue)|Establece el valor de un campo en un conjunto de registros.|
|[CDaoRecordset:: SetFieldValueNull](#setfieldvaluenull)|Establece el valor de un campo de un conjunto de registros en NULL. (sin valor).|
|[CDaoRecordset:: SetLockingMode](#setlockingmode)|Establece un valor que indica el tipo de bloqueo que se va a aplicar durante la edición.|
|[CDaoRecordset:: SetParamValue](#setparamvalue)|Establece el valor actual del parámetro especificado almacenado en el objeto DAOParameter subyacente.|
|[CDaoRecordset:: SetParamValueNull](#setparamvaluenull)|Establece el valor actual del parámetro especificado en null (sin ningún valor).|
|[CDaoRecordset:: SetPercentPosition](#setpercentposition)|Establece la posición del registro actual en una ubicación que corresponde a un porcentaje del número total de registros de un conjunto de registros.|
|[CDaoRecordset:: Update](#update)|Completa una operación de `AddNew` o `Edit` guardando los datos nuevos o editados en el origen de datos.|

### <a name="public-data-members"></a>Miembros de datos públicos

|Nombre|Descripción|
|----------|-----------------|
|[CDaoRecordset:: m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields)|Contiene una marca que indica si los campos se marcan automáticamente como modificados.|
|[CDaoRecordset:: m_nFields](#m_nfields)|Contiene el número de miembros de datos de campo de la clase de conjunto de registros y el número de columnas seleccionadas por el conjunto de registros del origen de datos.|
|[CDaoRecordset:: m_nParams](#m_nparams)|Contiene el número de miembros de datos de parámetro de la clase de conjunto de registros: el número de parámetros pasados con la consulta del conjunto de registros.|
|[CDaoRecordset:: m_pDAORecordset](#m_pdaorecordset)|Puntero a la interfaz de DAO subyacente del objeto de conjunto de registros.|
|[CDaoRecordset:: m_pDatabase](#m_pdatabase)|Base de datos de origen para este conjunto de resultados. Contiene un puntero a un objeto [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md) .|
|[CDaoRecordset:: m_strFilter](#m_strfilter)|Contiene una cadena que se usa para construir una instrucción **Where** de SQL.|
|[CDaoRecordset:: m_strSort](#m_strsort)|Contiene una cadena que se usa para construir una instrucción SQL **order by** .|

## <a name="remarks"></a>Observaciones

Los objetos de `CDaoRecordset`, conocidos como "conjuntos de registros", están disponibles en las tres formas siguientes:

- Los conjuntos de registros de tipo de tabla representan una tabla base que se puede usar para examinar, agregar, cambiar o eliminar registros de una tabla de base de datos única.

- Los conjuntos de registros de tipo Dynaset son el resultado de una consulta que puede tener registros actualizables. Estos conjuntos de registros son un conjunto de registros que puede usar para examinar, agregar, cambiar o eliminar registros de una tabla o tablas de base de datos subyacentes. Los conjuntos de registros de tipo Dynaset pueden contener campos de una o varias tablas de una base de datos.

- Los conjuntos de registros de tipo de instantánea son una copia estática de un conjunto de registros que puede usar para buscar datos o generar informes. Estos conjuntos de registros pueden contener campos de una o varias tablas de una base de datos, pero no se pueden actualizar.

Cada forma de conjunto de registros representa un conjunto de registros fijos en el momento en que se abre el conjunto de registros. Cuando se desplaza a un registro de un conjunto de registros de tipo tabla o de un conjunto de registros de tipo Dynaset, refleja los cambios realizados en el registro una vez abierto el conjunto de registros, ya sea por parte de otros usuarios u otros conjuntos de registros de la aplicación. (No se puede actualizar un conjunto de registros de tipo snapshot). Puede usar `CDaoRecordset` directamente o derivar una clase de conjunto de registros específica de la aplicación de `CDaoRecordset`. Seguidamente, puede:

- Desplácese por los registros.

- Establecer un índice y buscar rápidamente registros mediante [Seek](#seek) (solo conjuntos de registros de tipo tabla).

- Buscar registros en función de una comparación de cadenas: "<", "\<=", "=", "> =" o ">" (conjuntos de registros de tipo Dynaset y tipo de instantánea).

- Actualice los registros y especifique un modo de bloqueo (excepto los conjuntos de registros de tipo de instantánea).

- Filtre el conjunto de registros para restringir los registros que selecciona de los disponibles en el origen de datos.

- Ordene el conjunto de registros.

- Parametrizar el conjunto de registros para personalizar su selección con información no conocida hasta el tiempo de ejecución.

La clase `CDaoRecordset` proporciona una interfaz similar a la de `CRecordset`de clase. La principal diferencia es que la clase `CDaoRecordset` tiene acceso a los datos a través de un objeto de acceso a datos (DAO) basado en OLE. La clase `CRecordset` tiene acceso a DBMS a través de ODBC (Conectividad abierta de bases de datos) y un controlador ODBC para ese DBMS.

> [!NOTE]
> Las clases de base de datos DAO son distintas de las clases de base de datos MFC basadas en Conectividad abierta de bases de datos (ODBC). Todos los nombres de clase de base de datos DAO tienen el prefijo "CDao". Todavía puede obtener acceso a los orígenes de datos ODBC con las clases DAO; las clases DAO suelen ofrecer funcionalidades superiores porque son específicas del motor de base de datos de Microsoft Jet.

Puede usar `CDaoRecordset` directamente o derivar una clase de `CDaoRecordset`. Para utilizar una clase de conjunto de registros en cualquier caso, abra una base de datos y construya un objeto de conjunto de registros, pasando el constructor a un puntero al objeto de `CDaoDatabase`. También puede crear un objeto `CDaoRecordset` y dejar que MFC cree un objeto de `CDaoDatabase` temporal. A continuación, llame a la función miembro [Open](#open) del conjunto de registros, especificando si el objeto es un conjunto de registros de tipo tabla, un conjunto de registros de tipo Dynaset o un conjunto de registros de tipo Snapshot. Al llamar a `Open`, se seleccionan los datos de la base de datos y se recupera el primer registro.

Use las funciones miembro y los miembros de datos del objeto para desplazarse por los registros y trabajar en ellos. Las operaciones disponibles dependen de si el objeto es un conjunto de registros de tipo tabla, un conjunto de registros de tipo Dynaset o un conjunto de registros de tipo de instantánea, y si es actualizable o de solo lectura, depende de la capacidad de la base de datos o de conectividad abierta de bases de datos (ODBC). origen de datos. Para actualizar registros que pueden haber cambiado o agregado desde el `Open` llamada a, llame a la función miembro [Requery](#requery) del objeto. Llame a la función miembro `Close` del objeto y destruya el objeto cuando termine con él.

`CDaoRecordset` usa el intercambio de campos de registros (DFX) de DAO para admitir la lectura y actualización de campos C++ de registro a través de miembros con seguridad de tipos de la clase derivada de `CDaoRecordset` o `CDaoRecordset`. También puede implementar el enlace dinámico de columnas en una base de datos sin usar el mecanismo DFX mediante [GetFieldValue](#getfieldvalue) y [SetFieldValue](#setfieldvalue).

Para obtener información relacionada, vea el tema "objeto de conjunto de registros" en la ayuda de DAO.

## <a name="inheritance-hierarchy"></a>Jerarquía de herencia

[CObject](../../mfc/reference/cobject-class.md)

`CDaoRecordset`

## <a name="requirements"></a>Requisitos

**Encabezado:** afxdao. h

##  <a name="addnew"></a>CDaoRecordset:: AddNew

Llame a esta función miembro para agregar un nuevo registro a un conjunto de registros de tipo tabla o Dynaset.

```
virtual void AddNew();
```

### <a name="remarks"></a>Observaciones

Los campos del registro son inicialmente null. (En la terminología de bases de datos, null significa "sin valor" y no es igual que NULL C++en). Para completar la operación, debe llamar a la función miembro [Update](#update) . `Update` guarda los cambios realizados en el origen de datos.

> [!CAUTION]
>  Si edita un registro y, a continuación, se desplaza a otro registro sin llamar a `Update`, los cambios se perderán sin previo aviso.

Si agrega un registro a un conjunto de registros de tipo Dynaset llamando a [AddNew](#addnew), el registro estará visible en el conjunto de registros y se incluirá en la tabla subyacente, donde estará visible para los nuevos objetos de `CDaoRecordset`.

La posición del nuevo registro depende del tipo de conjunto de registros:

- En un conjunto de registros de tipo Dynaset, no se garantiza que el nuevo registro se inserte. Este comportamiento cambió con Microsoft Jet 3,0 por motivos de rendimiento y simultaneidad. Si el objetivo es hacer que el registro recién agregado sea el registro actual, obtenga el marcador del último registro modificado y muévalo a ese marcador:

[!code-cpp[NVC_MFCDatabase#1](../../mfc/codesnippet/cpp/cdaorecordset-class_1.cpp)]

- En un conjunto de registros de tipo tabla para el que se ha especificado un índice, los registros se devuelven en su lugar adecuado en el criterio de ordenación. Si no se ha especificado ningún índice, se devuelven nuevos registros al final del conjunto de registros.

El registro que era actual antes de usar `AddNew` sigue siendo actual. Si desea que el nuevo registro sea actual y el conjunto de registros admita marcadores, llame a [SetBookmark](#setbookmark) al marcador identificado por el valor de la propiedad LastModified del objeto de conjunto de registros DAO subyacente. Esto resulta útil para determinar el valor de los campos Counter (incremento automático) de un registro agregado. Para obtener más información, vea [GetLastModifiedBookmark](#getlastmodifiedbookmark).

Si la base de datos admite transacciones, puede hacer que el `AddNew` llame a parte de una transacción. Para obtener más información acerca de las transacciones, vea la clase [CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md). Tenga en cuenta que debe llamar a [CDaoWorkspace:: BeginTrans](../../mfc/reference/cdaoworkspace-class.md#begintrans) antes de llamar a `AddNew`.

No es válido llamar a `AddNew` para un conjunto de registros cuya función miembro [abierta](#open) no se haya llamado. Se produce una `CDaoException` si llama a `AddNew` para un conjunto de registros que no se puede anexar. Puede determinar si el conjunto de registros es actualizable llamando a [CanAppend](#canappend).

El marco marca los miembros de datos de campo modificados para asegurarse de que se escribirán en el registro del origen de datos mediante el mecanismo de intercambio de campos de registros (DFX) de DAO. Al cambiar el valor de un campo, normalmente se establece el campo modificado automáticamente, por lo que rara vez tendrá que llamar a [SetFieldDirty](#setfielddirty) , pero en ocasiones querrá asegurarse de que las columnas se actualicen o inserten explícitamente, independientemente del valor que se encuentre en el miembro de datos de campo. El mecanismo DFX también emplea el uso de **pseudo null**. Para obtener más información, vea [CDaoFieldExchange:: m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

Si no se utiliza el mecanismo de almacenamiento en búfer doble, al cambiar el valor del campo no se establece automáticamente el campo como modificado. En este caso, será necesario establecer explícitamente el campo modificado. La marca contenida en [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) controla esta comprobación automática de campos.

> [!NOTE]
> Si los registros son de doble búfer (es decir, se habilita la comprobación automática de campos), al llamar a `CancelUpdate` se restaurarán las variables de miembro a los valores que tenían antes de que se llamara a `AddNew` o `Edit`.

Para obtener información relacionada, vea los temas "método AddNew", "método CancelUpdate", "propiedad LastModified" y "propiedad EditMode" en la ayuda de DAO.

##  <a name="canappend"></a>CDaoRecordset:: CanAppend

Llame a esta función miembro para determinar si el conjunto de registros abierto previamente permite agregar nuevos registros mediante una llamada a la función miembro [AddNew](#addnew) .

```
BOOL CanAppend() const;
```

### <a name="return-value"></a>Valor devuelto

Distinto de cero si el conjunto de registros permite agregar nuevos registros; de lo contrario, es 0. `CanAppend` devolverá 0 si abrió el conjunto de registros como de solo lectura.

### <a name="remarks"></a>Observaciones

Para obtener información relacionada, vea el tema sobre el método Append en la ayuda de DAO.

##  <a name="canbookmark"></a>CDaoRecordset:: CanBookmark

Llame a esta función miembro para determinar si el conjunto de registros abierto previamente permite marcar registros individualmente mediante marcadores.

```
BOOL CanBookmark();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si el conjunto de registros admite marcadores; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Si usa conjuntos de registros basados completamente en tablas del motor de base de datos de Microsoft Jet, se pueden usar marcadores Excepto en los conjuntos de registros de tipo Snapshot marcados como conjuntos de registros de desplazamiento solo hacia delante. Es posible que otros productos de base de datos (orígenes de datos ODBC externos) no admitan marcadores.

Para obtener información relacionada, vea el tema sobre la propiedad Bookmarkable en la ayuda de DAO.

##  <a name="cancelupdate"></a>CDaoRecordset:: CancelUpdate

La función miembro `CancelUpdate` cancela cualquier actualización pendiente debido a una operación [Edit](#edit) o [AddNew](#addnew) .

```
virtual void CancelUpdate();
```

### <a name="remarks"></a>Observaciones

Por ejemplo, si una aplicación llama a la función miembro `Edit` o `AddNew` y no se ha llamado a [Update](#update), `CancelUpdate` cancela los cambios realizados después de que se haya llamado a `Edit` o `AddNew`.

> [!NOTE]
>  Si los registros son de doble búfer (es decir, se habilita la comprobación automática de campos), al llamar a `CancelUpdate` se restaurarán las variables de miembro a los valores que tenían antes de que se llamara a `AddNew` o `Edit`.

Si no hay pendiente ninguna operación de `Edit` o `AddNew`, `CancelUpdate` hace que MFC produzca una excepción. Llame a la función miembro [GetEditMode](#geteditmode) para determinar si hay una operación pendiente que se pueda cancelar.

Para obtener información relacionada, vea el tema "método CancelUpdate" en la ayuda de DAO.

##  <a name="canrestart"></a>CDaoRecordset:: CanRestart

Llame a esta función miembro para determinar si el conjunto de registros permite reiniciar su consulta (para actualizar sus registros) mediante una llamada a la función miembro `Requery`.

```
BOOL CanRestart();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si se puede llamar a `Requery` para volver a ejecutar la consulta del conjunto de registros, de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Los conjuntos de registros de tipo de tabla no admiten `Requery`.

Si no se admite `Requery`, llame a [cerrar](#close) y, a continuación, [abra](#open) para actualizar los datos. Puede llamar a `Requery` para actualizar la consulta de parámetros subyacente de un objeto de conjunto de registros después de haber cambiado los valores de los parámetros.

Para obtener información relacionada, vea el tema sobre la propiedad reiniciable en la ayuda de DAO.

##  <a name="canscroll"></a>CDaoRecordset:: CanScroll

Llame a esta función miembro para determinar si el conjunto de registros permite el desplazamiento.

```
BOOL CanScroll() const;
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si puede desplazarse por los registros; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Si llama a [Open](#open) con `dbForwardOnly`, el conjunto de registros solo puede desplazarse hacia delante.

Para obtener información relacionada, vea el tema "colocar el puntero de registro actual con DAO" en la ayuda de DAO.

##  <a name="cantransact"></a>CDaoRecordset:: CanTransact

Llame a esta función miembro para determinar si el conjunto de registros permite transacciones.

```
BOOL CanTransact();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si el origen de datos subyacente admite transacciones; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Para obtener información relacionada, vea el tema "propiedad Transactions" en la ayuda de DAO.

##  <a name="canupdate"></a>CDaoRecordset:: CanUpdate

Llame a esta función miembro para determinar si se puede actualizar el conjunto de registros.

```
BOOL CanUpdate() const;
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si el conjunto de registros se puede actualizar (agregar, actualizar y eliminar registros); de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Un conjunto de registros podría ser de solo lectura si el origen de datos subyacente es de solo lectura o si especificó `dbReadOnly` para *nOptions* cuando llamó a [Open](#open) para el conjunto de registros.

Para obtener información relacionada, vea los temas "AddNew Method", "Edit Method", "Delete Method", "Update Method" y "Updatable Property" en la ayuda de DAO.

##  <a name="cdaorecordset"></a>CDaoRecordset:: CDaoRecordset

Construye un objeto `CDaoRecordset`.

```
CDaoRecordset(CDaoDatabase* pDatabase = NULL);
```

### <a name="parameters"></a>Parámetros

*pDatabase*<br/>
Contiene un puntero a un objeto [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md) o el valor null. Si no es NULL y no se ha llamado a la función miembro `Open` del objeto `CDaoDatabase` para conectarlo al origen de datos, el conjunto de registros intenta abrirlo automáticamente durante su propia llamada a [Open](#open) . Si pasa NULL, se crea un objeto de `CDaoDatabase` y se conecta automáticamente con la información del origen de datos que especificó si ha derivado la clase de conjunto de registros de `CDaoRecordset`.

### <a name="remarks"></a>Observaciones

Puede usar `CDaoRecordset` directamente o derivar una clase específica de la aplicación de `CDaoRecordset`. Puede usar ClassWizard para derivar las clases de conjunto de registros.

> [!NOTE]
>  Si deriva una clase `CDaoRecordset`, la clase derivada debe proporcionar su propio constructor. En el constructor de la clase derivada, llame al constructor `CDaoRecordset::CDaoRecordset`, pasando los parámetros adecuados a él.

Pase NULL al constructor de conjunto de registros para tener un objeto `CDaoDatabase` construido y conectado automáticamente. Se trata de un acceso directo útil que no requiere que construya y conecte un objeto `CDaoDatabase` antes de construir el conjunto de registros. Si el objeto de `CDaoDatabase` no está abierto, también se creará un objeto [CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md) para el usuario que usa el área de trabajo predeterminada. Para obtener más información, vea [CDaoDatabase:: CDaoDatabase](../../mfc/reference/cdaodatabase-class.md#cdaodatabase).

##  <a name="close"></a>CDaoRecordset:: Close

Al cerrar un objeto de `CDaoRecordset` se quita de la colección de conjuntos de registros abiertos en la base de datos asociada.

```
virtual void Close();
```

### <a name="remarks"></a>Observaciones

Dado que `Close` no destruye el objeto `CDaoRecordset`, puede volver a usar el objeto llamando a `Open` en el mismo origen de datos o en otro origen de datos.

Todas las instrucciones [AddNew](#addnew) o [Edit](#edit) pendientes se cancelan y se revierten todas las transacciones pendientes. Si desea conservar las adiciones o ediciones pendientes, llame a [Update](#update) antes de llamar a `Close` para cada conjunto de registros.

Puede llamar a `Open` de nuevo después de llamar a `Close`. Esto le permite volver a usar el objeto de conjunto de registros. Una alternativa mejor es llamar a [Requery](#requery), si es posible.

Para obtener información relacionada, vea el tema sobre el método Close en la ayuda de DAO.

##  <a name="delete"></a>CDaoRecordset::D iminar

Llame a esta función miembro para eliminar el registro actual de un objeto Recordset abierto de tipo Dynaset o de tipo tabla.

```
virtual void Delete();
```

### <a name="remarks"></a>Observaciones

Después de una eliminación correcta, los miembros de datos de campo del conjunto de registros se establecen en un valor NULL y se debe llamar explícitamente a una de las funciones miembro de navegación de conjunto de registros ( [Move](#move), [Seek](#seek), [SetBookmark](#setbookmark), etc.) para desplazarse fuera del registro eliminado. Cuando se eliminan registros de un conjunto de registros, debe haber un registro actual en el conjunto de registros antes de llamar a `Delete`; de lo contrario, MFC produce una excepción.

`Delete` quita el registro actual y hace que sea inaccesible. Aunque no se puede editar o usar el registro eliminado, sigue siendo actual. Sin embargo, una vez que se mueve a otro registro, no puede volver a hacer que el registro eliminado esté actualizado.

> [!CAUTION]
>  El conjunto de registros debe ser actualizable y debe haber un registro válido en el conjunto de registros cuando se llama a `Delete`. Por ejemplo, si elimina un registro pero no se desplaza a un nuevo registro antes de volver a llamar a `Delete`, `Delete` produce [CDaoException](../../mfc/reference/cdaoexception-class.md).

Puede recuperar un registro si utiliza transacciones y llama a la función miembro [CDaoWorkspace:: Rollback](../../mfc/reference/cdaoworkspace-class.md#rollback) . Si la tabla base es la tabla principal de una relación de eliminación en cascada, la eliminación del registro actual también puede eliminar uno o varios registros de una tabla externa. Para obtener más información, vea la definición de "eliminación en cascada" en la ayuda de DAO.

A diferencia de `AddNew` y `Edit`, una llamada a `Delete` no va seguida de una llamada a `Update`.

Para obtener información relacionada, vea los temas "AddNew Method", "Edit Method", "Delete Method", "Update Method" y "Updatable Property" en la ayuda de DAO.

##  <a name="dofieldexchange"></a>CDaoRecordset::D oFieldExchange

El marco de trabajo llama a esta función miembro para intercambiar datos de forma automática entre los miembros de datos de campo del objeto de conjunto de registros y las columnas correspondientes del registro actual en el origen de datos.

```
virtual void DoFieldExchange(CDaoFieldExchange* pFX);
```

### <a name="parameters"></a>Parámetros

*pFX*<br/>
Contiene un puntero a un objeto `CDaoFieldExchange`. El marco ya habrá configurado este objeto para especificar un contexto para la operación de intercambio de campos.

### <a name="remarks"></a>Observaciones

También enlaza los miembros de datos de parámetro, si los hay, a marcadores de posición de parámetros en la cadena de instrucción SQL para la selección del conjunto de registros. El intercambio de datos de campo, denominado intercambio de campos de registros (DFX) de DAO, funciona en ambas direcciones: desde los miembros de datos de campo del objeto de conjunto de registros hasta los campos del registro en el origen de datos y desde el registro del origen de datos hasta el objeto de conjunto de registros. Si va a enlazar columnas dinámicamente, no es necesario implementar `DoFieldExchange`.

La única acción que se debe realizar normalmente para implementar `DoFieldExchange` para la clase de conjunto de registros derivada es crear la clase con ClassWizard y especificar los nombres y los tipos de datos de los miembros de datos de campo. También puede agregar código a las escrituras de ClassWizard para especificar los miembros de datos de parámetro. Si todos los campos se van a enlazar dinámicamente, esta función estará inactiva a menos que se especifiquen miembros de datos de parámetro.

Al declarar la clase de conjunto de registros derivada con ClassWizard, el asistente escribe una invalidación de `DoFieldExchange` automáticamente, que es similar al ejemplo siguiente:

[!code-cpp[NVC_MFCDatabase#2](../../mfc/codesnippet/cpp/cdaorecordset-class_2.cpp)]

##  <a name="edit"></a>CDaoRecordset:: Edit

Llame a esta función miembro para permitir cambios en el registro actual.

```
virtual void Edit();
```

### <a name="remarks"></a>Observaciones

Una vez que se llama a la función miembro `Edit`, los cambios realizados en los campos del registro actual se copian en el búfer de copia. Después de realizar los cambios deseados en el registro, llame a `Update` para guardar los cambios. `Edit` guarda los valores de los miembros de datos del conjunto de registros. Si llama a `Edit`, realiza cambios y llama de nuevo a `Edit`, los valores del registro se restauran a lo que estaban antes de la primera llamada a `Edit`.

> [!CAUTION]
>  Si edita un registro y, a continuación, realiza cualquier operación que se desplace a otro registro sin llamar primero a `Update`, los cambios se perderán sin previo aviso. Además, si cierra el conjunto de registros o la base de datos primaria, el registro editado se descarta sin previo aviso.

En algunos casos, puede que desee actualizar una columna convirtiéndola en null (que no contiene ningún dato). Para ello, llame a `SetFieldNull` con un parámetro de TRUE para marcar el campo como null. Esto también hace que se actualice la columna. Si desea que un campo se escriba en el origen de datos aunque su valor no haya cambiado, llame a `SetFieldDirty` con un parámetro de TRUE. Esto funciona incluso si el campo tenía el valor null.

El marco marca los miembros de datos de campo modificados para asegurarse de que se escribirán en el registro del origen de datos mediante el mecanismo de intercambio de campos de registros (DFX) de DAO. Al cambiar el valor de un campo, normalmente se establece el campo modificado automáticamente, por lo que rara vez tendrá que llamar a [SetFieldDirty](#setfielddirty) , pero en ocasiones querrá asegurarse de que las columnas se actualicen o inserten explícitamente, independientemente del valor que se encuentre en el miembro de datos de campo. El mecanismo DFX también emplea el uso de **pseudo null**. Para obtener más información, vea [CDaoFieldExchange:: m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

Si no se utiliza el mecanismo de almacenamiento en búfer doble, al cambiar el valor del campo no se establece automáticamente el campo como modificado. En este caso, será necesario establecer explícitamente el campo modificado. La marca contenida en [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) controla esta comprobación automática de campos.

Cuando el objeto de conjunto de registros está bloqueado de forma pesimista en un entorno multiusuario, el registro permanece bloqueado desde el momento en que se usa `Edit` hasta que se completa la actualización. Si el conjunto de registros está bloqueado de forma optimista, el registro se bloquea y se compara con el registro previamente editado justo antes de que se actualice en la base de datos. Si el registro ha cambiado desde que se llamó a `Edit`, se produce un error en la operación de `Update` y MFC inicia una excepción. Puede cambiar el modo de bloqueo con `SetLockingMode`.

> [!NOTE]
>  El bloqueo optimista siempre se usa en formatos de bases de datos externas, como ODBC e ISAM instalable.

El registro actual permanece actual después de llamar a `Edit`. Para llamar a `Edit`, debe haber un registro actual. Si no hay ningún registro actual o si el conjunto de registros no hace referencia a un objeto de conjunto de registros abierto o de tipo Dynaset, se produce una excepción. La llamada a `Edit` provoca que se produzca una `CDaoException` en las siguientes condiciones:

- No hay ningún registro actual.

- La base de datos o el conjunto de registros es de solo lectura.

- No se pueden actualizar los campos del registro.

- Otro usuario abrió la base de datos o el conjunto de registros para uso exclusivo.

- Otro usuario ha bloqueado la página que contiene el registro.

Si el origen de datos admite transacciones, puede hacer que el `Edit` llame a parte de una transacción. Tenga en cuenta que debe llamar a `CDaoWorkspace::BeginTrans` antes de llamar a `Edit` y después de abrir el conjunto de registros. Tenga en cuenta también que llamar a `CDaoWorkspace::CommitTrans` no es un sustituto de la llamada a `Update` para completar la operación de `Edit`. Para obtener más información sobre las transacciones, vea `CDaoWorkspace`de clases.

Para obtener información relacionada, vea los temas "AddNew Method", "Edit Method", "Delete Method", "Update Method" y "Updatable Property" en la ayuda de DAO.

##  <a name="fillcache"></a>CDaoRecordset:: FillCache

Llame a esta función miembro para almacenar en caché un número especificado de registros del conjunto de registros.

```
void FillCache(
    long* pSize = NULL,
    COleVariant* pBookmark = NULL);
```

### <a name="parameters"></a>Parámetros

*pSize*<br/>
Especifica el número de filas que se va a rellenar en la memoria caché. Si se omite este parámetro, el valor se determina mediante la configuración de la propiedad CacheSize del objeto DAO subyacente.

*pBookmark*<br/>
[COleVariant](../../mfc/reference/colevariant-class.md) que especifica un marcador. La memoria caché se rellena a partir del registro indicado por este marcador. Si se omite este parámetro, la memoria caché se rellena a partir del registro indicado por la propiedad CacheStart del objeto DAO subyacente.

### <a name="remarks"></a>Observaciones

El almacenamiento en caché mejora el rendimiento de una aplicación que recupera datos de un servidor remoto, o los captura. Una memoria caché es un espacio en la memoria local que contiene los datos capturados más recientemente del servidor en el supuesto de que se vuelvan a solicitar los datos mientras se ejecuta la aplicación. Cuando se solicitan datos, el motor de base de datos de Microsoft Jet comprueba primero la memoria caché de los datos en lugar de recuperarlos del servidor, lo que tarda más tiempo. El uso del almacenamiento en caché de datos en orígenes de datos que no son de ODBC no tiene ningún efecto, ya que los datos no se guardan en la memoria caché.

En lugar de esperar a que la memoria caché se rellene con registros a medida que se capturan, puede rellenar explícitamente la memoria caché en cualquier momento llamando a la función miembro `FillCache`. Se trata de una forma más rápida de rellenar la memoria caché porque `FillCache` captura varios registros a la vez en lugar de uno en uno. Por ejemplo, mientras se muestra cada pantalla de registros, puede hacer que la aplicación llame a `FillCache` para capturar la siguiente pantalla de registros.

Cualquier base de datos ODBC a la que se tenga acceso con objetos de conjunto de registros puede tener una memoria caché local. Para crear la memoria caché, abra un objeto de conjunto de registros desde el origen de datos remoto y, a continuación, llame a las funciones miembro `SetCacheSize` y `SetCacheStart` del conjunto de registros. Si *Lsize* y *lBookmark* crean un intervalo que es parcial o totalmente fuera del intervalo especificado por `SetCacheSize` y `SetCacheStart`, la parte del conjunto de registros fuera de este intervalo se omite y no se carga en la memoria caché. Si `FillCache` solicita más registros de los que permanecen en el origen de datos remoto, solo se capturan los registros restantes y no se produce ninguna excepción.

Los registros capturados desde la memoria caché no reflejan los cambios realizados simultáneamente en los datos de origen de otros usuarios.

`FillCache` captura solo los registros que no se han almacenado en la memoria caché. Para forzar una actualización de todos los datos en caché, llame a la función miembro `SetCacheSize` con un parámetro *Lsize* igual a 0, vuelva a llamar a `SetCacheSize` con el parámetro *Lsize* igual al tamaño de la caché que solicitó originalmente y, a continuación, llame a `FillCache`.

Para obtener información relacionada, vea el tema sobre el método FillCache en la ayuda de DAO.

##  <a name="find"></a>CDaoRecordset:: Find

Llame a esta función miembro para buscar una cadena determinada en un conjunto de registros de tipo Dynaset o Snapshot mediante un operador de comparación.

```
virtual BOOL Find(
    long lFindType,
    LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Parámetros

*lFindType*<br/>
Valor que indica el tipo de operación de búsqueda deseada. Los valores posibles son:

- AFX_DAO_NEXT buscar la siguiente ubicación de una cadena coincidente.

- AFX_DAO_PREV buscar la ubicación anterior de una cadena coincidente.

- AFX_DAO_FIRST buscar la primera ubicación de una cadena coincidente.

- AFX_DAO_LAST buscar la última ubicación de una cadena coincidente.

*lpszFilter*<br/>
Expresión de cadena (como la cláusula **Where** de una instrucción SQL sin la palabra **Where**) utilizada para buscar el registro. Por ejemplo:

[!code-cpp[NVC_MFCDatabase#3](../../mfc/codesnippet/cpp/cdaorecordset-class_3.cpp)]

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si se encuentran registros coincidentes; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Puede buscar la primera instancia, siguiente, anterior o la última instancia de la cadena. `Find` es una función virtual, por lo que puede invalidarla y agregar su propia implementación. Las funciones miembro `FindFirst`, `FindLast`, `FindNext`y `FindPrev` llaman a la función miembro `Find`, por lo que puede usar `Find` para controlar el comportamiento de todas las operaciones de búsqueda.

Para buscar un registro en un conjunto de registros de tipo tabla, llame a la función miembro [Seek](#seek) .

> [!TIP]
>  Cuanto menor sea el conjunto de registros que tenga, más eficaz será el `Find`. En general, y especialmente con los datos ODBC, es mejor crear una nueva consulta que recupere solo los registros deseados.

Para obtener información relacionada, vea el tema sobre los métodos FindFirst, FindLast, FindNext y FindPrevious en la ayuda de DAO.

##  <a name="findfirst"></a>CDaoRecordset:: FindFirst

Llame a esta función miembro para buscar el primer registro que coincide con una condición especificada.

```
BOOL FindFirst(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Parámetros

*lpszFilter*<br/>
Expresión de cadena (como la cláusula **Where** de una instrucción SQL sin la palabra **Where**) utilizada para buscar el registro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si se encuentran registros coincidentes; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La función miembro `FindFirst` comienza su búsqueda desde el principio del conjunto de registros y busca hasta el final del conjunto de registros.

Si desea incluir todos los registros de la búsqueda (no solo aquellos que cumplan una condición específica), use una de las operaciones de movimiento para moverse de registro a registro. Para buscar un registro en un conjunto de registros de tipo tabla, llame a la función miembro `Seek`.

Si no se encuentra un registro que coincida con los criterios, el puntero del registro actual queda indeterminado y `FindFirst` devuelve cero. Si el conjunto de registros contiene más de un registro que cumple los criterios, `FindFirst` busca la primera aparición, `FindNext` busca la siguiente repetición, etc.

> [!CAUTION]
>  Si edita el registro actual, asegúrese de guardar los cambios mediante una llamada a la función miembro `Update` antes de pasar a otro registro. Si se mueve a otro registro sin actualizar, los cambios se perderán sin previo aviso.

Las funciones miembro de `Find` buscan desde la ubicación y en la dirección especificada en la tabla siguiente:

|Operaciones de búsqueda|Begin|Dirección de búsqueda|
|---------------------|-----------|----------------------|
|`FindFirst`|Inicio del conjunto de registros|Fin del conjunto de registros|
|`FindLast`|Fin del conjunto de registros|Inicio del conjunto de registros|
|`FindNext`|Registro actual|Fin del conjunto de registros|
|`FindPrevious`|Registro actual|Inicio del conjunto de registros|

> [!NOTE]
>  Cuando se llama a `FindLast`, el motor de base de datos de Microsoft Jet rellena completamente el conjunto de registros antes de comenzar la búsqueda, si aún no se ha hecho. La primera búsqueda puede tardar más que las búsquedas posteriores.

No obstante, el uso de una de las operaciones de búsqueda no es lo mismo que llamar a `MoveFirst` o `MoveNext`, que simplemente hace que el primer registro o el siguiente estén actualizados sin especificar una condición. Puede seguir una operación de búsqueda con una operación de movimiento.

Tenga en cuenta lo siguiente al usar las operaciones de búsqueda:

- Si `Find` devuelve un valor distinto de cero, no se define el registro actual. En este caso, debe volver a colocar el puntero del registro actual en un registro válido.

- No se puede usar una operación de búsqueda con un conjunto de registros de desplazamiento de solo avance de tipo Snapshot.

- Debe usar el formato de fecha de Estados Unidos (mes-día-año) al buscar campos que contengan fechas, incluso si no está utilizando la versión de Estados Unidos del motor de base de datos de Microsoft Jet. de lo contrario, es posible que no se encuentren los registros coincidentes.

- Cuando se trabaja con bases de datos ODBC y conjuntos de registros dinámicos grandes, es posible que descubra que el uso de las operaciones de búsqueda es lento, especialmente cuando se trabaja con conjuntos de registros de gran tamaño. Puede mejorar el rendimiento mediante el uso de consultas SQL con cláusulas **ORDERBY** o **Where** personalizadas, consultas de parámetros u objetos `CDaoQuerydef` que recuperen registros indexados específicos.

Para obtener información relacionada, vea el tema sobre los métodos FindFirst, FindLast, FindNext y FindPrevious en la ayuda de DAO.

##  <a name="findlast"></a>CDaoRecordset:: FindLast

Llame a esta función miembro para buscar el último registro que coincide con una condición especificada.

```
BOOL FindLast(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Parámetros

*lpszFilter*<br/>
Expresión de cadena (como la cláusula **Where** de una instrucción SQL sin la palabra **Where**) utilizada para buscar el registro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si se encuentran registros coincidentes; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La función miembro `FindLast` comienza su búsqueda al final del conjunto de registros y busca hacia atrás hacia el principio del conjunto de registros.

Si desea incluir todos los registros de la búsqueda (no solo aquellos que cumplan una condición específica), use una de las operaciones de movimiento para moverse de registro a registro. Para buscar un registro en un conjunto de registros de tipo tabla, llame a la función miembro `Seek`.

Si no se encuentra un registro que coincida con los criterios, el puntero del registro actual queda indeterminado y `FindLast` devuelve cero. Si el conjunto de registros contiene más de un registro que cumple los criterios, `FindFirst` busca la primera aparición, `FindNext` busca la siguiente repetición después de la primera aparición, y así sucesivamente.

> [!CAUTION]
>  Si edita el registro actual, asegúrese de guardar los cambios mediante una llamada a la función miembro `Update` antes de pasar a otro registro. Si se mueve a otro registro sin actualizar, los cambios se perderán sin previo aviso.

No obstante, el uso de una de las operaciones de búsqueda no es lo mismo que llamar a `MoveFirst` o `MoveNext`, que simplemente hace que el primer registro o el siguiente estén actualizados sin especificar una condición. Puede seguir una operación de búsqueda con una operación de movimiento.

Tenga en cuenta lo siguiente al usar las operaciones de búsqueda:

- Si `Find` devuelve un valor distinto de cero, no se define el registro actual. En este caso, debe volver a colocar el puntero del registro actual en un registro válido.

- No se puede usar una operación de búsqueda con un conjunto de registros de desplazamiento de solo avance de tipo Snapshot.

- Debe usar el formato de fecha de Estados Unidos (mes-día-año) al buscar campos que contengan fechas, incluso si no está utilizando la versión de Estados Unidos del motor de base de datos de Microsoft Jet. de lo contrario, es posible que no se encuentren los registros coincidentes.

- Cuando se trabaja con bases de datos ODBC y conjuntos de registros dinámicos grandes, es posible que descubra que el uso de las operaciones de búsqueda es lento, especialmente cuando se trabaja con conjuntos de registros de gran tamaño. Puede mejorar el rendimiento mediante el uso de consultas SQL con cláusulas **ORDERBY** o **Where** personalizadas, consultas de parámetros u objetos `CDaoQuerydef` que recuperen registros indexados específicos.

Para obtener información relacionada, vea el tema sobre los métodos FindFirst, FindLast, FindNext y FindPrevious en la ayuda de DAO.

##  <a name="findnext"></a>CDaoRecordset:: FindNext

Llame a esta función miembro para buscar el siguiente registro que coincide con una condición especificada.

```
BOOL FindNext(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Parámetros

*lpszFilter*<br/>
Expresión de cadena (como la cláusula **Where** de una instrucción SQL sin la palabra **Where**) utilizada para buscar el registro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si se encuentran registros coincidentes; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La función miembro `FindNext` inicia la búsqueda en el registro actual y busca en el final del conjunto de registros.

Si desea incluir todos los registros de la búsqueda (no solo aquellos que cumplan una condición específica), use una de las operaciones de movimiento para moverse de registro a registro. Para buscar un registro en un conjunto de registros de tipo tabla, llame a la función miembro `Seek`.

Si no se encuentra un registro que coincida con los criterios, el puntero del registro actual queda indeterminado y `FindNext` devuelve cero. Si el conjunto de registros contiene más de un registro que cumple los criterios, `FindFirst` busca la primera aparición, `FindNext` busca la siguiente repetición, etc.

> [!CAUTION]
>  Si edita el registro actual, asegúrese de guardar los cambios mediante una llamada a la función miembro `Update` antes de pasar a otro registro. Si se mueve a otro registro sin actualizar, los cambios se perderán sin previo aviso.

No obstante, el uso de una de las operaciones de búsqueda no es lo mismo que llamar a `MoveFirst` o `MoveNext`, que simplemente hace que el primer registro o el siguiente estén actualizados sin especificar una condición. Puede seguir una operación de búsqueda con una operación de movimiento.

Tenga en cuenta lo siguiente al usar las operaciones de búsqueda:

- Si `Find` devuelve un valor distinto de cero, no se define el registro actual. En este caso, debe volver a colocar el puntero del registro actual en un registro válido.

- No se puede usar una operación de búsqueda con un conjunto de registros de desplazamiento de solo avance de tipo Snapshot.

- Debe usar el formato de fecha de Estados Unidos (mes-día-año) al buscar campos que contengan fechas, incluso si no está utilizando la versión de Estados Unidos del motor de base de datos de Microsoft Jet. de lo contrario, es posible que no se encuentren los registros coincidentes.

- Cuando se trabaja con bases de datos ODBC y conjuntos de registros dinámicos grandes, es posible que descubra que el uso de las operaciones de búsqueda es lento, especialmente cuando se trabaja con conjuntos de registros de gran tamaño. Puede mejorar el rendimiento mediante el uso de consultas SQL con cláusulas **ORDERBY** o **Where** personalizadas, consultas de parámetros u objetos `CDaoQuerydef` que recuperen registros indexados específicos.

Para obtener información relacionada, vea el tema sobre los métodos FindFirst, FindLast, FindNext y FindPrevious en la ayuda de DAO.

##  <a name="findprev"></a>CDaoRecordset:: FindPrev

Llame a esta función miembro para buscar el registro anterior que coincide con una condición especificada.

```
BOOL FindPrev(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Parámetros

*lpszFilter*<br/>
Expresión de cadena (como la cláusula **Where** de una instrucción SQL sin la palabra **Where**) utilizada para buscar el registro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si se encuentran registros coincidentes; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La función miembro `FindPrev` inicia la búsqueda en el registro actual y busca hacia atrás hacia el principio del conjunto de registros.

Si desea incluir todos los registros de la búsqueda (no solo aquellos que cumplan una condición específica), use una de las operaciones de movimiento para moverse de registro a registro. Para buscar un registro en un conjunto de registros de tipo tabla, llame a la función miembro `Seek`.

Si no se encuentra un registro que coincida con los criterios, el puntero del registro actual queda indeterminado y `FindPrev` devuelve cero. Si el conjunto de registros contiene más de un registro que cumple los criterios, `FindFirst` busca la primera aparición, `FindNext` busca la siguiente repetición, etc.

> [!CAUTION]
>  Si edita el registro actual, asegúrese de guardar los cambios mediante una llamada a la función miembro `Update` antes de pasar a otro registro. Si se mueve a otro registro sin actualizar, los cambios se perderán sin previo aviso.

No obstante, el uso de una de las operaciones de búsqueda no es lo mismo que llamar a `MoveFirst` o `MoveNext`, que simplemente hace que el primer registro o el siguiente estén actualizados sin especificar una condición. Puede seguir una operación de búsqueda con una operación de movimiento.

Tenga en cuenta lo siguiente al usar las operaciones de búsqueda:

- Si `Find` devuelve un valor distinto de cero, no se define el registro actual. En este caso, debe volver a colocar el puntero del registro actual en un registro válido.

- No se puede usar una operación de búsqueda con un conjunto de registros de desplazamiento de solo avance de tipo Snapshot.

- Debe usar el formato de fecha de Estados Unidos (mes-día-año) al buscar campos que contengan fechas, incluso si no está utilizando la versión de Estados Unidos del motor de base de datos de Microsoft Jet. de lo contrario, es posible que no se encuentren los registros coincidentes.

- Cuando se trabaja con bases de datos ODBC y conjuntos de registros dinámicos grandes, es posible que descubra que el uso de las operaciones de búsqueda es lento, especialmente cuando se trabaja con conjuntos de registros de gran tamaño. Puede mejorar el rendimiento mediante el uso de consultas SQL con cláusulas **ORDERBY** o **Where** personalizadas, consultas de parámetros u objetos `CDaoQuerydef` que recuperen registros indexados específicos.

Para obtener información relacionada, vea el tema sobre los métodos FindFirst, FindLast, FindNext y FindPrevious en la ayuda de DAO.

##  <a name="getabsoluteposition"></a>CDaoRecordset:: GetAbsolutePosition

Devuelve el número de registro del registro actual de un objeto de conjunto de registros.

```
long GetAbsolutePosition();
```

### <a name="return-value"></a>Valor devuelto

Entero comprendido entre 0 y el número de registros del conjunto de registros. Corresponde a la posición ordinal del registro actual en el conjunto de registros.

### <a name="remarks"></a>Observaciones

El valor de la propiedad AbsolutePosition del objeto DAO subyacente es de base cero; un valor de 0 hace referencia al primer registro del conjunto de registros. Puede determinar el número de registros rellenados en el conjunto de registros llamando a [GetRecordCount](#getrecordcount). La llamada a `GetRecordCount` puede tardar algún tiempo, ya que debe tener acceso a todos los registros para determinar el recuento.

Si no hay ningún registro actual, como cuando no hay registros en el conjunto de registros, se devuelve-1. Si se elimina el registro actual, el valor de la propiedad AbsolutePosition no se define y MFC inicia una excepción si se hace referencia a él. En el caso de los conjuntos de registros de tipo Dynaset, los nuevos registros se agregan al final de la secuencia.

> [!NOTE]
>  Esta propiedad no está pensada para usarse como un número de registro suplente. Los marcadores siguen siendo la forma recomendada de conservar y volver a una posición determinada y son la única manera de colocar el registro actual en todos los tipos de objetos de conjunto de registros. En concreto, la posición de un registro determinado cambia cuando se eliminan los registros que lo preceden. Tampoco existe la garantía de que un registro determinado tendrá la misma posición absoluta si el conjunto de registros se vuelve a crear porque el orden de los registros individuales dentro de un conjunto de registros no está garantizado a menos que se cree con una instrucción SQL mediante una cláusula **ORDERBY** .

> [!NOTE]
>  Esta función miembro solo es válida para los conjuntos de registros de tipo Dynaset y tipo de instantánea.

Para obtener información relacionada, vea el tema "propiedad AbsolutePosition" en la ayuda de DAO.

##  <a name="getbookmark"></a>CDaoRecordset:: GetBookmark

Llame a esta función miembro para obtener el valor de marcador en un registro determinado.

```
COleVariant GetBookmark();
```

### <a name="return-value"></a>Valor devuelto

Devuelve un valor que representa el marcador del registro actual.

### <a name="remarks"></a>Observaciones

Cuando se crea o se abre un objeto de conjunto de registros, cada uno de sus registros tiene ya un marcador único si los admite. Llame a `CanBookmark` para determinar si un conjunto de registros admite marcadores.

Puede guardar el marcador del registro actual asignando el valor del marcador a un objeto de `COleVariant`. Para volver rápidamente a ese registro en cualquier momento después de desplazarse a otro registro, llame a `SetBookmark` con un parámetro que se corresponda con el valor de ese objeto `COleVariant`.

> [!NOTE]
>  Al llamar a [Requery](#requery) se cambian los marcadores DAO.

Para obtener información relacionada, vea el tema "propiedad Bookmark" en la ayuda de DAO.

##  <a name="getcachesize"></a>CDaoRecordset:: GetCacheSize

Llame a esta función miembro para obtener el número de registros almacenados en caché.

```
long GetCacheSize();
```

### <a name="return-value"></a>Valor devuelto

Valor que especifica el número de registros de un conjunto de registros de tipo Dynaset que contiene los datos que se van a almacenar en caché localmente desde un origen de datos ODBC.

### <a name="remarks"></a>Observaciones

El almacenamiento en caché de datos mejora el rendimiento de una aplicación que recupera datos de un servidor remoto a través de objetos de conjunto de registros de tipo Dynaset. Una memoria caché es un espacio en memoria local que contiene los datos recuperados más recientemente del servidor en caso de que se vuelvan a solicitar los datos mientras se ejecuta la aplicación. Cuando se solicitan datos, el motor de base de datos de Microsoft Jet comprueba primero la memoria caché de los datos solicitados en lugar de recuperarlos del servidor, lo que tarda más tiempo. Los datos que no proceden de un origen de datos ODBC no se guardan en la memoria caché.

Cualquier origen de datos ODBC, como una tabla adjunta, puede tener una memoria caché local.

Para obtener información relacionada, vea el tema "propiedades CacheSize, CacheStart" en la ayuda de DAO.

##  <a name="getcachestart"></a>CDaoRecordset:: GetCacheStart

Llame a esta función miembro para obtener el valor de marcador del primer registro del conjunto de registros que se va a almacenar en caché.

```
COleVariant GetCacheStart();
```

### <a name="return-value"></a>Valor devuelto

`COleVariant` que especifica el marcador del primer registro del conjunto de registros que se va a almacenar en caché.

### <a name="remarks"></a>Observaciones

El motor de base de datos de Microsoft Jet solicita registros dentro del intervalo de caché de la memoria caché y solicita registros fuera del intervalo de caché del servidor.

> [!NOTE]
>  Los registros recuperados de la memoria caché no reflejan los cambios realizados simultáneamente en los datos de origen de otros usuarios.

Para obtener información relacionada, vea el tema "propiedades CacheSize, CacheStart" en la ayuda de DAO.

##  <a name="getcurrentindex"></a>CDaoRecordset:: GetCurrentIndex

Llame a esta función miembro para determinar el índice actualmente en uso en un objeto de `CDaoRecordset` de tipo de tabla indizada.

```
CString GetCurrentIndex();
```

### <a name="return-value"></a>Valor devuelto

`CString` que contiene el nombre del índice actualmente en uso con un conjunto de registros de tipo tabla. Devuelve una cadena vacía si no se ha establecido ningún índice.

### <a name="remarks"></a>Observaciones

Este índice es la base para ordenar registros en un conjunto de registros de tipo tabla y lo utiliza la función miembro [Seek](#seek) para buscar registros.

Un objeto `CDaoRecordset` puede tener más de un índice, pero solo puede utilizar un índice cada vez (aunque un objeto [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) puede tener varios índices definidos).

Para obtener información relacionada, vea el tema sobre el objeto index y la definición de "índice actual" en la ayuda de DAO.

##  <a name="getdatecreated"></a>CDaoRecordset:: GetDateCreated

Llame a esta función miembro para recuperar la fecha y hora en que se creó una tabla base.

```
COleDateTime GetDateCreated();
```

### <a name="return-value"></a>Valor devuelto

Objeto [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md) que contiene la fecha y hora de creación de la tabla base.

### <a name="remarks"></a>Observaciones

La configuración de fecha y hora se deriva del equipo en el que se creó la tabla base.

Para obtener información relacionada, vea el tema "DateCreated, propiedades de LastUpdated" en la ayuda de DAO.

##  <a name="getdatelastupdated"></a>CDaoRecordset:: GetDateLastUpdated

Llame a esta función miembro para recuperar la fecha y la hora en que se actualizó por última vez el esquema.

```
COleDateTime GetDateLastUpdated();
```

### <a name="return-value"></a>Valor devuelto

Objeto [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md) que contiene la fecha y hora en que se actualizó por última vez la estructura de la tabla base (esquema).

### <a name="remarks"></a>Observaciones

La configuración de fecha y hora se deriva del equipo en el que se actualizó por última vez la estructura de la tabla base (esquema).

Para obtener información relacionada, vea el tema "DateCreated, propiedades de LastUpdated" en la ayuda de DAO.

##  <a name="getdefaultdbname"></a>CDaoRecordset:: GetDefaultDBName

Llame a esta función miembro para determinar el nombre de la base de datos de este conjunto de registros.

```
virtual CString GetDefaultDBName();
```

### <a name="return-value"></a>Valor devuelto

`CString` que contiene la ruta de acceso y el nombre de la base de datos de la que se deriva este conjunto de registros.

### <a name="remarks"></a>Observaciones

Si se crea un conjunto de registros sin un puntero a un objeto [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md), el conjunto de registros usa esta ruta de acceso para abrir la base de datos predeterminada. De forma predeterminada, esta función devuelve una cadena vacía. Cuando ClassWizard deriva un nuevo conjunto de registros de `CDaoRecordset`, creará esta función automáticamente.

En el ejemplo siguiente se muestra el uso de la barra diagonal inversa doble (\\\\) en la cadena, como es necesario para que la cadena se interprete correctamente.

[!code-cpp[NVC_MFCDatabase#4](../../mfc/codesnippet/cpp/cdaorecordset-class_4.cpp)]

##  <a name="getdefaultsql"></a>CDaoRecordset:: GetDefaultSQL

El marco de trabajo llama a esta función miembro para obtener la instrucción SQL predeterminada en la que se basa el conjunto de registros.

```
virtual CString GetDefaultSQL();
```

### <a name="return-value"></a>Valor devuelto

`CString` que contiene la instrucción SQL predeterminada.

### <a name="remarks"></a>Observaciones

Puede tratarse de un nombre de tabla o una instrucción **Select** de SQL.

La instrucción SQL predeterminada se define indirectamente declarando la clase de conjunto de registros con ClassWizard y ClassWizard realiza esta tarea por usted.

Si pasa una cadena de SQL null a [Open](#open), se llama a esta función para determinar el nombre de tabla o SQL para el conjunto de registros.

##  <a name="geteditmode"></a>CDaoRecordset:: GetEditMode

Llame a esta función miembro para determinar el estado de edición, que es uno de los valores siguientes:

```
short GetEditMode();
```

### <a name="return-value"></a>Valor devuelto

Devuelve un valor que indica el estado de edición del registro actual.

### <a name="remarks"></a>Observaciones

|Value|Descripción|
|-----------|-----------------|
|`dbEditNone`|No hay ninguna operación de edición en curso.|
|`dbEditInProgress`|Se ha llamado previamente a `Edit`.|
|`dbEditAdd`|Se ha llamado previamente a `AddNew`.|

Para obtener información relacionada, vea el tema "propiedad EditMode" en la ayuda de DAO.

##  <a name="getfieldcount"></a>CDaoRecordset:: GetFieldCount

Llame a esta función miembro para recuperar el número de campos (columnas) definidos en el conjunto de registros.

```
short GetFieldCount();
```

### <a name="return-value"></a>Valor devuelto

Número de campos del conjunto de registros.

### <a name="remarks"></a>Observaciones

Para obtener información relacionada, vea el tema "propiedad Count" en la ayuda de DAO.

##  <a name="getfieldinfo"></a>CDaoRecordset:: GetFieldInfo

Llame a esta función miembro para obtener información sobre los campos de un conjunto de registros.

```
void GetFieldInfo(
    int nIndex,
    CDaoFieldInfo& fieldinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

void GetFieldInfo(
    LPCTSTR lpszName,
    CDaoFieldInfo& fieldinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
```

### <a name="parameters"></a>Parámetros

*nIndex*<br/>
Índice de base cero del campo predefinido en la colección de campos del conjunto de registros, para la búsqueda por índice.

*FieldInfo*<br/>
Referencia a una estructura [cdaofieldinfo (](../../mfc/reference/cdaofieldinfo-structure.md) .

*dwInfoOptions*<br/>
Opciones que especifican la información sobre el conjunto de registros que se va a recuperar. Aquí se enumeran las opciones disponibles junto con lo que hacen que la función devuelva. Para obtener el mejor rendimiento, recupere solo el nivel de información que necesita:

- `AFX_DAO_PRIMARY_INFO` (valor predeterminado) Name, Type, size, Attributes

- `AFX_DAO_SECONDARY_INFO` información principal, más: posición ordinal, requerida, Permitir longitud cero, orden de intercalación, nombre externo, campo de origen, tabla de origen

- `AFX_DAO_ALL_INFO` información principal y secundaria, más: valor predeterminado, regla de validación, texto de validación

*lpszName*<br/>
Nombre del campo.

### <a name="remarks"></a>Observaciones

Una versión de la función permite buscar un campo por índice. La otra versión permite buscar un campo por nombre.

Para obtener una descripción de la información devuelta, consulte la estructura [cdaofieldinfo (](../../mfc/reference/cdaofieldinfo-structure.md) . Esta estructura tiene miembros que corresponden a los elementos de la información enumerados anteriormente en la descripción de *dwInfoOptions*. Cuando se solicita información en un nivel, también se obtiene información sobre cualquier nivel anterior.

Para obtener información relacionada, vea el tema "propiedad Attributes" en la ayuda de DAO.

##  <a name="getfieldvalue"></a>CDaoRecordset:: GetFieldValue

Llame a esta función miembro para recuperar datos en un conjunto de registros.

```
virtual void GetFieldValue(
    LPCTSTR lpszName,
    COleVariant& varValue);

virtual void GetFieldValue(
    int nIndex,
    COleVariant& varValue);

virtual COleVariant GetFieldValue(LPCTSTR lpszName);
virtual COleVariant GetFieldValue(int nIndex);
```

### <a name="parameters"></a>Parámetros

*lpszName*<br/>
Puntero a una cadena que contiene el nombre de un campo.

*varValue*<br/>
Referencia a un objeto `COleVariant` que almacenará el valor de un campo.

*nIndex*<br/>
Índice de base cero del campo de la colección de campos del conjunto de registros, para la búsqueda por índice.

### <a name="return-value"></a>Valor devuelto

Las dos versiones de `GetFieldValue` que devuelven un valor devuelven un objeto [COleVariant](../../mfc/reference/colevariant-class.md) que contiene el valor de un campo.

### <a name="remarks"></a>Observaciones

Puede buscar un campo por nombre o por posición ordinal.

> [!NOTE]
>  Es más eficaz llamar a una de las versiones de esta función miembro que toma una referencia de objeto `COleVariant` como parámetro, en lugar de llamar a una versión que devuelve un objeto `COleVariant`. Las últimas versiones de esta función se conservan por razones de compatibilidad con versiones anteriores.

Utilice `GetFieldValue` y [SetFieldValue](#setfieldvalue) para enlazar dinámicamente campos en tiempo de ejecución en lugar de enlazar columnas estáticamente mediante el mecanismo [DoFieldExchange](#dofieldexchange) .

`GetFieldValue` y el mecanismo de `DoFieldExchange` se pueden combinar para mejorar el rendimiento. Por ejemplo, use `GetFieldValue` para recuperar un valor que solo necesita a petición y asignar esa llamada a un botón "más información" en la interfaz.

Para obtener información relacionada, vea los temas "objeto de campo" y "propiedad de valor" en la ayuda de DAO.

##  <a name="getindexcount"></a>CDaoRecordset:: GetIndexCount

Llame a esta función miembro para determinar el número de índices disponibles en el conjunto de registros de tipo de tabla.

```
short GetIndexCount();
```

### <a name="return-value"></a>Valor devuelto

El número de índices en el conjunto de registros de tipo de tabla.

### <a name="remarks"></a>Observaciones

`GetIndexCount` es útil para recorrer todos los índices del conjunto de registros. Para ello, use `GetIndexCount` junto con [getIndexInfo](#getindexinfo). Si se llama a esta función miembro en conjuntos de registros de tipo Dynaset o de tipo Snapshot, MFC produce una excepción.

Para obtener información relacionada, vea el tema "propiedad Attributes" en la ayuda de DAO.

##  <a name="getindexinfo"></a>CDaoRecordset:: GetIndexInfo

Llame a esta función miembro para obtener varios tipos de información sobre un índice definido en la tabla base subyacente de un conjunto de registros.

```
void GetIndexInfo(
    int nIndex,
    CDaoIndexInfo& indexinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

void GetIndexInfo(
    LPCTSTR lpszName,
    CDaoIndexInfo& indexinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
```

### <a name="parameters"></a>Parámetros

*nIndex*<br/>
Índice de base cero de la colección de índices de la tabla, para la búsqueda por posición numérica.

*indexinfo*<br/>
Referencia a una estructura [cdaoindexinfo (](../../mfc/reference/cdaoindexinfo-structure.md) .

*dwInfoOptions*<br/>
Opciones que especifican qué información sobre el índice se va a recuperar. Aquí se enumeran las opciones disponibles junto con lo que hacen que la función devuelva. Para obtener el mejor rendimiento, recupere solo el nivel de información que necesita:

- Nombre de `AFX_DAO_PRIMARY_INFO` (valor predeterminado), información de campo, campos

- `AFX_DAO_SECONDARY_INFO` información principal, además de: principal, único, agrupado, nulo, requerido, externo

- `AFX_DAO_ALL_INFO` información principal y secundaria, más: recuento distintivo

*lpszName*<br/>
Puntero al nombre del objeto de índice, para la búsqueda por nombre.

### <a name="remarks"></a>Observaciones

Una versión de la función permite buscar un índice por su posición en la colección. La otra versión permite buscar un índice por nombre.

Para obtener una descripción de la información devuelta, consulte la estructura [cdaoindexinfo (](../../mfc/reference/cdaoindexinfo-structure.md) . Esta estructura tiene miembros que corresponden a los elementos de la información enumerados anteriormente en la descripción de *dwInfoOptions*. Cuando se solicita información en un nivel, también se obtiene información sobre cualquier nivel anterior.

Para obtener información relacionada, vea el tema "propiedad Attributes" en la ayuda de DAO.

##  <a name="getlastmodifiedbookmark"></a>CDaoRecordset:: GetLastModifiedBookmark

Llame a esta función miembro para recuperar el marcador del registro agregado o actualizado más recientemente.

```
COleVariant GetLastModifiedBookmark();
```

### <a name="return-value"></a>Valor devuelto

`COleVariant` que contiene un marcador que indica el registro agregado o modificado más recientemente.

### <a name="remarks"></a>Observaciones

Cuando se crea o se abre un objeto de conjunto de registros, cada uno de sus registros tiene ya un marcador único si los admite. Llame a [GetBookmark](#getbookmark) para determinar si el conjunto de registros admite marcadores. Si el conjunto de registros no admite marcadores, se produce una `CDaoException`.

Al agregar un registro, este aparece al final del conjunto de registros y no es el registro actual. Para que el nuevo registro sea actual, llame a `GetLastModifiedBookmark` y, a continuación, llame a `SetBookmark` para volver al registro recién agregado.

Para obtener información relacionada, vea el tema "propiedad LastModified" en la ayuda de DAO.

##  <a name="getlockingmode"></a>CDaoRecordset:: GetLockingMode

Llame a esta función miembro para determinar el tipo de bloqueo en vigor para el conjunto de registros.

```
BOOL GetLockingMode();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si el tipo de bloqueo es pesimista; de lo contrario, es 0 para el bloqueo de registros optimistas.

### <a name="remarks"></a>Observaciones

Cuando el bloqueo pesimista está en vigor, la página de datos que contiene el registro que está editando se bloquea en cuanto se llama a la función miembro [Edit](#edit) . La página se desbloquea cuando se llama a la función miembro [Update](#update) o [Close](#close) , o a cualquiera de las operaciones de movimiento o búsqueda.

Cuando el bloqueo optimista está en vigor, la página de datos que contiene el registro solo se bloquea mientras el registro se está actualizando con la función miembro `Update`.

Al trabajar con orígenes de datos ODBC, el modo de bloqueo siempre es optimista.

Para obtener información relacionada, vea los temas "propiedad LockEdits" y "comportamiento de bloqueo en aplicaciones multiusuario" en la ayuda de DAO.

##  <a name="getname"></a>CDaoRecordset:: GetName

Llame a esta función miembro para recuperar el nombre del conjunto de registros.

```
CString GetName();
```

### <a name="return-value"></a>Valor devuelto

`CString` que contiene el nombre del conjunto de registros.

### <a name="remarks"></a>Observaciones

El nombre del conjunto de registros debe empezar por una letra y puede contener un máximo de 40 caracteres. Puede incluir números y caracteres de subrayado, pero no puede incluir signos de puntuación ni espacios.

Para obtener información relacionada, vea el tema "propiedad de nombre" en la ayuda de DAO.

##  <a name="getparamvalue"></a>CDaoRecordset:: GetParamValue

Llame a esta función miembro para recuperar el valor actual del parámetro especificado almacenado en el objeto DAOParameter subyacente.

```
virtual COleVariant GetParamValue(int nIndex);
virtual COleVariant GetParamValue(LPCTSTR lpszName);
```

### <a name="parameters"></a>Parámetros

*nIndex*<br/>
Posición numérica del parámetro en el objeto DAOParameter subyacente.

*lpszName*<br/>
Nombre del parámetro cuyo valor desea.

### <a name="return-value"></a>Valor devuelto

Objeto de la clase [COleVariant](../../mfc/reference/colevariant-class.md) que contiene el valor del parámetro.

### <a name="remarks"></a>Observaciones

Puede tener acceso al parámetro por el nombre o por su posición numérica en la colección.

Para obtener información relacionada, vea el tema "objeto de parámetro" en la ayuda de DAO.

##  <a name="getpercentposition"></a>CDaoRecordset:: GetPercentPosition

Cuando se trabaja con un conjunto de registros de tipo Dynaset o de instantánea, si se llama a `GetPercentPosition` antes de rellenar completamente el conjunto de registros, la cantidad de movimiento es relativa al número de registros a los que se obtiene acceso como se indica mediante una llamada a [GetRecordCount](#getrecordcount).

```
float GetPercentPosition();
```

### <a name="return-value"></a>Valor devuelto

Un número entre 0 y 100 que indica la ubicación aproximada del registro actual en el objeto de conjunto de registros basándose en un porcentaje de los registros del conjunto de registros.

### <a name="remarks"></a>Observaciones

Puede pasar al último registro llamando a [MoveLast](#movelast) para completar el rellenado de todos los conjuntos de registros, pero esto puede tardar bastante tiempo.

Puede llamar a `GetPercentPosition` en los tres tipos de objetos de conjunto de registros, incluidas las tablas sin índices. Sin embargo, no puede llamar a `GetPercentPosition` en instantáneas de desplazamiento de solo avance o en un conjunto de registros abierto desde una consulta de paso a través en una base de datos externa. Si no hay ningún registro actual o se ha eliminado el registro actual, se produce una `CDaoException`.

Para obtener información relacionada, vea el tema "propiedad PercentPosition" en la ayuda de DAO.

##  <a name="getrecordcount"></a>CDaoRecordset:: GetRecordCount

Llame a esta función miembro para averiguar el número de registros de un conjunto de registros a los que se ha tenido acceso.

```
long GetRecordCount();
```

### <a name="return-value"></a>Valor devuelto

Devuelve el número de registros a los que se tiene acceso en un objeto de conjunto de registros.

### <a name="remarks"></a>Observaciones

`GetRecordCount` no indica el número de registros que contiene un conjunto de registros de tipo Dynaset o de instantánea hasta que se ha tenido acceso a todos los registros. Esta llamada de función miembro puede tardar una cantidad considerable de tiempo en completarse.

Una vez que se ha tenido acceso al último registro, el valor devuelto indica el número total de registros no eliminados en el conjunto de registros. Para forzar el acceso al último registro, llame a la función miembro `MoveLast` o `FindLast` para el conjunto de registros. También puede usar un recuento de SQL para determinar el número aproximado de registros que devolverá la consulta.

A medida que la aplicación elimina los registros de un conjunto de registros de tipo Dynaset, el valor devuelto de `GetRecordCount` disminuye. Sin embargo, los registros eliminados por otros usuarios no se reflejan en `GetRecordCount` hasta que el registro actual se coloca en un registro eliminado. Si ejecuta una transacción que afecta al número de registros y, posteriormente, revierte la transacción, `GetRecordCount` no reflejará el número real de registros restantes.

El valor de `GetRecordCount` de un conjunto de registros de tipo Snapshot no se ve afectado por los cambios en las tablas subyacentes.

El valor de `GetRecordCount` de un conjunto de registros de tipo tabla refleja el número aproximado de registros de la tabla y se ve afectado inmediatamente a medida que se agregan y eliminan registros de tabla.

Un conjunto de registros sin registros devuelve un valor de 0. Al trabajar con tablas o bases de datos ODBC adjuntas, `GetRecordCount` siempre devuelve-1. Al llamar a la función miembro `Requery` en un conjunto de registros, se restablece el valor de `GetRecordCount` del mismo modo que si se volviera a ejecutar la consulta.

Para obtener información relacionada, vea el tema "propiedad RecordCount" en la ayuda de DAO.

##  <a name="getsql"></a>CDaoRecordset:: GetSQL

Llame a esta función miembro para obtener la instrucción SQL que se usó para seleccionar los registros del conjunto de registros cuando se abrió.

```
CString GetSQL() const;
```

### <a name="return-value"></a>Valor devuelto

`CString` que contiene la instrucción SQL.

### <a name="remarks"></a>Observaciones

Normalmente, será una instrucción **Select** de SQL.

La cadena devuelta por `GetSQL` es normalmente diferente de cualquier cadena que se haya pasado al conjunto de registros del parámetro *lpszSQL* a la función miembro [abierta](#open) . Esto se debe a que el conjunto de registros crea una instrucción SQL completa basada en lo que pasó a `Open`, lo que especificó con ClassWizard y lo que puede haber especificado en los miembros de datos [m_strFilter](#m_strfilter) y [m_strSort](#m_strsort) .

> [!NOTE]
>  Llame a esta función miembro solo después de llamar a `Open`.

Para obtener información relacionada, vea el tema "propiedad SQL" en la ayuda de DAO.

##  <a name="gettype"></a>CDaoRecordset:: GetType

Llame a esta función miembro después de abrir el conjunto de registros para determinar el tipo del objeto de conjunto de registros.

```
short GetType();
```

### <a name="return-value"></a>Valor devuelto

Uno de los siguientes valores que indica el tipo de un conjunto de registros:

- `dbOpenTable` conjunto de registros de tipo tabla

- conjunto de registros de tipo Dynaset `dbOpenDynaset`

- `dbOpenSnapshot` conjunto de registros de tipo Snapshot

### <a name="remarks"></a>Observaciones

Para obtener información relacionada, vea el tema "propiedad de tipo" en la ayuda de DAO.

##  <a name="getvalidationrule"></a>CDaoRecordset:: GetValidationRule

Llame a esta función miembro para determinar la regla que se usa para validar los datos.

```
CString GetValidationRule();
```

### <a name="return-value"></a>Valor devuelto

`CString` objeto que contiene un valor que valida los datos de un registro a medida que se cambian o se agregan a una tabla.

### <a name="remarks"></a>Observaciones

Esta regla se basa en texto y se aplica cada vez que se cambia la tabla subyacente. Si los datos no son válidos, MFC produce una excepción. El mensaje de error devuelto es el texto de la propiedad ValidationText del objeto de campo subyacente, si se especifica, o el texto de la expresión especificada por la propiedad ValidationRule del objeto de campo subyacente. Puede llamar a [GetValidationText](#getvalidationtext) para obtener el texto del mensaje de error.

Por ejemplo, un campo de un registro que requiera el día del mes puede tener una regla de validación como "DAY BETWEEN 1 AND 31".

Para obtener información relacionada, vea el tema "propiedad ValidationRule" en la ayuda de DAO.

##  <a name="getvalidationtext"></a>CDaoRecordset:: GetValidationText

Llame a esta función miembro para recuperar el texto de la propiedad ValidationText del objeto de campo subyacente.

```
CString GetValidationText();
```

### <a name="return-value"></a>Valor devuelto

`CString` objeto que contiene el texto del mensaje que se muestra si el valor de un campo no satisface la regla de validación del objeto de campo subyacente.

### <a name="remarks"></a>Observaciones

Para obtener información relacionada, vea el tema "propiedad ValidationText" en la ayuda de DAO.

##  <a name="isbof"></a>CDaoRecordset:: IsBOF

Llame a esta función miembro antes de desplazarse de registro a registro para saber si ha pasado antes del primer registro del conjunto de registros.

```
BOOL IsBOF() const;
```

### <a name="return-value"></a>Valor devuelto

Distinto de cero si el conjunto de registros no contiene ningún registro o si se ha desplazado hacia atrás antes del primer registro; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

También puede llamar a `IsBOF` junto con `IsEOF` para determinar si el conjunto de registros contiene registros o si está vacío. Inmediatamente después de llamar a `Open`, si el conjunto de registros no contiene registros, `IsBOF` devuelve un valor distinto de cero. Al abrir un conjunto de registros que tiene al menos un registro, el primer registro es el registro actual y `IsBOF` devuelve 0.

Si el primer registro es el registro actual y llama a `MovePrev`, `IsBOF` devolverá después un valor distinto de cero. Si `IsBOF` devuelve un valor distinto de cero y llama a `MovePrev`, se produce una excepción. Si `IsBOF` devuelve un valor distinto de cero, el registro actual no está definido y cualquier acción que requiera un registro actual producirá una excepción.

Efecto de métodos específicos en la configuración de `IsBOF` y `IsEOF`:

- La llamada a `Open*` convierte internamente el primer registro del conjunto de registros en el registro actual llamando a `MoveFirst`. Por consiguiente, al llamar a `Open` en un conjunto vacío de registros, `IsBOF` y `IsEOF` devuelven un valor distinto de cero. (Vea la tabla siguiente para ver el comportamiento de una llamada `MoveFirst` o `MoveLast` errónea).

- Todas las operaciones de movimiento que buscan correctamente un registro provocan que `IsBOF` y `IsEOF` devuelvan 0.

- Una llamada `AddNew` seguida de una llamada `Update` que Inserte correctamente un nuevo registro hará que `IsBOF` devuelva 0, pero solo si `IsEOF` ya es distinto de cero. El estado de `IsEOF` siempre permanecerá sin cambios. Tal y como se define en el motor de base de datos de Microsoft Jet, el puntero de registro actual de un conjunto de registros vacío está al final de un archivo, por lo que se inserta cualquier registro nuevo después del registro actual.

- Cualquier llamada `Delete`, incluso si quita el único registro restante de un conjunto de registros, no cambiará el valor de `IsBOF` o `IsEOF`.

En esta tabla se muestran las operaciones de movimiento que se permiten con diferentes combinaciones de `IsBOF`/ `IsEOF`.

||MoveFirst, MoveLast|MovePrev,<br /><br /> Desplazamiento < 0|Movimiento 0|MoveNext<br /><br /> Desplazamiento > 0|
|------|-------------------------|-----------------------------|------------|-----------------------------|
|`IsBOF`= distinto de cero,<br /><br /> `IsEOF`=0|Permitida|Excepción|Excepción|Permitida|
|`IsBOF`=0,<br /><br /> `IsEOF`= distinto de cero|Permitida|Permitida|Excepción|Excepción|
|Ambos distintos|Excepción|Excepción|Excepción|Excepción|
|Ambos 0|Permitida|Permitida|Permitida|Permitida|

Permitir una operación de movimiento no significa que la operación busque correctamente un registro. Simplemente indica que se permite un intento de realizar la operación de movimiento especificada y no generará una excepción. El valor de las funciones miembro `IsBOF` y `IsEOF` puede cambiar como resultado de la operación de movimiento.

En la tabla siguiente se muestra el efecto de las operaciones de movimiento que no buscan un registro en el valor de la configuración de `IsBOF` y `IsEOF`.

||IsBOF|IsEOF|
|------|-----------|-----------|
|`MoveFirst`, `MoveLast`|Distinto|Distinto|
|`Move` 0|Sin cambios|Sin cambios|
|`MovePrev`, `Move` < 0|Distinto|Sin cambios|
|`MoveNext`, `Move` > 0|Sin cambios|Distinto|

Para obtener información relacionada, vea el tema "BOF, EOF Properties" en la ayuda de DAO.

##  <a name="isdeleted"></a>CDaoRecordset:: IsDeleted

Llame a esta función miembro para determinar si se ha eliminado el registro actual.

```
BOOL IsDeleted() const;
```

### <a name="return-value"></a>Valor devuelto

Distinto de cero si el conjunto de registros está colocado en un registro eliminado; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Si se desplaza a un registro y `IsDeleted` devuelve TRUE (distinto de cero), debe desplazarse a otro registro antes de poder realizar cualquier otra operación de conjunto de registros.

> [!NOTE]
>  No es necesario comprobar el estado eliminado de los registros de una instantánea o un conjunto de registros de tipo tabla. Dado que los registros no se pueden eliminar de una instantánea, no es necesario llamar a `IsDeleted`. En el caso de los conjuntos de registros de tipo tabla, los registros eliminados se quitan realmente del conjunto de registros. Una vez que se ha eliminado un registro, ya sea por parte de otro usuario o de otro conjunto de registros, no podrá desplazarse de nuevo a ese registro. Por lo tanto, no es necesario llamar a `IsDeleted`.

Cuando se elimina un registro de un Dynaset, se quita del conjunto de registros y no se puede desplazar hacia atrás hasta ese registro. Sin embargo, si un registro de un conjunto de registros dinámico es eliminado por otro usuario o en otro conjunto de registros basado en la misma tabla, `IsDeleted` devolverá TRUE cuando se desplace posteriormente a ese registro.

Para obtener información relacionada, vea los temas "Delete Method", "LastModified Property" y "EditMode Property" en la ayuda de DAO.

##  <a name="iseof"></a>CDaoRecordset:: IsEOF

Llame a esta función miembro mientras se desplaza de registro a registro para saber si ha ido más allá del último registro del conjunto de registros.

```
BOOL IsEOF() const;
```

### <a name="return-value"></a>Valor devuelto

Distinto de cero si el conjunto de registros no contiene registros o si se ha desplazado más allá del último registro; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

También puede llamar a `IsEOF` para determinar si el conjunto de registros contiene registros o si está vacío. Inmediatamente después de llamar a `Open`, si el conjunto de registros no contiene registros, `IsEOF` devuelve un valor distinto de cero. Al abrir un conjunto de registros que tiene al menos un registro, el primer registro es el registro actual y `IsEOF` devuelve 0.

Si el último registro es el registro actual cuando se llama a `MoveNext`, `IsEOF` devolverá después un valor distinto de cero. Si `IsEOF` devuelve un valor distinto de cero y llama a `MoveNext`, se produce una excepción. Si `IsEOF` devuelve un valor distinto de cero, el registro actual no está definido y cualquier acción que requiera un registro actual producirá una excepción.

Efecto de métodos específicos en la configuración de `IsBOF` y `IsEOF`:

- La llamada a `Open` convierte internamente el primer registro del conjunto de registros en el registro actual llamando a `MoveFirst`. Por consiguiente, al llamar a `Open` en un conjunto vacío de registros, `IsBOF` y `IsEOF` devuelven un valor distinto de cero. (Vea la tabla siguiente para ver el comportamiento de una llamada `MoveFirst` errónea).

- Todas las operaciones de movimiento que buscan correctamente un registro provocan que `IsBOF` y `IsEOF` devuelvan 0.

- Una llamada `AddNew` seguida de una llamada `Update` que Inserte correctamente un nuevo registro hará que `IsBOF` devuelva 0, pero solo si `IsEOF` ya es distinto de cero. El estado de `IsEOF` siempre permanecerá sin cambios. Tal y como se define en el motor de base de datos de Microsoft Jet, el puntero de registro actual de un conjunto de registros vacío está al final de un archivo, por lo que se inserta cualquier registro nuevo después del registro actual.

- Cualquier llamada `Delete`, incluso si quita el único registro restante de un conjunto de registros, no cambiará el valor de `IsBOF` o `IsEOF`.

En esta tabla se muestran las operaciones de movimiento que se permiten con diferentes combinaciones de `IsBOF`/ `IsEOF`.

||MoveFirst, MoveLast|MovePrev,<br /><br /> Desplazamiento < 0|Movimiento 0|MoveNext<br /><br /> Desplazamiento > 0|
|------|-------------------------|-----------------------------|------------|-----------------------------|
|`IsBOF`= distinto de cero,<br /><br /> `IsEOF`=0|Permitida|Excepción|Excepción|Permitida|
|`IsBOF`=0,<br /><br /> `IsEOF`= distinto de cero|Permitida|Permitida|Excepción|Excepción|
|Ambos distintos|Excepción|Excepción|Excepción|Excepción|
|Ambos 0|Permitida|Permitida|Permitida|Permitida|

Permitir una operación de movimiento no significa que la operación busque correctamente un registro. Simplemente indica que se permite un intento de realizar la operación de movimiento especificada y no generará una excepción. El valor de las funciones miembro `IsBOF` y `IsEOF` puede cambiar como resultado de la operación de movimiento.

En la tabla siguiente se muestra el efecto de las operaciones de movimiento que no buscan un registro en el valor de la configuración de `IsBOF` y `IsEOF`.

||IsBOF|IsEOF|
|------|-----------|-----------|
|`MoveFirst`, `MoveLast`|Distinto|Distinto|
|`Move` 0|Sin cambios|Sin cambios|
|`MovePrev`, `Move` < 0|Distinto|Sin cambios|
|`MoveNext`, `Move` > 0|Sin cambios|Distinto|

Para obtener información relacionada, vea el tema "BOF, EOF Properties" en la ayuda de DAO.

##  <a name="isfielddirty"></a>CDaoRecordset:: IsFieldDirty

Llame a esta función miembro para determinar si el miembro de datos de campo especificado de un Dynaset se ha marcado como "sucio" (cambiado).

```
BOOL IsFieldDirty(void* pv);
```

### <a name="parameters"></a>Parámetros

*FV*<br/>
Puntero al miembro de datos de campo cuyo estado se desea comprobar, o NULL para determinar si alguno de los campos está sucio.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si el miembro de datos de campo especificado se marca como modificado; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Los datos de todos los miembros de datos de campo modificados se transferirán al registro en el origen de datos cuando el registro actual se actualice mediante una llamada a la función miembro `Update` de `CDaoRecordset` (después de una llamada a `Edit` o `AddNew`). Con este conocimiento, puede realizar pasos adicionales, como quitar la marca del miembro de datos de campo para marcar la columna de modo que no se escriba en el origen de datos.

`IsFieldDirty` se implementa a través de `DoFieldExchange`.

##  <a name="isfieldnull"></a>CDaoRecordset:: IsFieldNull

Llame a esta función miembro para determinar si el miembro de datos de campo especificado de un conjunto de registros se ha marcado como null.

```
BOOL IsFieldNull(void* pv);
```

### <a name="parameters"></a>Parámetros

*FV*<br/>
Puntero al miembro de datos de campo cuyo estado se desea comprobar, o NULL para determinar si alguno de los campos es NULL.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si el miembro de datos de campo especificado se marca como null; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

(En la terminología de bases de datos, null significa "sin valor" y no es igual que NULL C++en). Si un miembro de datos de campo se marca como null, se interpreta como una columna del registro actual para el que no hay ningún valor.

> [!NOTE]
>  En determinadas situaciones, el uso de `IsFieldNull` puede ser ineficaz, como se muestra en el ejemplo de código siguiente:

[!code-cpp[NVC_MFCDatabase#5](../../mfc/codesnippet/cpp/cdaorecordset-class_5.cpp)]

> [!NOTE]
>  Si utiliza el enlace de registros dinámicos, sin derivar de `CDaoRecordset`, asegúrese de usar VT_NULL como se muestra en el ejemplo.

##  <a name="isfieldnullable"></a>CDaoRecordset:: IsFieldNullable

Llame a esta función miembro para determinar si el miembro de datos de campo especificado tiene valores NULL (se puede establecer en un valor null; C++ NULL no es lo mismo que null, que, en la terminología de bases de datos, significa "sin valor").

```
BOOL IsFieldNullable(void* pv);
```

### <a name="parameters"></a>Parámetros

*FV*<br/>
Puntero al miembro de datos de campo cuyo estado se desea comprobar, o NULL para determinar si alguno de los campos es NULL.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si el miembro de datos de campo especificado se puede establecer en null; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Un campo que no puede ser null debe tener un valor. Si intenta establecer este tipo de campo en NULL al agregar o actualizar un registro, el origen de datos rechaza la adición o actualización, y `Update` producirá una excepción. La excepción se produce cuando se llama a `Update`, no cuando se llama a `SetFieldNull`.

##  <a name="isopen"></a>CDaoRecordset:: IsOpen

Llame a esta función miembro para determinar si el conjunto de registros está abierto.

```
BOOL IsOpen() const;
```

### <a name="return-value"></a>Valor devuelto

Distinto de cero si se ha llamado previamente a la función miembro `Open` o `Requery` del objeto de conjunto de registros y el conjunto de registros no se ha cerrado; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

##  <a name="m_bcheckcachefordirtyfields"></a>CDaoRecordset:: m_bCheckCacheForDirtyFields

Contiene una marca que indica si los campos almacenados en caché se marcan automáticamente como modificados (cambiados) y null.

### <a name="remarks"></a>Observaciones

La marca tiene como valor predeterminado TRUE. La configuración de este miembro de datos controla todo el mecanismo de almacenamiento en búfer doble. Si establece la marca en TRUE, puede desactivar el almacenamiento en caché campo por campo mediante el mecanismo DFX. Si establece la marca en FALSE, debe llamar a `SetFieldDirty` y `SetFieldNull` mismo.

Establezca este miembro de datos antes de llamar a `Open`. Este mecanismo es principalmente para facilitar el uso. El rendimiento puede ser más lento debido al doble búfer de campos a medida que se realizan cambios.

##  <a name="m_nfields"></a>CDaoRecordset:: m_nFields

Contiene el número de miembros de datos de campo de la clase de conjunto de registros y el número de columnas seleccionadas por el conjunto de registros del origen de datos.

### <a name="remarks"></a>Observaciones

El constructor de la clase de conjunto de registros debe inicializar `m_nFields` con el número correcto de campos enlazados estáticamente. ClassWizard escribe esta inicialización cuando se usa para declarar la clase de conjunto de registros. También puede escribirlo manualmente.

El marco de trabajo utiliza este número para administrar la interacción entre los miembros de datos de campo y las columnas correspondientes del registro actual en el origen de datos.

> [!NOTE]
>  Este número debe corresponder al número de columnas de salida registradas en `DoFieldExchange` después de una llamada a `SetFieldType` con el parámetro `CDaoFieldExchange::outputColumn`.

Puede enlazar columnas dinámicamente por medio de `CDaoRecordset::GetFieldValue` y `CDaoRecordset::SetFieldValue`. Si lo hace, no necesita incrementar el recuento en `m_nFields` para reflejar el número de llamadas a funciones DFX en la función miembro `DoFieldExchange`.

##  <a name="m_nparams"></a>CDaoRecordset:: m_nParams

Contiene el número de miembros de datos de parámetro de la clase de conjunto de registros: el número de parámetros pasados con la consulta del conjunto de registros.

### <a name="remarks"></a>Observaciones

Si la clase de conjunto de registros tiene algún miembro de datos de parámetro, el constructor de la clase debe inicializar *m_nParams* con el número correcto. El valor de *m_nParams* tiene como valor predeterminado 0. Si agrega miembros de datos de parámetro (que debe realizar manualmente), también debe agregar manualmente una inicialización en el constructor de clase para reflejar el número de parámetros (que debe ser al menos tan grande como el número de marcadores de posición ' ' en el *m_strFilter* o *m_strSort* cadena).

El marco de trabajo utiliza este número cuando Parametriza la consulta del conjunto de registros.

> [!NOTE]
>  Este número debe corresponder al número de "params" registrado en `DoFieldExchange` después de una llamada a `SetFieldType` con el parámetro `CFieldExchange::param`.

Para obtener información relacionada, vea el tema "objeto de parámetro" en la ayuda de DAO.

##  <a name="m_pdaorecordset"></a>CDaoRecordset:: m_pDAORecordset

Contiene un puntero a la interfaz OLE para el objeto de conjunto de registros DAO subyacente al objeto `CDaoRecordset`.

### <a name="remarks"></a>Observaciones

Utilice este puntero si necesita tener acceso a la interfaz de DAO directamente.

Para obtener información relacionada, vea el tema "objeto de conjunto de registros" en la ayuda de DAO.

##  <a name="m_pdatabase"></a>CDaoRecordset:: m_pDatabase

Contiene un puntero al objeto `CDaoDatabase` a través del que el conjunto de registros está conectado a un origen de datos.

### <a name="remarks"></a>Observaciones

Esta variable se establece de dos maneras. Normalmente, se pasa un puntero a un objeto que ya está abierto `CDaoDatabase` al construir el objeto de conjunto de registros. Si pasa NULL en su lugar, `CDaoRecordset` crea un objeto `CDaoDatabase` y lo abre. En cualquier caso, `CDaoRecordset` almacena el puntero en esta variable.

Normalmente, no necesitará usar directamente el puntero almacenado en `m_pDatabase`. Sin embargo, si escribe sus propias extensiones en `CDaoRecordset`, es posible que tenga que usar el puntero. Por ejemplo, puede que necesite el puntero si inicia sus propios `CDaoException`.

Para obtener información relacionada, vea el tema "objeto de base de datos" en la ayuda de DAO.

##  <a name="m_strfilter"></a>CDaoRecordset:: m_strFilter

Contiene una cadena que se usa para construir la cláusula **Where** de una instrucción SQL.

### <a name="remarks"></a>Observaciones

No incluye la palabra reservada **en la que** filtrar el conjunto de registros. El uso de este miembro de datos no es aplicable a los conjuntos de registros de tipo de tabla. El uso de `m_strFilter` no tiene ningún efecto al abrir un conjunto de registros mediante un puntero `CDaoQueryDef`.

Use el formato de fecha de Estados Unidos (mes-día-año) cuando filtre campos que contengan fechas, incluso si no está utilizando la versión de Estados Unidos del motor de base de datos de Microsoft Jet. de lo contrario, es posible que los datos no se filtren como se espera.

Para obtener información relacionada, vea el tema "propiedad Filter" en la ayuda de DAO.

##  <a name="m_strsort"></a>CDaoRecordset:: m_strSort

Contiene una cadena que contiene la cláusula **OrderBy** de una instrucción SQL sin las palabras reservadas **OrderBy**.

### <a name="remarks"></a>Observaciones

Puede ordenar por objetos de conjunto de registros de tipo Dynaset y de instantánea.

No se pueden ordenar objetos de conjunto de registros de tipo tabla. Para determinar el criterio de ordenación de un conjunto de registros de tipo tabla, llame a [SetCurrentIndex](#setcurrentindex).

El uso de *m_strSort* no tiene ningún efecto al abrir un conjunto de registros mediante un puntero `CDaoQueryDef`.

Para obtener información relacionada, vea el tema "propiedad Sort" en la ayuda de DAO.

##  <a name="move"></a>CDaoRecordset:: Move

Llame a esta función miembro para colocar los registros del conjunto de registros *lRows* del registro actual.

```
virtual void Move(long lRows);
```

### <a name="parameters"></a>Parámetros

*lRows*<br/>
Número de registros que se van a desplazar hacia delante o hacia atrás. Los valores positivos avanzan hacia delante, hacia el final del conjunto de registros. Los valores negativos se mueven hacia atrás, hacia el principio.

### <a name="remarks"></a>Observaciones

Puede desplazarse hacia delante o hacia atrás. `Move( 1 )` es equivalente a `MoveNext`y `Move( -1 )` es equivalente a `MovePrev`.

> [!CAUTION]
>  Si se llama a cualquiera de las funciones de `Move`, se produce una excepción si el conjunto de registros no tiene registros. En general, llame a `IsBOF` y `IsEOF` antes de una operación de movimiento para determinar si el conjunto de registros tiene registros. Después de llamar a `Open` o `Requery`, llame a `IsBOF` o a `IsEOF`.

> [!NOTE]
>  Si se ha desplazado más allá del principio o el final del conjunto de registros (`IsBOF` o `IsEOF` devuelve un valor distinto de cero), una llamada a `Move` produce una `CDaoException`.

> [!NOTE]
>  Si llama a cualquiera de las funciones de `Move` mientras el registro actual se está actualizando o agregando, las actualizaciones se pierden sin previo aviso.

Cuando se llama a `Move` en una instantánea de desplazamiento de solo avance, el parámetro *lRows* debe ser un entero positivo y no se permiten marcadores, por lo que solo se puede avanzar.

Para que el primer registro, último, siguiente o anterior de un conjunto de registros sea el registro actual, llame a la función miembro `MoveFirst`, `MoveLast`, `MoveNext`o `MovePrev`.

Para obtener información relacionada, vea los temas "Move Method" y "MoveFirst, MoveLast, MoveNext, MovePrevious Methods" en la ayuda de DAO.

##  <a name="movefirst"></a>CDaoRecordset:: MoveFirst

Llame a esta función miembro para convertir el primer registro del conjunto de registros (si existe) en el registro actual.

```
void MoveFirst();
```

### <a name="remarks"></a>Observaciones

No es necesario llamar a `MoveFirst` inmediatamente después de abrir el conjunto de registros. En ese momento, el primer registro (si existe) se convierte automáticamente en el registro actual.

> [!CAUTION]
>  Si se llama a cualquiera de las funciones de `Move`, se produce una excepción si el conjunto de registros no tiene registros. En general, llame a `IsBOF` y `IsEOF` antes de una operación de movimiento para determinar si el conjunto de registros tiene registros. Después de llamar a `Open` o `Requery`, llame a `IsBOF` o a `IsEOF`.

> [!NOTE]
>  Si llama a cualquiera de las funciones de `Move` mientras el registro actual se está actualizando o agregando, las actualizaciones se pierden sin previo aviso.

Use las funciones de `Move` para pasar de un registro a otro sin aplicar una condición. Utilice las operaciones de búsqueda para buscar registros en un objeto de conjunto de registros de tipo Dynaset o de tipo snapshot que cumplan una condición determinada. Para buscar un registro en un objeto de conjunto de registros de tipo tabla, llame a `Seek`.

Si el conjunto de registros hace referencia a un conjunto de registros de tipo tabla, el movimiento sigue el índice actual de la tabla. Puede establecer el índice actual mediante la propiedad index del objeto DAO subyacente. Si no establece el índice actual, el orden de los registros devueltos es indefinido.

Si llama a `MoveLast` en un objeto de conjunto de registros basado en una consulta SQL o una definición de usuario, se fuerza la finalización de la consulta y el objeto de conjunto de registros se rellena por completo.

No se puede llamar a la función miembro `MoveFirst` o `MovePrev` con una instantánea de desplazamiento de solo avance.

Para mover la posición del registro actual en un objeto de conjunto de registros un número específico de registros hacia delante o hacia atrás, llame a `Move`.

Para obtener información relacionada, vea los temas "Move Method" y "MoveFirst, MoveLast, MoveNext, MovePrevious Methods" en la ayuda de DAO.

##  <a name="movelast"></a>CDaoRecordset:: MoveLast

Llame a esta función miembro para que el último registro (si existe) del conjunto de registros sea el registro actual.

```
void MoveLast();
```

### <a name="remarks"></a>Observaciones

> [!CAUTION]
>  Si se llama a cualquiera de las funciones de `Move`, se produce una excepción si el conjunto de registros no tiene registros. En general, llame a `IsBOF` y `IsEOF` antes de una operación de movimiento para determinar si el conjunto de registros tiene registros. Después de llamar a `Open` o `Requery`, llame a `IsBOF` o a `IsEOF`.

> [!NOTE]
>  Si llama a cualquiera de las funciones de `Move` mientras el registro actual se está actualizando o agregando, las actualizaciones se pierden sin previo aviso.

Use las funciones de `Move` para pasar de un registro a otro sin aplicar una condición. Utilice las operaciones de búsqueda para buscar registros en un objeto de conjunto de registros de tipo Dynaset o de tipo snapshot que cumplan una condición determinada. Para buscar un registro en un objeto de conjunto de registros de tipo tabla, llame a `Seek`.

Si el conjunto de registros hace referencia a un conjunto de registros de tipo tabla, el movimiento sigue el índice actual de la tabla. Puede establecer el índice actual mediante la propiedad index del objeto DAO subyacente. Si no establece el índice actual, el orden de los registros devueltos es indefinido.

Si llama a `MoveLast` en un objeto de conjunto de registros basado en una consulta SQL o una definición de usuario, se fuerza la finalización de la consulta y el objeto de conjunto de registros se rellena por completo.

Para mover la posición del registro actual en un objeto de conjunto de registros un número específico de registros hacia delante o hacia atrás, llame a `Move`.

Para obtener información relacionada, vea los temas "Move Method" y "MoveFirst, MoveLast, MoveNext, MovePrevious Methods" en la ayuda de DAO.

##  <a name="movenext"></a>CDaoRecordset:: MoveNext

Llame a esta función miembro para que el Registro siguiente en el conjunto de registros sea el registro actual.

```
void MoveNext();
```

### <a name="remarks"></a>Observaciones

Se recomienda llamar a `IsBOF` antes de intentar pasar al registro anterior. Una llamada a `MovePrev` producirá una `CDaoException` si `IsBOF` devuelve un valor distinto de cero, lo que indica que ya se ha desplazado antes del primer registro o que no se ha seleccionado ningún registro en el conjunto de registros.

> [!CAUTION]
>  Si se llama a cualquiera de las funciones de `Move`, se produce una excepción si el conjunto de registros no tiene registros. En general, llame a `IsBOF` y `IsEOF` antes de una operación de movimiento para determinar si el conjunto de registros tiene registros. Después de llamar a `Open` o `Requery`, llame a `IsBOF` o a `IsEOF`.

> [!NOTE]
>  Si llama a cualquiera de las funciones de `Move` mientras el registro actual se está actualizando o agregando, las actualizaciones se pierden sin previo aviso.

Use las funciones de `Move` para pasar de un registro a otro sin aplicar una condición. Utilice las operaciones de búsqueda para buscar registros en un objeto de conjunto de registros de tipo Dynaset o de tipo snapshot que cumplan una condición determinada. Para buscar un registro en un objeto de conjunto de registros de tipo tabla, llame a `Seek`.

Si el conjunto de registros hace referencia a un conjunto de registros de tipo tabla, el movimiento sigue el índice actual de la tabla. Puede establecer el índice actual mediante la propiedad index del objeto DAO subyacente. Si no establece el índice actual, el orden de los registros devueltos es indefinido.

Para mover la posición del registro actual en un objeto de conjunto de registros un número específico de registros hacia delante o hacia atrás, llame a `Move`.

Para obtener información relacionada, vea los temas "Move Method" y "MoveFirst, MoveLast, MoveNext, MovePrevious Methods" en la ayuda de DAO.

##  <a name="moveprev"></a>CDaoRecordset:: MovePrev

Llame a esta función miembro para que el registro anterior del conjunto de registros sea el registro actual.

```
void MovePrev();
```

### <a name="remarks"></a>Observaciones

Se recomienda llamar a `IsBOF` antes de intentar pasar al registro anterior. Una llamada a `MovePrev` producirá una `CDaoException` si `IsBOF` devuelve un valor distinto de cero, lo que indica que ya se ha desplazado antes del primer registro o que no se ha seleccionado ningún registro en el conjunto de registros.

> [!CAUTION]
>  Si se llama a cualquiera de las funciones de `Move`, se produce una excepción si el conjunto de registros no tiene registros. En general, llame a `IsBOF` y `IsEOF` antes de una operación de movimiento para determinar si el conjunto de registros tiene registros. Después de llamar a `Open` o `Requery`, llame a `IsBOF` o a `IsEOF`.

> [!NOTE]
>  Si llama a cualquiera de las funciones de `Move` mientras el registro actual se está actualizando o agregando, las actualizaciones se pierden sin previo aviso.

Use las funciones de `Move` para pasar de un registro a otro sin aplicar una condición. Utilice las operaciones de búsqueda para buscar registros en un objeto de conjunto de registros de tipo Dynaset o de tipo snapshot que cumplan una condición determinada. Para buscar un registro en un objeto de conjunto de registros de tipo tabla, llame a `Seek`.

Si el conjunto de registros hace referencia a un conjunto de registros de tipo tabla, el movimiento sigue el índice actual de la tabla. Puede establecer el índice actual mediante la propiedad index del objeto DAO subyacente. Si no establece el índice actual, el orden de los registros devueltos es indefinido.

No se puede llamar a la función miembro `MoveFirst` o `MovePrev` con una instantánea de desplazamiento de solo avance.

Para mover la posición del registro actual en un objeto de conjunto de registros un número específico de registros hacia delante o hacia atrás, llame a `Move`.

Para obtener información relacionada, vea los temas "Move Method" y "MoveFirst, MoveLast, MoveNext, MovePrevious Methods" en la ayuda de DAO.

##  <a name="open"></a>CDaoRecordset:: Open

Debe llamar a esta función miembro para recuperar los registros del conjunto de registros.

```
virtual void Open(
    int nOpenType = AFX_DAO_USE_DEFAULT_TYPE,
    LPCTSTR lpszSQL = NULL,
    int nOptions = 0);

virtual void Open(
    CDaoTableDef* pTableDef,
    int nOpenType = dbOpenTable,
    int nOptions = 0);

virtual void Open(
    CDaoQueryDef* pQueryDef,
    int nOpenType = dbOpenDynaset,
    int nOptions = 0);
```

### <a name="parameters"></a>Parámetros

*nOpenType*<br/>
Uno de los valores siguientes:

- `dbOpenDynaset` un conjunto de registros de tipo Dynaset con desplazamiento bidireccional. Este es el valor predeterminado.

- `dbOpenTable` un conjunto de registros de tipo tabla con desplazamiento bidireccional.

- `dbOpenSnapshot` un conjunto de registros de tipo Snapshot con desplazamiento bidireccional.

*lpszSQL*<br/>
Puntero de cadena que contiene uno de los elementos siguientes:

- Un puntero NULL.

- El nombre de una o varias definiciones de una o más definiciones de (separadas por comas).

- Una instrucción **Select** de SQL (opcionalmente con una cláusula **Where** o **ORDERBY** de SQL).

- Una consulta de paso a través.

*nOptions*<br/>
Una o varias de las opciones que se enumeran a continuación. El valor predeterminado es 0. Los valores posibles son los siguientes:

- `dbAppendOnly` solo puede anexar nuevos registros (solo el conjunto de registros de tipo Dynaset). Esta opción significa literalmente que solo se pueden anexar los registros. Las clases de base de datos ODBC de MFC tienen una opción de solo anexar que permite recuperar y anexar registros.

- `dbForwardOnly` el conjunto de registros es una instantánea de desplazamiento de solo avance.

- `dbSeeChanges` generar una excepción si otro usuario está cambiando los datos que está editando.

- `dbDenyWrite` otros usuarios no pueden modificar ni agregar registros.

- `dbDenyRead` otros usuarios no pueden ver los registros (solo en el conjunto de registros de tipo tabla).

- `dbReadOnly` solo puede ver los registros; otros usuarios pueden modificarlos.

- `dbInconsistent` se permiten actualizaciones incoherentes (solo conjunto de registros de tipo Dynaset).

- `dbConsistent` solo se permiten actualizaciones coherentes (solo conjunto de registros de tipo Dynaset).

> [!NOTE]
>  Las constantes `dbConsistent` y `dbInconsistent` son mutuamente excluyentes. Puede usar uno u otro, pero no ambos en una instancia determinada de `Open`.

*pTableDef*<br/>
Un puntero a un objeto [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) . Esta versión solo es válida para los conjuntos de registros de tipo de tabla. Al utilizar esta opción, no se utiliza el puntero `CDaoDatabase` utilizado para construir el `CDaoRecordset`; en su lugar, se usa la base de datos en la que reside el TableDef.

*pQueryDef*<br/>
Un puntero a un objeto [CDaoQueryDef](../../mfc/reference/cdaoquerydef-class.md) . Esta versión solo es válida para los conjuntos de registros de tipo Dynaset y tipo de instantánea. Al utilizar esta opción, no se utiliza el puntero `CDaoDatabase` utilizado para construir el `CDaoRecordset`; en su lugar, se utiliza la base de datos en la que reside la QueryDef.

### <a name="remarks"></a>Observaciones

Antes de llamar a `Open`, debe construir el objeto de conjunto de registros. Existen varias formas de hacerlo:

- Al construir el objeto de conjunto de registros, pase un puntero a un objeto `CDaoDatabase` que ya está abierto.

- Al construir el objeto de conjunto de registros, pase un puntero a un objeto `CDaoDatabase` que no esté abierto. El conjunto de registros abre un objeto de `CDaoDatabase`, pero no lo cerrará cuando se cierre el objeto de conjunto de registros.

- Cuando se construye el objeto de conjunto de registros, se pasa un puntero nulo. El objeto de conjunto de registros llama a `GetDefaultDBName` para obtener el nombre de Microsoft Access. Archivo MDB que se va a abrir. Después, el conjunto de registros abre un objeto `CDaoDatabase` y lo mantiene abierto mientras el conjunto de registros esté abierto. Cuando se llama a `Close` en el conjunto de registros, también se cierra el objeto `CDaoDatabase`.

    > [!NOTE]
    >  Cuando el conjunto de registros abre el objeto `CDaoDatabase`, abre el origen de datos con acceso no exclusivo.

Para la versión de `Open` que usa el parámetro *lpszSQL* , una vez abierto el conjunto de registros, puede recuperar los registros de una de varias maneras. La primera opción es tener funciones DFX en el `DoFieldExchange`. La segunda opción consiste en usar el enlace dinámico llamando a la función miembro `GetFieldValue`. Estas opciones se pueden implementar por separado o en combinación. Si se combinan, tendrá que pasar la instrucción SQL por la llamada a `Open`.

Cuando se usa la segunda versión de `Open` en la que se pasa un objeto `CDaoTableDef`, las columnas resultantes estarán disponibles para enlazarse a través de `DoFieldExchange` y el mecanismo DFX, y/o enlazar dinámicamente a través de `GetFieldValue`.

> [!NOTE]
>  Solo se puede llamar a `Open` mediante un objeto `CDaoTableDef` para conjuntos de registros de tipo tabla.

Cuando se usa la tercera versión de `Open` en la que se pasa un objeto `CDaoQueryDef`, se ejecutará esa consulta y las columnas resultantes estarán disponibles para que se puedan enlazar a través de `DoFieldExchange` y el mecanismo DFX, y/o enlazar dinámicamente a través de `GetFieldValue`.

> [!NOTE]
>  Solo se puede llamar a `Open` mediante un objeto `CDaoQueryDef` para los conjuntos de registros de tipo Dynaset y tipo de instantánea.

En la primera versión de `Open` que usa el parámetro `lpszSQL`, los registros se seleccionan en función de los criterios que se muestran en la tabla siguiente.

|Valor del parámetro `lpszSQL`|Los registros seleccionados están determinados por|Ejemplo|
|--------------------------------------|----------------------------------------|-------------|
|NULL|La cadena devuelta por `GetDefaultSQL`.||
|Lista separada por comas de uno o más nombres de definiciones de de y/o QueryDef.|Todas las columnas representadas en el `DoFieldExchange`.|`"Customer"`|
|**Seleccionar** columna-lista **de** tabla-lista|Columnas especificadas de los objetos tabledef y/o QueryDef especificados.|`"SELECT CustId, CustName`<br /><br /> `FROM Customer"`|

El procedimiento habitual es pasar NULL a `Open`; en ese caso, `Open` llama a `GetDefaultSQL`, una función miembro reemplazable que ClassWizard genera al crear una clase derivada de `CDaoRecordset`. Este valor proporciona el nombre de la definición de usuario (s) y/o el nombre de la QueryDef especificado en ClassWizard. En su lugar, puede especificar otra información en el parámetro *lpszSQL* .

Lo que pase, `Open` crea una cadena de SQL final para la consulta (la cadena puede tener las cláusulas **Where** y **ORDERBY** de SQL anexadas a la cadena *lpszSQL* pasada) y, a continuación, ejecuta la consulta. Puede examinar la cadena construida llamando a `GetSQL` después de llamar a `Open`.

Los miembros de datos de campo de la clase de conjunto de registros están enlazados a las columnas de los datos seleccionados. Si se devuelve algún registro, el primer registro se convierte en el registro actual.

Si desea establecer las opciones del conjunto de registros, como un filtro o una ordenación, establezca `m_strSort` o `m_strFilter` después de crear el objeto de conjunto de registros, pero antes de llamar a `Open`. Si desea actualizar los registros del conjunto de registros después de que el conjunto de registros ya esté abierto, llame a `Requery`.

Si llama a `Open` en un conjunto de registros de tipo Dynaset o de instantánea, o si el origen de datos hace referencia a una instrucción SQL o a una definición de tipos que representa una tabla adjunta, no puede usar `dbOpenTable` para el argumento de tipo; Si lo hace, MFC produce una excepción. Para determinar si un objeto TableDef representa una tabla adjunta, cree un objeto [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) y llame a su función miembro [GetConnect](../../mfc/reference/cdaotabledef-class.md#getconnect) .

Use la marca `dbSeeChanges` si desea capturar los cambios realizados por otro usuario u otro programa de la máquina al editar o eliminar el mismo registro. Por ejemplo, si dos usuarios inician la edición del mismo registro, el primer usuario que llama a la función miembro `Update` se realiza correctamente. Cuando el segundo usuario llama a `Update`, se produce una `CDaoException`. Del mismo modo, si el segundo usuario intenta llamar a `Delete` para eliminar el registro y ya lo ha cambiado el primer usuario, se produce una `CDaoException`.

Normalmente, si el usuario obtiene este `CDaoException` durante la actualización, el código debe actualizar el contenido de los campos y recuperar los valores recién modificados. Si la excepción se produce en el proceso de eliminación, el código podría mostrar los datos del nuevo registro al usuario y un mensaje que indica que los datos han cambiado recientemente. En este momento, el código puede solicitar una confirmación de que el usuario aún desea eliminar el registro.

> [!TIP]
>  Use la opción de desplazamiento solo hacia delante (`dbForwardOnly`) para mejorar el rendimiento cuando la aplicación realiza un solo paso a través de un conjunto de registros abierto desde un origen de datos ODBC.

Para obtener información relacionada, vea el tema "método OpenRecordset" en la ayuda de DAO.

##  <a name="requery"></a>CDaoRecordset:: Requery

Llame a esta función miembro para volver a generar (actualizar) un conjunto de registros.

```
virtual void Requery();
```

### <a name="remarks"></a>Observaciones

Si se devuelve algún registro, el primer registro se convierte en el registro actual.

Para que el conjunto de registros refleje las adiciones y eliminaciones que usted u otros usuarios realizan en el origen de datos, debe volver a generar el conjunto de registros llamando a `Requery`. Si el conjunto de registros es un Dynaset, refleja automáticamente las actualizaciones que usted u otros usuarios realizan en sus registros existentes (pero no en las adiciones). Si el conjunto de registros es una instantánea, debe llamar a `Requery` para reflejar las modificaciones realizadas por otros usuarios, así como las adiciones y eliminaciones.

En el caso de una instantánea o de un Dynaset, llame a `Requery` en cualquier momento en el que desee volver a generar el conjunto de registros con los valores de los parámetros. Establezca el nuevo filtro u orden estableciendo [m_strFilter](#m_strfilter) y [m_strSort](#m_strsort) antes de llamar a `Requery`. Establezca nuevos parámetros asignando nuevos valores a los miembros de datos de parámetro antes de llamar a `Requery`.

Si se produce un error al intentar volver a generar el conjunto de registros, se cierra el conjunto de registros. Antes de llamar a `Requery`, puede determinar si el conjunto de registros se puede consultar mediante una llamada a la función miembro [CanRestart](#canrestart) . `CanRestart` no garantiza que `Requery` se realizará correctamente.

> [!CAUTION]
>  Llame a `Requery` solo después de haber llamado a `Open`.

> [!NOTE]
>  Al llamar a [Requery](#requery) se cambian los marcadores DAO.

No se puede llamar a `Requery` en un conjunto de registros de tipo Dynaset o de instantánea si la llamada a `CanRestart` devuelve 0, y no se puede usar en un conjunto de registros de tipo tabla.

Si tanto `IsBOF` como `IsEOF` devuelven un valor distinto de cero después de llamar a `Requery`, la consulta no devolvió ningún registro y el conjunto de registros no contendrá ningún dato.

Para obtener información relacionada, vea el tema sobre el método Requery en la ayuda de DAO.

##  <a name="seek"></a>CDaoRecordset:: Seek

Llame a esta función miembro para ubicar el registro en un objeto de conjunto de registros de tipo tabla indizado que cumpla los criterios especificados para el índice actual y haga que registre el registro actual.

```
BOOL Seek(
    LPCTSTR lpszComparison,
    COleVariant* pKey1,
    COleVariant* pKey2 = NULL,
    COleVariant* pKey3 = NULL);

BOOL Seek(
    LPCTSTR lpszComparison,
    COleVariant* pKeyArray,
    WORD nKeys);
```

### <a name="parameters"></a>Parámetros

*lpszComparison*<br/>
Una de las siguientes expresiones de cadena: "<", "\<=", "=", "> =" o ">".

*pKey1*<br/>
Puntero a [COleVariant](../../mfc/reference/colevariant-class.md) cuyo valor corresponde al primer campo del índice. Necesario.

*pKey2*<br/>
Un puntero a un `COleVariant` cuyo valor corresponde al segundo campo del índice, si existe. Su valor predeterminado es NULL.

*pKey3*<br/>
Un puntero a un `COleVariant` cuyo valor corresponde al tercer campo del índice, si existe. Su valor predeterminado es NULL.

*pKeyArray*<br/>
Puntero a una matriz de variantes. El tamaño de la matriz se corresponde con el número de campos del índice.

*nKeys*<br/>
Entero que corresponde al tamaño de la matriz, que es el número de campos del índice.

> [!NOTE]
>  No especifique caracteres comodín en las claves. Los caracteres comodín harán que `Seek` no devuelvan registros coincidentes.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si se encuentran registros coincidentes; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Use la segunda versión (matriz) de `Seek` para administrar los índices de cuatro campos o más.

`Seek` habilita la búsqueda de índices de alto rendimiento en conjuntos de registros de tipo tabla. Debe establecer el índice actual llamando a `SetCurrentIndex` antes de llamar a `Seek`. Si el Índice identifica un campo o campos de clave no únicos, `Seek` busca el primer registro que cumpla los criterios. Si no se establece un índice, se produce una excepción.

Tenga en cuenta que si no va a crear un conjunto de registros Unicode, los objetos `COleVariant` se deben declarar explícitamente como ANSI. Esto puede hacerse mediante el uso de la forma [COleVariant:: COleVariant](../../mfc/reference/colevariant-class.md#colevariant) **(** *lpszSrc* **,** *vtSrc* **)** del constructor con *vtSrc* establecido en `VT_BSTRT` (ANSI) o mediante la función `COleVariant` [setString](../../mfc/reference/colevariant-class.md#setstring) **(** *lpszSrc* **,** *vtSrc* **)** con *vtSrc* establecida en `VT_BSTRT`.

Cuando se llama a `Seek`, se pasan uno o varios valores de clave y un operador de comparación ("<", "\<=", "=", "> =" o ">"). `Seek` busca en los campos de clave especificados y localiza el primer registro que cumple los criterios especificados por *lpszComparison* y *pKey1*. Una vez encontrado, `Seek` devuelve un valor distinto de cero y hace que ese registro sea el actual. Si `Seek` no encuentra ninguna coincidencia, `Seek` devuelve cero y el registro actual no está definido. Al usar DAO directamente, debe comprobar explícitamente la propiedad NoMatch.

Si `lpszComparison` es "=", "> =" o ">", `Seek` comienza al principio del índice. Si *lpszComparison* es "<" o "< =", `Seek` se inicia al final del índice y busca hacia atrás a menos que haya entradas de índice duplicadas al final. En este caso, `Seek` comienza en una entrada arbitraria entre las entradas de índice duplicadas al final del índice.

No es necesario que sea un registro actual cuando se utiliza `Seek`.

Para buscar un registro en un conjunto de registros de tipo Dynaset o de instantánea que satisfaga una condición específica, use las operaciones de búsqueda. Para incluir todos los registros, no solo aquellos que cumplan una condición específica, use las operaciones de movimiento para moverse de un registro a otro.

No se puede llamar a `Seek` en una tabla adjunta de ningún tipo, ya que las tablas asociadas deben abrirse como conjuntos de registros de tipo Dynaset o de tipo Snapshot. Sin embargo, si llama a `CDaoDatabase::Open` para abrir directamente una base de datos ISAM instalable, puede llamar a `Seek` en las tablas de esa base de datos, aunque el rendimiento puede ser lento.

Para obtener información relacionada, vea el tema sobre el método Seek en la ayuda de DAO.

##  <a name="setabsoluteposition"></a>CDaoRecordset:: SetAbsolutePosition

Establece el número de registro relativo del registro actual de un objeto de conjunto de registros.

```
void SetAbsolutePosition(long lPosition);
```

### <a name="parameters"></a>Parámetros

*lPosition*<br/>
Corresponde a la posición ordinal del registro actual en el conjunto de registros.

### <a name="remarks"></a>Observaciones

La llamada a `SetAbsolutePosition` permite colocar el puntero del registro actual en un registro específico en función de su posición ordinal en un conjunto de registros de tipo Dynaset o de tipo Snapshot. También puede determinar el número de registro actual llamando a [GetAbsolutePosition](#getabsoluteposition).

> [!NOTE]
>  Esta función miembro solo es válida para los conjuntos de registros de tipo Dynaset y tipo de instantánea.

El valor de la propiedad AbsolutePosition del objeto DAO subyacente es de base cero; un valor de 0 hace referencia al primer registro del conjunto de registros. Si se establece un valor mayor que el número de registros rellenados, MFC producirá una excepción. Puede determinar el número de registros rellenados en el conjunto de registros llamando a la función miembro `GetRecordCount`.

Si se elimina el registro actual, el valor de la propiedad AbsolutePosition no se define y MFC inicia una excepción si se hace referencia a él. Los nuevos registros se agregan al final de la secuencia.

> [!NOTE]
>  Esta propiedad no está pensada para usarse como un número de registro suplente. Los marcadores siguen siendo la forma recomendada de conservar y volver a una posición determinada y son la única manera de colocar el registro actual en todos los tipos de objetos de conjunto de registros que admiten marcadores. En concreto, la posición de un registro determinado cambia cuando se eliminan los registros que lo preceden. Tampoco existe la garantía de que un registro determinado tendrá la misma posición absoluta si el conjunto de registros se vuelve a crear porque el orden de los registros individuales dentro de un conjunto de registros no está garantizado a menos que se cree con una instrucción SQL mediante una cláusula **ORDERBY** .

Para obtener información relacionada, vea el tema "propiedad AbsolutePosition" en la ayuda de DAO.

##  <a name="setbookmark"></a>CDaoRecordset:: SetBookmark

Llame a esta función miembro para colocar el conjunto de registros en el registro que contiene el marcador especificado.

```
void SetBookmark(COleVariant varBookmark);
```

### <a name="parameters"></a>Parámetros

*varBookmark*<br/>
Objeto [COleVariant](../../mfc/reference/colevariant-class.md) que contiene el valor de marcador de un registro específico.

### <a name="remarks"></a>Observaciones

Cuando se crea o se abre un objeto de conjunto de registros, cada uno de sus registros tiene ya un marcador único. Puede recuperar el marcador del registro actual llamando a `GetBookmark` y guardando el valor en un objeto `COleVariant`. Más adelante puede volver a ese registro llamando a `SetBookmark` mediante el valor de marcador guardado.

> [!NOTE]
>  Al llamar a [Requery](#requery) se cambian los marcadores DAO.

Tenga en cuenta que si no va a crear un conjunto de registros Unicode, el objeto `COleVariant` se debe declarar explícitamente como ANSI. Esto puede hacerse mediante el uso de la forma [COleVariant:: COleVariant](../../mfc/reference/colevariant-class.md#colevariant) **(** *lpszSrc* **,** *vtSrc* **)** del constructor con *vtSrc* establecido en `VT_BSTRT` (ANSI) o mediante la función `COleVariant` [setString](../../mfc/reference/colevariant-class.md#setstring) **(** *lpszSrc* **,** *vtSrc* **)** con *vtSrc* establecida en `VT_BSTRT`.

Para obtener información relacionada, vea los temas sobre la propiedad Bookmark y la propiedad Bookmarkable en la ayuda de DAO.

##  <a name="setcachesize"></a>CDaoRecordset:: SetCacheSize

Llame a esta función miembro para establecer el número de registros que se van a almacenar en caché.

```
void SetCacheSize(long lSize);
```

### <a name="parameters"></a>Parámetros

*lSize*<br/>
Especifica el número de registros. Un valor típico es 100. Un valor de 0 desactiva el almacenamiento en caché. El valor debe estar comprendido entre 5 y 1200 registros. La memoria caché puede utilizar una cantidad de memoria considerable.

### <a name="remarks"></a>Observaciones

Una memoria caché es un espacio en memoria local que contiene los datos recuperados más recientemente del servidor en caso de que se vuelvan a solicitar los datos mientras se ejecuta la aplicación. El almacenamiento en caché de datos mejora el rendimiento de una aplicación que recupera datos de un servidor remoto a través de objetos de conjunto de registros de tipo Dynaset. Cuando se solicitan datos, el motor de base de datos de Microsoft Jet comprueba primero la memoria caché de los datos solicitados en lugar de recuperarlos del servidor, lo que tarda más tiempo. Los datos que no proceden de un origen de datos ODBC no se guardan en la memoria caché.

Cualquier origen de datos ODBC, como una tabla adjunta, puede tener una memoria caché local. Para crear la memoria caché, abra un objeto de conjunto de registros desde el origen de datos remoto, llame a las funciones miembro `SetCacheSize` y `SetCacheStart` y, a continuación, llame a la función miembro `FillCache` o recorra los registros mediante una de las operaciones de movimiento. El parámetro *Lsize* de la función miembro `SetCacheSize` puede basarse en el número de registros con los que la aplicación puede trabajar al mismo tiempo. Por ejemplo, si usa un conjunto de registros como el origen de los datos que se van a mostrar en la pantalla, puede pasar el parámetro `SetCacheSize` *Lsize* como 20 para mostrar 20 registros al mismo tiempo.

Para obtener información relacionada, vea el tema "propiedades CacheSize, CacheStart" en la ayuda de DAO.

##  <a name="setcachestart"></a>CDaoRecordset:: SetCacheStart

Llame a esta función miembro para especificar el marcador del primer registro del conjunto de registros que se va a almacenar en caché.

```
void SetCacheStart(COleVariant varBookmark);
```

### <a name="parameters"></a>Parámetros

*varBookmark*<br/>
[COleVariant](../../mfc/reference/colevariant-class.md) que especifica el marcador del primer registro del conjunto de registros que se va a almacenar en caché.

### <a name="remarks"></a>Observaciones

Puede usar el valor de marcador de cualquier registro para el parámetro *varBookmark* de la función miembro `SetCacheStart`. Haga que el registro que desea que inicie la memoria caché con el registro actual, establezca un marcador para ese registro mediante [SetBookmark](#setbookmark)y pase el valor de marcador como parámetro para la función miembro `SetCacheStart`.

El motor de base de datos de Microsoft Jet solicita registros dentro del intervalo de caché de la memoria caché y solicita registros fuera del intervalo de caché del servidor.

Los registros recuperados de la memoria caché no reflejan los cambios realizados simultáneamente en los datos de origen de otros usuarios.

Para forzar una actualización de todos los datos en caché, pase el parámetro *Lsize* de `SetCacheSize` como 0, llame a `SetCacheSize` de nuevo con el tamaño de la memoria caché que solicitó originalmente y, a continuación, llame a la función miembro `FillCache`.

Tenga en cuenta que si no va a crear un conjunto de registros Unicode, el objeto `COleVariant` se debe declarar explícitamente como ANSI. Esto puede hacerse mediante el uso de la forma [COleVariant:: COleVariant](../../mfc/reference/colevariant-class.md#colevariant) **(** *lpszSrc* **,** *vtSrc* **)** del constructor con *vtSrc* establecido en `VT_BSTRT` (ANSI) o mediante la función `COleVariant` [setString](../../mfc/reference/colevariant-class.md#setstring) **(** *lpszSrc* **,** *vtSrc* **)** con *vtSrc* establecida en `VT_BSTRT`.

Para obtener información relacionada, vea el tema CacheSize, CacheStart Properties en la ayuda de DAO.

##  <a name="setcurrentindex"></a>CDaoRecordset:: SetCurrentIndex

Llame a esta función miembro para establecer un índice en un conjunto de registros de tipo tabla.

```
void SetCurrentIndex(LPCTSTR lpszIndex);
```

### <a name="parameters"></a>Parámetros

*lpszIndex*<br/>
Puntero que contiene el nombre del índice que se va a establecer.

### <a name="remarks"></a>Observaciones

Los registros de las tablas base no se almacenan en ningún orden concreto. La configuración de un índice cambia el orden de los registros devueltos por la base de datos, pero no afecta al orden en el que se almacenan los registros. El índice especificado ya debe estar definido. Si intenta usar un objeto de índice que no existe, o si no se establece el índice al llamar a [Seek](#seek), MFC produce una excepción.

Puede crear un nuevo índice para la tabla llamando a [CDaoTableDef:: CreateIndex](../../mfc/reference/cdaotabledef-class.md#createindex) y anexando el nuevo índice a la colección Indexes del objeto TableDef subyacente mediante una llamada a [CDaoTableDef:: Append](../../mfc/reference/cdaotabledef-class.md#append)y, a continuación, volver a abrir el conjunto de registros.

Los registros devueltos de un conjunto de registros de tipo tabla solo se pueden ordenar por los índices definidos para el objeto TableDef subyacente. Para ordenar los registros en otro orden, puede abrir un conjunto de registros de tipo Dynaset o de tipo Snapshot mediante una cláusula **ORDERBY** de SQL almacenada en [CDaoRecordset:: m_strSort](#m_strsort).

Para obtener información relacionada, vea el tema sobre el objeto index y la definición de "índice actual" en la ayuda de DAO.

##  <a name="setfielddirty"></a>CDaoRecordset:: SetFieldDirty

Llame a esta función miembro para marcar un miembro de datos de campo del conjunto de registros como cambiado o como inalterado.

```
void SetFieldDirty(
    void* pv,
    BOOL bDirty = TRUE);
```

### <a name="parameters"></a>Parámetros

*FV*<br/>
Contiene la dirección de un miembro de datos de campo en el conjunto de registros o NULL. Si es NULL, se marcan todos los miembros de datos de campo del conjunto de registros. (C++ NULL no es lo mismo que null en la terminología de bases de datos, lo que significa que "no tiene ningún valor").

*bDirty*<br/>
TRUE si el miembro de datos de campo se va a marcar como "sucio" (cambiado). De lo contrario, es FALSE si el miembro de datos de campo se va a marcar como "Clean" (sin cambios).

### <a name="remarks"></a>Observaciones

Marcar campos como sin cambios garantiza que el campo no se actualice.

El marco marca los miembros de datos de campo modificados para asegurarse de que se escribirán en el registro del origen de datos mediante el mecanismo de intercambio de campos de registros (DFX) de DAO. Al cambiar el valor de un campo, normalmente se establece el campo modificado automáticamente, por lo que rara vez tendrá que llamar a `SetFieldDirty`, pero en ocasiones querrá asegurarse de que las columnas se actualicen o inserten explícitamente, independientemente del valor que se encuentre en el miembro de datos del campo. El mecanismo DFX también emplea el uso de PSEUDONULL. Para obtener más información, vea [CDaoFieldExchange:: m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

Si no se utiliza el mecanismo de almacenamiento en búfer doble, al cambiar el valor del campo no se establece automáticamente el campo como modificado. En este caso, será necesario establecer explícitamente el campo como modificado. La marca contenida en [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) controla esta comprobación automática de campos.

> [!NOTE]
>  Llame a esta función miembro solo después de haber llamado a [Edit](#edit) o [AddNew](#addnew).

Si se usa NULL para el primer argumento de la función, se aplicará la función a todos los campos de `outputColumn`, no a los campos de **parámetros** de `CDaoFieldExchange`. Por ejemplo, la llamada

[!code-cpp[NVC_MFCDatabase#6](../../mfc/codesnippet/cpp/cdaorecordset-class_6.cpp)]

establecerá solo `outputColumn` campos en NULL; los campos de **parámetros** no se verán afectados.

Para trabajar en un **parámetro**, debe proporcionar la dirección real del **parámetro** individual en el que desea trabajar, por ejemplo:

[!code-cpp[NVC_MFCDatabase#7](../../mfc/codesnippet/cpp/cdaorecordset-class_7.cpp)]

Esto significa que no se pueden establecer todos los campos de **parámetros** en null, como se puede hacer con `outputColumn` campos.

`SetFieldDirty` se implementa a través de `DoFieldExchange`.

##  <a name="setfieldnull"></a>CDaoRecordset:: SetFieldNull

Llame a esta función miembro para marcar un miembro de datos de campo del conjunto de registros como null (específicamente sin ningún valor) o como no NULL.

```
void SetFieldNull(
    void* pv,
    BOOL bNull = TRUE);
```

### <a name="parameters"></a>Parámetros

*FV*<br/>
Contiene la dirección de un miembro de datos de campo en el conjunto de registros o NULL. Si es NULL, se marcan todos los miembros de datos de campo del conjunto de registros. (C++ NULL no es lo mismo que null en la terminología de bases de datos, lo que significa que "no tiene ningún valor").

*bNull*<br/>
Distinto de cero si el miembro de datos de campo se va a marcar como sin valor (NULL). De lo contrario, es 0 si el miembro de datos de campo se va a marcar como no NULL.

### <a name="remarks"></a>Observaciones

`SetFieldNull` se utiliza para los campos enlazados en el mecanismo de `DoFieldExchange`.

Al agregar un nuevo registro a un conjunto de registros, todos los miembros de datos de campo se establecen inicialmente en un valor NULL y se marcan como "sucio" (cambiado). Cuando se recupera un registro de un origen de datos, sus columnas ya tienen valores o son NULL. Si no es adecuado convertir un campo en null, se produce [CDaoException](../../mfc/reference/cdaoexception-class.md) .

Si utiliza el mecanismo de almacenamiento en búfer doble, por ejemplo, si desea designar específicamente un campo del registro actual como sin valor, llame a `SetFieldNull` con *bNull* establecido en true para marcarlo como null. Si un campo se marcó previamente como NULL y ahora desea darle un valor, simplemente establezca su nuevo valor. No es necesario quitar la marca nula con `SetFieldNull`. Para determinar si el campo puede ser null, llame a [IsFieldNullable](#isfieldnullable).

Si no utiliza el mecanismo de almacenamiento en búfer doble, al cambiar el valor del campo no se establece automáticamente el campo como modificado y no NULL. Debe establecer específicamente los campos modificados y no nulos. La marca contenida en [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) controla esta comprobación automática de campos.

El mecanismo DFX emplea el uso de PSEUDONULL. Para obtener más información, vea [CDaoFieldExchange:: m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

> [!NOTE]
>  Llame a esta función miembro solo después de haber llamado a [Edit](#edit) o [AddNew](#addnew).

Si se usa NULL para el primer argumento de la función, solo se aplicará la función a los campos `outputColumn`, no a los campos de **parámetros** de `CDaoFieldExchange`. Por ejemplo, la llamada

[!code-cpp[NVC_MFCDatabase#8](../../mfc/codesnippet/cpp/cdaorecordset-class_8.cpp)]

establecerá solo `outputColumn` campos en NULL; los campos de **parámetros** no se verán afectados.

##  <a name="setfieldvalue"></a>CDaoRecordset:: SetFieldValue

Llame a esta función miembro para establecer el valor de un campo, ya sea por posición ordinal o cambiando el valor de la cadena.

```
virtual void SetFieldValue(
    LPCTSTR lpszName,
    const COleVariant& varValue);

virtual void SetFieldValue(
    int nIndex,
    const COleVariant& varValue);

void SetFieldValue(
    LPCTSTR lpszName,
    LPCTSTR lpszValue);

void SetFieldValue(
    int nIndex,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>Parámetros

*lpszName*<br/>
Puntero a una cadena que contiene el nombre de un campo.

*varValue*<br/>
Referencia a un objeto [COleVariant](../../mfc/reference/colevariant-class.md) que contiene el valor del contenido del campo.

*nIndex*<br/>
Entero que representa la posición ordinal del campo en la colección de campos del conjunto de registros (basada en cero).

*lpszValue*<br/>
Puntero a una cadena que contiene el valor del contenido del campo.

### <a name="remarks"></a>Observaciones

Use `SetFieldValue` y [GetFieldValue](#getfieldvalue) para enlazar dinámicamente campos en tiempo de ejecución en lugar de enlazar columnas estáticamente mediante el mecanismo [DoFieldExchange](#dofieldexchange) .

Tenga en cuenta que si no va a crear un conjunto de registros Unicode, debe utilizar una forma de `SetFieldValue` que no contenga un parámetro `COleVariant`, o bien el objeto `COleVariant` se debe declarar explícitamente como ANSI. Esto puede hacerse mediante el uso de la forma [COleVariant:: COleVariant](../../mfc/reference/colevariant-class.md#colevariant) **(** *lpszSrc* **,** *vtSrc* **)** del constructor con *vtSrc* establecido en `VT_BSTRT` (ANSI) o mediante la función `COleVariant` [setString](../../mfc/reference/colevariant-class.md#setstring) **(** *lpszSrc* **,** *vtSrc* **)** con *vtSrc* establecida en `VT_BSTRT`.

Para obtener información relacionada, vea los temas "objeto de campo" y "propiedad de valor" en la ayuda de DAO.

##  <a name="setfieldvaluenull"></a>CDaoRecordset:: SetFieldValueNull

Llame a esta función miembro para establecer el campo en un valor null.

```
void SetFieldValueNull(int nIndex);
void SetFieldValueNull(LPCTSTR lpszName);
```

### <a name="parameters"></a>Parámetros

*nIndex*<br/>
Índice del campo en el conjunto de registros, para la búsqueda por índice de base cero.

*lpszName*<br/>
Nombre del campo en el conjunto de registros, para buscar por nombre.

### <a name="remarks"></a>Observaciones

C++NULL no es lo mismo que null, que, en la terminología de bases de datos, significa "no tener ningún valor".

Para obtener información relacionada, vea los temas "objeto de campo" y "propiedad de valor" en la ayuda de DAO.

##  <a name="setlockingmode"></a>CDaoRecordset:: SetLockingMode

Llame a esta función miembro para establecer el tipo de bloqueo del conjunto de registros.

```
void SetLockingMode(BOOL bPessimistic);
```

### <a name="parameters"></a>Parámetros

*bPessimistic*<br/>
Marca que indica el tipo de bloqueo.

### <a name="remarks"></a>Observaciones

Cuando el bloqueo pesimista está en vigor, la página de 2K que contiene el registro que está editando se bloquea en cuanto se llama a la función miembro `Edit`. La página se desbloquea cuando se llama a la función miembro `Update` o `Close` o a cualquiera de las operaciones de movimiento o búsqueda.

Cuando el bloqueo optimista está en vigor, la página de 2K que contiene el registro solo se bloquea mientras el registro se está actualizando con la función miembro `Update`.

Si una página está bloqueada, ningún otro usuario podrá editar los registros en la misma página. Si llama a `SetLockingMode` y pasa un valor distinto de cero y otro usuario ya tiene la página bloqueada, se produce una excepción al llamar a `Edit`. Otros usuarios pueden leer datos de las páginas bloqueadas.

Si llama a `SetLockingMode` con un valor de cero y después llama a `Update` mientras la página está bloqueada por otro usuario, se produce una excepción. Para ver los cambios realizados por otro usuario en el registro (y perder los cambios), llame a la función miembro `SetBookmark` con el valor de marcador del registro actual.

Al trabajar con orígenes de datos ODBC, el modo de bloqueo siempre es optimista.

##  <a name="setparamvalue"></a>CDaoRecordset:: SetParamValue

Llame a esta función miembro para establecer el valor de un parámetro en el conjunto de registros en tiempo de ejecución.

```
virtual void SetParamValue(
    int nIndex,
    const COleVariant& varValue);

virtual void SetParamValue(
    LPCTSTR lpszName,
    const COleVariant& varValue);
```

### <a name="parameters"></a>Parámetros

*nIndex*<br/>
Posición numérica del parámetro en la colección de parámetros de la definición de la definición.

*var*<br/>
Valor que se va a establecer. Vea la sección Comentarios.

*lpszName*<br/>
Nombre del parámetro cuyo valor se va a establecer.

### <a name="remarks"></a>Observaciones

El parámetro ya se debe haber establecido como parte de la cadena de SQL del conjunto de registros. Puede tener acceso al parámetro por el nombre o por su posición de índice en la colección.

Especifique el valor que se va a establecer como un objeto de `COleVariant`. Para obtener información sobre cómo establecer el valor y el tipo deseado en el objeto `COleVariant`, vea la clase [COleVariant](../../mfc/reference/colevariant-class.md). Tenga en cuenta que si no va a crear un conjunto de registros Unicode, el objeto `COleVariant` se debe declarar explícitamente como ANSI. Esto puede hacerse mediante el uso de la forma [COleVariant:: COleVariant](../../mfc/reference/colevariant-class.md#colevariant) **(** *lpszSrc* **,** *vtSrc* **)** del constructor con *vtSrc* establecido en `VT_BSTRT` (ANSI) o mediante la función `COleVariant` [setString](../../mfc/reference/colevariant-class.md#setstring) **(** *lpszSrc* **,** *vtSrc* **)** con *vtSrc* establecida en `VT_BSTRT`.

##  <a name="setparamvaluenull"></a>CDaoRecordset:: SetParamValueNull

Llame a esta función miembro para establecer el parámetro en un valor null.

```
void SetParamValueNull(int nIndex);
void SetParamValueNull(LPCTSTR lpszName);
```

### <a name="parameters"></a>Parámetros

*nIndex*<br/>
Índice del campo en el conjunto de registros, para la búsqueda por índice de base cero.

*lpszName*<br/>
Nombre del campo en el conjunto de registros, para buscar por nombre.

### <a name="remarks"></a>Observaciones

C++NULL no es lo mismo que null, que, en la terminología de bases de datos, significa "no tener ningún valor".

##  <a name="setpercentposition"></a>CDaoRecordset:: SetPercentPosition

Llame a esta función miembro para establecer un valor que cambie la ubicación aproximada del registro actual en el objeto de conjunto de registros basándose en un porcentaje de los registros del conjunto de registros.

```
void SetPercentPosition(float fPosition);
```

### <a name="parameters"></a>Parámetros

*fPosition*<br/>
Número comprendido entre 0 y 100.

### <a name="remarks"></a>Observaciones

Al trabajar con un conjunto de registros de tipo Dynaset o de instantánea, rellene primero el conjunto de registros desplazándose hasta el último registro antes de llamar a `SetPercentPosition`. Si llama a `SetPercentPosition` antes de rellenar completamente el conjunto de registros, la cantidad de movimiento es relativa al número de registros a los que se tiene acceso como indica el valor de [GetRecordCount](#getrecordcount). Puede moverse al último registro llamando a `MoveLast`.

Una vez que se llama a `SetPercentPosition`, el registro en la posición aproximada correspondiente a ese valor se convierte en actual.

> [!NOTE]
>  No se recomienda llamar a `SetPercentPosition` para trasladar el registro actual a un registro específico en un conjunto de registros. En su lugar, llame a la función miembro [SetBookmark](#setbookmark) .

Para obtener información relacionada, vea el tema "propiedad PercentPosition" en la ayuda de DAO.

##  <a name="update"></a>CDaoRecordset:: Update

Llame a esta función miembro después de una llamada a la función miembro `AddNew` o `Edit`.

```
virtual void Update();
```

### <a name="remarks"></a>Observaciones

Esta llamada es necesaria para completar la operación `AddNew` o `Edit`.

Tanto `AddNew` como `Edit` preparan un búfer de edición en el que se colocan los datos agregados o editados para guardarlos en el origen de datos. `Update` guarda los datos. Solo se actualizan los campos marcados o detectados como modificados.

Si el origen de datos admite transacciones, puede hacer que la llamada de `Update` (y su correspondiente `AddNew` o llamada a `Edit`) forme parte de una transacción.

> [!CAUTION]
> Si llama a `Update` sin llamar primero a `AddNew` o `Edit`, `Update` produce una `CDaoException`. Si llama a `AddNew` o `Edit`, debe llamar a `Update` antes de llamar a [MoveNext](#movenext) o cerrar el conjunto de registros o la conexión del origen de datos. De lo contrario, los cambios se perderán sin notificación.

Cuando el objeto de conjunto de registros está bloqueado de forma pesimista en un entorno multiusuario, el registro permanece bloqueado desde el momento en que se usa `Edit` hasta que se completa la actualización. Si el conjunto de registros está bloqueado de forma optimista, el registro se bloquea y se compara con el registro previamente editado justo antes de que se actualice en la base de datos. Si el registro ha cambiado desde que se llamó a `Edit`, se produce un error en la operación de `Update` y MFC inicia una excepción. Puede cambiar el modo de bloqueo con `SetLockingMode`.

> [!NOTE]
> El bloqueo optimista siempre se usa en formatos de bases de datos externas, como ODBC e ISAM instalable.

Para obtener información relacionada, vea los temas "AddNew Method", "CancelUpdate Method", "Delete Method", "LastModified Property", "Update Method" y "EditMode Property" en la ayuda de DAO.

## <a name="see-also"></a>Consulte también

[CObject (clase)](../../mfc/reference/cobject-class.md)<br/>
[Gráfico de jerarquías](../../mfc/hierarchy-chart.md)<br/>
[CDaoTableDef (clase)](../../mfc/reference/cdaotabledef-class.md)<br/>
[CDaoWorkspace (clase)](../../mfc/reference/cdaoworkspace-class.md)<br/>
[CDaoDatabase (clase)](../../mfc/reference/cdaodatabase-class.md)<br/>
[CDaoQueryDef (clase)](../../mfc/reference/cdaoquerydef-class.md)<br/>
