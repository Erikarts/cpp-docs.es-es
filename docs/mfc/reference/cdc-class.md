---
title: Clase CDC
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: 830c6d068a5074d0918107ca601c51d198a8a912
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/14/2020
ms.locfileid: "81375711"
---
# <a name="cdc-class"></a>Clase CDC

Define una clase de objetos en el contexto del dispositivo.

## <a name="syntax"></a>Sintaxis

```
class CDC : public CObject
```

## <a name="members"></a>Miembros

### <a name="public-constructors"></a>Constructores públicos

|Nombre|Descripción|
|----------|-----------------|
|[CDC::CDC](#cdc)|Construye un objeto `CDC`.|

### <a name="public-methods"></a>Métodos públicos

|Nombre|Descripción|
|----------|-----------------|
|[CDC::AbortDoc](#abortdoc)|Termina el trabajo de impresión actual, borrando todo lo que la `StartDoc` aplicación ha escrito en el dispositivo desde la última llamada de la función miembro.|
|[CDC::AbortPath](#abortpath)|Cierra y descarta cualquier acceso en el contexto del dispositivo.|
|[CDC::AddMetaFileComment](#addmetafilecomment)|Copia el comentario de un búfer en un metarchivo de formato mejorado especificado.|
|[CDC::AlphaBlend](#alphablend)|Muestra mapas de bits que tienen píxeles transparentes o semitransparentes.|
|[CDC::AngleArc](#anglearc)|Dibuja un segmento de línea y un arco, y mueve la posición actual al punto final del arco.|
|[CDC::Arc](#arc)|Dibuja un arco elíptico.|
|[CDC::ArcTo](#arcto)|Dibuja un arco elíptico. Esta función `Arc`es similar a , excepto que se actualiza la posición actual.|
|[CDC::Adjuntar](#attach)|Asocia un contexto de `CDC` dispositivo Windows a este objeto.|
|[CDC::BeginPath](#beginpath)|Abre un corchete de ruta en el contexto del dispositivo.|
|[CDC::BitBlt](#bitblt)|Copia un mapa de bits de un contexto de dispositivo especificado.|
|[CDC::Chord](#chord)|Dibuja un acorde (una figura cerrada delimitada por la intersección de una elipse y un segmento de línea).|
|[CDC::CloseFigure](#closefigure)|Cierra una figura abierta en una ruta de acceso.|
|[CDC::CreateCompatibleDC](#createcompatibledc)|Crea un contexto de dispositivo de memoria que es compatible con otro contexto de dispositivo. Puede usarlo para preparar imágenes en la memoria.|
|[CDC::CreateDC](#createdc)|Crea un contexto de dispositivo para un dispositivo específico.|
|[CDC::CreateIC](#createic)|Crea un contexto de información para un dispositivo específico. Esto proporciona una manera rápida de obtener información sobre el dispositivo sin crear un contexto de dispositivo.|
|[CDC::DeleteDC](#deletedc)|Elimina el contexto de dispositivo `CDC` de Windows asociado a este objeto.|
|[CDC::DeleteTempMap](#deletetempmap)|Llamado por `CWinApp` el controlador de tiempo `CDC` de `FromHandle`inactividad para eliminar cualquier objeto temporal creado por . También separa el contexto del dispositivo.|
|[CDC::Dsetach](#detach)|Separa el contexto del `CDC` dispositivo Windows de este objeto.|
|[CDC::DPtoHIMETRIC](#dptohimetric)|Convierte unidades de dispositivo en unidades HIMETRIC.|
|[CDC::DPtoLP](#dptolp)|Convierte unidades de dispositivo en unidades lógicas.|
|[CDC::Draw3dRect](#draw3drect)|Dibuja un rectángulo tridimensional.|
|[CDC::DrawDragRect](#drawdragrect)|Borra y redibuja un rectángulo a medida que se arrastra.|
|[CDC::DrawEdge](#drawedge)|Dibuja los bordes de un rectángulo.|
|[CDC::DrawEscape](#drawescape)|Accede a las capacidades de dibujo de una pantalla de vídeo que no están disponibles directamente a través de la interfaz del dispositivo gráfico (GDI).|
|[CDC::DrawFocusRect](#drawfocusrect)|Dibuja un rectángulo en el estilo utilizado para indicar el foco.|
|[CDC::DrawFrameControl](#drawframecontrol)|Dibuje un control de fotograma.|
|[CDC::DrawIcon](#drawicon)|Dibuja un icono.|
|[CDC::DrawState](#drawstate)|Muestra una imagen y aplica un efecto visual para indicar un estado.|
|[CDC::DrawText](#drawtext)|Dibuja texto con formato en el rectángulo especificado.|
|[CDC::DrawTextEx](#drawtextex)|Dibuja texto con formato en el rectángulo especificado utilizando formatos adicionales.|
|[CDC::Elipse](#ellipse)|Dibuja una elipse.|
|[CDC::EndDoc](#enddoc)|Finaliza un trabajo de `StartDoc` impresión iniciado por la función miembro.|
|[CDC::EndPage](#endpage)|Informa al controlador de dispositivo de que una página está finalizando.|
|[CDC::EndPath](#endpath)|Cierra un corchete de ruta y selecciona la ruta definida por el corchete en el contexto del dispositivo.|
|[CDC::EnumObjects](#enumobjects)|Enumera las plumas y pinceles disponibles en un contexto de dispositivo.|
|[CDC::Escape](#escape)|Permite que las aplicaciones accedan a instalaciones que no están directamente disponibles desde un dispositivo determinado a través de GDI. También permite el acceso a las funciones de escape de Windows. Las llamadas de escape realizadas por una aplicación se traducen y se envían al controlador del dispositivo.|
|[CDC::ExcludeClipRect](#excludecliprect)|Crea una nueva región de recorte que consta de la región de recorte existente menos el rectángulo especificado.|
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|Impide dibujar dentro de áreas no válidas de una ventana excluyendo una región actualizada en la ventana de una región de recorte.|
|[CDC::ExtFloodFill](#extfloodfill)|Rellena un área con el pincel actual. Proporciona más flexibilidad que la función miembro [CDC::FloodFill.](#floodfill)|
|[CDC::ExtTextOut](#exttextout)|Escribe una cadena de caracteres dentro de una región rectangular utilizando la fuente seleccionada actualmente.|
|[CDC::FillPath](#fillpath)|Cierra las figuras abiertas en el trazado actual y rellena el interior del trazado utilizando el pincel actual y el modo de relleno de polígonos.|
|[CDC::FillRect](#fillrect)|Rellena un rectángulo determinado mediante un pincel específico.|
|[CDC::FillRgn](#fillrgn)|Rellena una región específica con el pincel especificado.|
|[CDC::FillSolidRect](#fillsolidrect)|Rellena un rectángulo con un color sólido.|
|[CDC::FlattenPath](#flattenpath)|Transforma las curvas del trazado seleccionado en el contexto del dispositivo actual y convierte cada curva en una secuencia de líneas.|
|[CDC::FloodFill](#floodfill)|Rellena un área con el pincel actual.|
|[CDC::FrameRect](#framerect)|Dibuja un borde alrededor de un rectángulo.|
|[CDC::FrameRgn](#framergn)|Dibuja un borde alrededor de una región específica con un pincel.|
|[CDC::FromHandle](#fromhandle)|Devuelve un puntero `CDC` a un objeto cuando se le da un identificador a un contexto de dispositivo. Si no hay un objeto `CDC` asociado al identificador, se crea y asocia un objeto `CDC` temporal.|
|[CDC::GetArcDirection](#getarcdirection)|Devuelve la dirección de arco actual para el contexto del dispositivo.|
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|Recupera la configuración del filtro de relación de aspecto actual.|
|[CDC::GetBkColor](#getbkcolor)|Recupera el color de fondo actual.|
|[CDC::GetBkMode](#getbkmode)|Recupera el modo de fondo.|
|[CDC::GetBoundsRect](#getboundsrect)|Devuelve el rectángulo delimitador acumulado actual para el contexto de dispositivo especificado.|
|[CDC::GetBrushOrg](#getbrushorg)|Recupera el origen del pincel actual.|
|[CDC::GetCharABCWidths](#getcharabcwidths)|Recupera los anchos, en unidades lógicas, de caracteres consecutivos en un intervalo determinado de la fuente actual.|
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|Recupera los anchos, en unidades lógicas, de índices de glifo consecutivos en un intervalo especificado de la fuente TrueType actual.|
|[CDC::GetCharacterPlacement](#getcharacterplacement)|Recupera varios tipos de información en una cadena de caracteres.|
|[CDC::GetCharWidth](#getcharwidth)|Recupera los anchos fraccionarios de caracteres consecutivos en un intervalo determinado de la fuente actual.|
|[CDC::GetCharWidthI](#getcharwidthi)|Recupera los anchos, en coordenadas lógicas, de índices de glifo consecutivos en un rango especificado de la fuente actual.|
|[CDC::GetClipBox](#getclipbox)|Recupera las dimensiones del rectángulo delimitador más estrecho alrededor del contorno delimitador actual.|
|[CDC::GetColorAdjustment](#getcoloradjustment)|Recupera los valores de ajuste de color para el contexto del dispositivo.|
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|Devuelve un puntero al `CBitmap` objeto seleccionado actualmente.|
|[CDC::GetCurrentBrush](#getcurrentbrush)|Devuelve un puntero al `CBrush` objeto seleccionado actualmente.|
|[CDC::GetCurrentFont](#getcurrentfont)|Devuelve un puntero al `CFont` objeto seleccionado actualmente.|
|[CDC::GetCurrentPalette](#getcurrentpalette)|Devuelve un puntero al `CPalette` objeto seleccionado actualmente.|
|[CDC::GetCurrentPen](#getcurrentpen)|Devuelve un puntero al `CPen` objeto seleccionado actualmente.|
|[CDC::GetCurrentPosition](#getcurrentposition)|Recupera la posición actual del lápiz (en coordenadas lógicas).|
|[CDC::GetDCBrushColor](#getdcbrushcolor)|Recupera el color de pincel actual.|
|[CDC::GetDCPenColor](#getdcpencolor)|Recupera el color del lápiz actual.|
|[CDC::GetDeviceCaps](#getdevicecaps)|Recupera un tipo especificado de información específica del dispositivo sobre las capacidades de un dispositivo de visualización determinado.|
|[CDC::GetFontData](#getfontdata)|Recupera información de métricas de fuentes de un archivo de fuente escalable. La información que se va a recuperar se identifica especificando un desplazamiento en el archivo de fuente y la longitud de la información que se va a devolver.|
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|Devuelve información sobre la fuente seleccionada actualmente para el contexto de visualización especificado.|
|[CDC::GetGlyphOutline](#getglyphoutline)|Recupera la curva de contorno o mapa de bits para un carácter de contorno en la fuente actual.|
|[CDC::GetGraphicsMode](#getgraphicsmode)|Recupera el modo de gráficos actual para el contexto de dispositivo especificado.|
|[CDC::GetHalftoneBrush](#gethalftonebrush)|Recupera un pincel de medios tonos.|
|[CDC::GetKerningPairs](#getkerningpairs)|Recupera los pares de kerning de caracteres para la fuente que está seleccionada actualmente en el contexto de dispositivo especificado.|
|[CDC::GetLayout](#getlayout)|Recupera el diseño de un contexto de dispositivo (DC). El diseño puede ser de izquierda a derecha (predeterminado) o de derecha a izquierda (espejado).|
|[CDC::GetMapMode](#getmapmode)|Recupera el modo de asignación actual.|
|[CDC::GetMiterLimit](#getmiterlimit)|Devuelve el límite de inglete para el contexto del dispositivo.|
|[CDC::GetNearestColor](#getnearestcolor)|Recupera el color lógico más cercano a un color lógico especificado que puede representar el dispositivo especificado.|
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|Recupera información de métricas de fuente para fuentes TrueType.|
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|Recupera los anchos de caracteres individuales en un grupo consecutivo de caracteres de la fuente actual mediante el contexto del dispositivo de salida.|
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|Calcula el ancho y el alto de una cadena de caracteres en el contexto del dispositivo de salida.|
|[CDC::GetOutputTextExtent](#getoutputtextextent)|Calcula el ancho y el alto de una línea de texto en el contexto del dispositivo de salida utilizando la fuente actual para determinar las dimensiones.|
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|Recupera las métricas de la fuente actual del contexto del dispositivo de salida.|
|[CDC::GetPath](#getpath)|Recupera las coordenadas que definen los puntos finales de las líneas y los puntos de control de las curvas que se encuentran en la ruta seleccionada en el contexto del dispositivo.|
|[CDC::GetPixel](#getpixel)|Recupera el valor de color RGB del píxel en el punto especificado.|
|[CDC::GetPolyFillMode](#getpolyfillmode)|Recupera el modo de relleno de polígonos actual.|
|[CDC::GetROP2](#getrop2)|Recupera el modo de dibujo actual.|
|[CDC::GetSafeHdc](#getsafehdc)|Devuelve [CDC::m_hDC](#m_hdc), el contexto del dispositivo de salida.|
|[CDC::GetStretchBltMode](#getstretchbltmode)|Recupera el modo de estiramiento de mapa de bits actual.|
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|Calcula el ancho y el alto de una cadena de caracteres en el contexto del dispositivo de atributo.|
|[CDC::GetTextAlign](#gettextalign)|Recupera los indicadores de alineación de texto.|
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|Recupera la configuración actual para la cantidad de espaciado entre caracteres.|
|[CDC::GetTextColor](#gettextcolor)|Recupera el color de texto actual.|
|[CDC::GetTextExtent](#gettextextent)|Calcula el ancho y el alto de una línea de texto en el contexto del dispositivo de atributo utilizando la fuente actual para determinar las dimensiones.|
|[CDC::GetTextExtentExPointi](#gettextextentexpointi)|Recupera el número de caracteres de una cadena especificada que caben dentro de un espacio especificado y rellena una matriz con la extensión de texto para cada uno de esos caracteres.|
|[CDC::GetTextExtentPointI](#gettextextentpointi)|Recupera el ancho y alto de la matriz especificada de índices de glifo.|
|[CDC::GetTextFace](#gettextface)|Copia el nombre de tipo de letra de la fuente actual en un búfer como una cadena terminada en null.|
|[CDC::GetTextMetrics](#gettextmetrics)|Recupera las métricas de la fuente actual del contexto del dispositivo de atributo.|
|[CDC::GetViewportExt](#getviewportext)|Recupera las extensiones X e Y de la ventana gráfica.|
|[CDC::GetViewportOrg](#getviewportorg)|Recupera las coordenadas x e y del origen de la ventana gráfica.|
|[CDC::GetWindow](#getwindow)|Devuelve la ventana asociada al contexto del dispositivo de visualización.|
|[CDC::GetWindowExt](#getwindowext)|Recupera las extensiones x e y de la ventana asociada.|
|[CDC::GetWindowOrg](#getwindoworg)|Recupera las coordenadas x e y del origen de la ventana asociada.|
|[CDC::GetWorldTransform](#getworldtransform)|Recupera la transformación actual del espacio mundial en el espacio de página.|
|[CDC::GradientFill](#gradientfill)|Rellena las estructuras de rectángulo y triángulo con un color gradente.|
|[CDC::GrayString](#graystring)|Dibuja texto atenuado (gris) en la ubicación dada.|
|[CDC::HIMETRICtoDP](#himetrictodp)|Convierte unidades HIMETRIC en unidades de dispositivo.|
|[CDC::HIMETRICtoLP](#himetrictolp)|Convierte unidades HIMETRIC en unidades lógicas.|
|[CDC::IntersectClipRect](#intersectcliprect)|Crea una nueva región de recorte formando la intersección de la región actual y un rectángulo.|
|[CDC::InvertRect](#invertrect)|Invierte el contenido de un rectángulo.|
|[CDC::InvertRgn](#invertrgn)|Invierte los colores de una región.|
|[CDC::IsPrinting](#isprinting)|Determina si el contexto del dispositivo se está utilizando para la impresión.|
|[CDC::LineTo](#lineto)|Dibuja una línea desde la posición actual hasta un punto, pero sin incluirlo.|
|[CDC::LPtoDP](#lptodp)|Convierte unidades lógicas en unidades de dispositivo.|
|[CDC::LPtoHIMETRIC](#lptohimetric)|Convierte unidades lógicas en unidades HIMETRIC.|
|[CDC::MaskBlt](#maskblt)|Combina los datos de color para los mapas de bits de origen y destino utilizando la máscara y la operación ráster dadas.|
|[CDC::ModifyWorldTransform](#modifyworldtransform)|Cambia la transformación del mundo para un contexto de dispositivo mediante el modo especificado.|
|[CDC::MoveTo](#moveto)|Mueve la posición actual.|
|[CDC::OffsetClipRgn](#offsetcliprgn)|Mueve la región de recorte del dispositivo especificado.|
|[CDC::OffsetViewportOrg](#offsetviewportorg)|Modifica el origen de la ventana gráfica en relación con las coordenadas del origen de la ventana gráfica actual.|
|[CDC::OffsetWindowOrg](#offsetwindoworg)|Modifica el origen de la ventana en relación con las coordenadas del origen de la ventana actual.|
|[CDC::PaintRgn](#paintrgn)|Rellena una región con el pincel seleccionado.|
|[CDC::PatBlt](#patblt)|Crea un patrón de bits.|
|[CDC::Pie](#pie)|Dibuja una cuña en forma de pastel.|
|[CDC::PlayMetaFile](#playmetafile)|Reproduce el contenido del metarchivo especificado en el dispositivo especificado. La versión `PlayMetaFile` mejorada de muestra la imagen almacenada en el metarchivo de formato mejorado dado. El metarchivo se puede reproducir cualquier número de veces.|
|[CDC::PlgBlt](#plgblt)|Realiza una transferencia de bloque de bits de los bits de datos de color desde el rectángulo especificado en el contexto del dispositivo de origen al paralelogramo especificado en el contexto de dispositivo especificado.|
|[CDC::PolyBezier](#polybezier)|Dibuja una o más splines de Bzier. La posición actual no se utiliza ni se actualiza.|
|[CDC::PolyBezierTo](#polybezierto)|Dibuja una o más splines de Bzier y mueve la posición actual al punto final de la última spline de Bzier.|
|[CDC::PolyDraw](#polydraw)|Dibuja un conjunto de segmentos de línea y splines de Bzier. Esta función actualiza la posición actual.|
|[CDC::Polygon](#polygon)|Dibuja un polígono que consta de dos o más puntos (vértices) conectados por líneas.|
|[CDC::Polyline](#polyline)|Dibuja un conjunto de segmentos de línea que conectan los puntos especificados.|
|[CDC::PolylineTo](#polylineto)|Dibuja una o más líneas rectas y mueve la posición actual al punto final de la última línea.|
|[CDC::PolyPolygon](#polypolygon)|Crea dos o más polígonos que se rellenan mediante el modo de relleno de polígonos actual. Los polígonos pueden estar desarticulados o pueden superponerse.|
|[CDC::PolyPolyline](#polypolyline)|Dibuja varias series de segmentos de línea conectados. Esta función no utiliza ni actualiza la posición actual.|
|[CDC::PtVisible](#ptvisible)|Especifica si el punto especificado está dentro de la región de recorte.|
|[CDC::RealizePalette](#realizepalette)|Asigna las entradas de la paleta de la paleta lógica actual a la paleta del sistema.|
|[CDC::Rectangle](#rectangle)|Dibuja un rectángulo con el lápiz actual y lo rellena con el pincel actual.|
|[CDC::RectVisible](#rectvisible)|Determina si alguna parte del rectángulo especificado se encuentra dentro de la región de recorte.|
|[CDC::ReleaseAttribDC](#releaseattribdc)|Releases `m_hAttribDC`, el contexto del dispositivo de atributos.|
|[CDC::ReleaseOutputDC](#releaseoutputdc)|Releases `m_hDC`, el contexto del dispositivo de salida.|
|[CDC::ResetDC](#resetdc)|Actualiza `m_hAttribDC` el contexto del dispositivo.|
|[CDC::RestoreDC](#restoredc)|Restaura el contexto del dispositivo a `SaveDC`un estado anterior guardado con .|
|[CDC::RoundRect](#roundrect)|Dibuja un rectángulo con esquinas redondeadas usando el lápiz actual y rellenado con el pincel actual.|
|[CDC::SaveDC](#savedc)|Guarda el estado actual del contexto del dispositivo.|
|[CDC::ScaleViewportExt](#scaleviewportext)|Modifica la extensión de la ventana gráfica con respecto a los valores actuales.|
|[CDC::ScaleWindowExt](#scalewindowext)|Modifica las extensiones de ventana con respecto a los valores actuales.|
|[CDC::ScrollDC](#scrolldc)|Desplaza un rectángulo de bits horizontal y verticalmente.|
|[CDC::SelectClipPath](#selectclippath)|Selecciona la ruta actual como una región de recorte para el contexto del dispositivo, combinando la nueva región con cualquier región de recorte existente mediante el modo especificado.|
|[CDC::SelectClipRgn](#selectcliprgn)|Combina la región dada con la región de recorte actual mediante el modo especificado.|
|[CDC::SelectObject](#selectobject)|Selecciona un objeto de dibujo GDI como un lápiz.|
|[CDC::SelectPalette](#selectpalette)|Selecciona la paleta lógica.|
|[CDC::SelectStockObject](#selectstockobject)|Selecciona una de las plumas, pinceles o fuentes predefinidas proporcionadas por Windows.|
|[CDC::SetAbortProc](#setabortproc)|Establece una función de devolución de llamada proporcionada por el programador a la que Windows llama si se debe anular un trabajo de impresión.|
|[CDC::SetArcDirection](#setarcdirection)|Establece la dirección del dibujo que se utilizará para las funciones de arco y rectángulo.|
|[CDC::SetAttribDC](#setattribdc)|Establece `m_hAttribDC`, el contexto del dispositivo de atributo.|
|[CDC::SetBkColor](#setbkcolor)|Establece el color de fondo actual.|
|[CDC::SetBkMode](#setbkmode)|Establece el modo de fondo.|
|[CDC::SetBoundsRect](#setboundsrect)|Controla la acumulación de información de rectángulo delimitador para el contexto de dispositivo especificado.|
|[CDC::SetBrushOrg](#setbrushorg)|Especifica el origen del siguiente pincel seleccionado en un contexto de dispositivo.|
|[CDC::SetColorAdjustment](#setcoloradjustment)|Establece los valores de ajuste de color para el contexto del dispositivo utilizando los valores especificados.|
|[CDC::SetDCBrushColor](#setdcbrushcolor)|Establece el color del pincel actual.|
|[CDC::SetDCPenColor](#setdcpencolor)|Establece el color actual del lápiz.|
|[CDC::SetGraphicsMode](#setgraphicsmode)|Establece el modo de gráficos actual para el contexto de dispositivo especificado.|
|[CDC::SetLayout](#setlayout)|Cambia el diseño de un contexto de dispositivo (DC).|
|[CDC::SetMapMode](#setmapmode)|Establece el modo de asignación actual.|
|[CDC::SetMapperFlags](#setmapperflags)|Altera el algoritmo que utiliza el asignador de fuentes cuando asigna fuentes lógicas a fuentes físicas.|
|[CDC::SetMiterLimit](#setmiterlimit)|Establece el límite para la longitud de las uniones de inglete para el contexto del dispositivo.|
|[CDC::SetOutputDC](#setoutputdc)|Establece `m_hDC`, el contexto del dispositivo de salida.|
|[CDC::SetPixel](#setpixel)|Establece el píxel en el punto especificado en la aproximación más cercana del color especificado.|
|[CDC::SetPixelV](#setpixelv)|Establece el píxel en las coordenadas especificadas en la aproximación más cercana del color especificado. `SetPixelV`es más `SetPixel` rápido que porque no necesita devolver el valor de color del punto realmente pintado.|
|[CDC::SetPolyFillMode](#setpolyfillmode)|Establece el modo de relleno de polígonos.|
|[CDC::SetROP2](#setrop2)|Establece el modo de dibujo actual.|
|[CDC::SetStretchBltMode](#setstretchbltmode)|Establece el modo de estiramiento de mapa de bits.|
|[CDC::SetTextAlign](#settextalign)|Establece los indicadores de alineación de texto.|
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|Establece la cantidad de espaciado entre caracteres.|
|[CDC::SetTextColor](#settextcolor)|Establece el color de texto.|
|[CDC::SetTextJustification](#settextjustification)|Agrega espacio a los caracteres de interrupción de una cadena.|
|[CDC::SetViewportExt](#setviewportext)|Establece las extensiones X e Y de la ventana gráfica.|
|[CDC::SetViewportOrg](#setviewportorg)|Establece el origen de la ventana gráfica.|
|[CDC::SetWindowExt](#setwindowext)|Establece las extensiones x e y de la ventana asociada.|
|[CDC::SetWindowOrg](#setwindoworg)|Establece el origen de la ventana del contexto del dispositivo.|
|[CDC::SetWorldTransform](#setworldtransform)|Establece el espacio mundial actual en la transformación de espacio de página.|
|[CDC::StartDoc](#startdoc)|Informa al controlador de dispositivo de que se está iniciando un nuevo trabajo de impresión.|
|[CDC::StartPage](#startpage)|Informa al controlador de dispositivo de que se está iniciando una nueva página.|
|[CDC::StretchBlt](#stretchblt)|Mueve un mapa de bits de un rectángulo de origen y un dispositivo a un rectángulo de destino, estirando o comprimiendo el mapa de bits si es necesario para ajustarse a las dimensiones del rectángulo de destino.|
|[CDC::StrokeAndFillPath](#strokeandfillpath)|Cierra las figuras abiertas de un trazado, golpea el contorno del trazado utilizando el lápiz actual y rellena su interior con el pincel actual.|
|[CDC::StrokePath](#strokepath)|Representa la ruta especificada mediante el lápiz actual.|
|[CDC::TabbedTextOut](#tabbedtextout)|Escribe una cadena de caracteres en una ubicación especificada, expandiendo las pestañas a los valores especificados en una matriz de posiciones de tabulación.|
|[CDC::TextOut](#textout)|Escribe una cadena de caracteres en una ubicación especificada utilizando la fuente seleccionada actualmente.|
|[CDC::TransparentBlt](#transparentblt)|Transfiere un bloque de bits de datos de color desde el contexto de dispositivo de origen especificado a un contexto de dispositivo de destino, lo que representa un color especificado transparente en la transferencia.|
|[CDC::UpdateColors](#updatecolors)|Actualiza el área de cliente del contexto del dispositivo haciendo coincidir los colores actuales del área de cliente con la paleta del sistema píxel por píxel.|
|[CDC::WidenPath](#widenpath)|Redefine el trazado actual como el área que se pintaría si el trazado se trazara utilizando el lápiz seleccionado actualmente en el contexto del dispositivo.|

### <a name="public-operators"></a>Operadores públicos

|Nombre|Descripción|
|----------|-----------------|
|[CDC::operador HDC](#operator_hdc)|Recupera el identificador del contexto del dispositivo.|

### <a name="public-data-members"></a>Miembros de datos públicos

|Nombre|Descripción|
|----------|-----------------|
|[CDC::m_hAttribDC](#m_hattribdc)|El contexto de atributo-dispositivo utilizado por este `CDC` objeto.|
|[CDC::m_hDC](#m_hdc)|El contexto de dispositivo `CDC` de salida utilizado por este objeto.|

## <a name="remarks"></a>Observaciones

El `CDC` objeto proporciona funciones miembro para trabajar con un contexto de dispositivo, como una pantalla o impresora, así como miembros para trabajar con un contexto de visualización asociado con el área de cliente de una ventana.

Realice todos los dibujos `CDC` a través de las funciones miembro de un objeto. La clase proporciona funciones miembro para operaciones de contexto de dispositivo, trabajar con herramientas de dibujo, selección de objetos de interfaz de dispositivo gráfico (GDI) con seguridad de tipos y trabajar con colores y paletas. También proporciona funciones miembro para obtener y establecer atributos de dibujo, mapear, trabajar con la ventana gráfica, trabajar con la extensión de ventana, convertir coordenadas, trabajar con regiones, recortar, dibujar líneas y dibujar formas simples, elipses y polígonos. Las funciones miembro también se proporcionan para dibujar texto, trabajar con fuentes, usar escapes de impresora, desplazarse y reproducir metarchivos.

Para usar `CDC` un objeto, compílelo y, a continuación, llame a sus funciones miembro que paralelo funciones de Windows que usan contextos de dispositivo.

> [!NOTE]
> En Windows 95/98, todas las coordenadas de pantalla están limitadas a 16 bits. Por lo tanto, un `CDC` **int** pasado a una función miembro debe estar en el intervalo -32768 a 32767.

Para usos específicos, la biblioteca Microsoft `CDC` Foundation Class proporciona varias clases derivadas de . `CPaintDC`encapsula las `BeginPaint` llamadas a y `EndPaint`. `CClientDC`administra un contexto de visualización asociado con el área de cliente de una ventana. `CWindowDC`administra un contexto de visualización asociado a una ventana completa, incluidos su marco y controles. `CMetaFileDC`asocia un contexto de dispositivo con un metarchivo.

`CDC`proporciona dos funciones miembro, [GetLayout](#getlayout) y [SetLayout](#setlayout), para invertir el diseño de un contexto de dispositivo, que no hereda su diseño de una ventana. Esta orientación de derecha a izquierda es necesaria para aplicaciones escritas para culturas, como el árabe o el hebreo, donde el diseño del carácter no es el estándar europeo.

`CDC`contiene dos contextos de dispositivo, [m_hDC](#m_hdc) y `CDC` [m_hAttribDC](#m_hattribdc), que, al crear un objeto, hacen referencia al mismo dispositivo. `CDC`dirige todas las llamadas `m_hDC` GDI de salida `m_hAttribDC`a . (Un ejemplo de una `GetTextColor`llamada `SetTextColor` de atributo es , mientras que es una llamada de salida.)

Por ejemplo, el marco de trabajo usa `CMetaFileDC` estos dos contextos de dispositivo para implementar un objeto que enviará la salida a un metarchivo mientras lee atributos de un dispositivo físico. La vista previa de impresión se implementa en el marco de trabajo de forma similar. También puede usar los dos contextos de dispositivo de forma similar en el código específico de la aplicación.

Hay ocasiones en las que es posible `m_hDC` `m_hAttribDC` que necesite información de métricas de texto de los contextos de dispositivo y de dispositivo. Los siguientes pares de funciones proporcionan esta capacidad:

|Usos m_hAttribDC|Utiliza m_hDC|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

Para obtener `CDC`más información sobre , consulte [Contextos](../../mfc/device-contexts.md)de dispositivo .

## <a name="inheritance-hierarchy"></a>Jerarquía de herencia

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>Requisitos

**Encabezado:** afxwin.h

## <a name="cdcabortdoc"></a><a name="abortdoc"></a>CDC::AbortDoc

Termina el trabajo de impresión actual y borra todo lo que la aplicación ha escrito en el dispositivo desde la última llamada a la Función miembro [StartDoc.](#startdoc)

```
int AbortDoc();
```

### <a name="return-value"></a>Valor devuelto

Un valor mayor o igual que 0 si se realiza correctamente, o un valor negativo si se ha producido un error. La lista siguiente muestra los valores de error comunes y sus significados:

- SP_ERROR Error general.

- SP_OUTOFDISK No hay suficiente espacio en disco disponible actualmente para la cola de impresión y no habrá más espacio disponible.

- SP_OUTOFMEMORY No hay suficiente memoria disponible para el spooling.

- SP_USERABORT Usuario terminó el trabajo a través del Administrador de impresión.

### <a name="remarks"></a>Observaciones

Esta función miembro reemplaza el escape de impresora ABORTDOC.

`AbortDoc`debe utilizarse para terminar lo siguiente:

- Operaciones de impresión que no especifican una función de anulación mediante [SetAbortProc](#setabortproc).

- Operaciones de impresión que aún no han alcanzado su primera llamada de escape NEWFRAME o NEXTBAND.

Si una aplicación encuentra un error de impresión o una operación de impresión cancelada, no `CDC`debe intentar finalizar la operación mediante el [EndDoc](#enddoc) o `AbortDoc` las funciones miembro de la clase . GDI finaliza automáticamente la operación antes de devolver el valor de error.

Si la aplicación muestra un cuadro de diálogo para permitir `AbortDoc` al usuario cancelar la operación de impresión, debe llamar antes de destruir el cuadro de diálogo.

Si se utilizó el Administrador de `AbortDoc` impresión para iniciar el trabajo de impresión, al llamar se borra todo el trabajo de cola de impresión: la impresora no recibe nada. Si el Administrador de impresión no se utilizó para iniciar `AbortDoc` el trabajo de impresión, es posible que los datos se hayan enviado a la impresora antes de llamarse. En este caso, el controlador de impresora habría restablecido la impresora (cuando sea posible) y cerrado el trabajo de impresión.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC::StartDoc](#startdoc).

## <a name="cdcabortpath"></a><a name="abortpath"></a>CDC::AbortPath

Cierra y descarta cualquier acceso en el contexto del dispositivo.

```
BOOL AbortPath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Si hay un corchete de ruta abierto en el contexto del dispositivo, el corchete de ruta se cierra y se descarta la ruta de acceso. Si hay una ruta de acceso cerrada en el contexto del dispositivo, se descarta la ruta de acceso.

## <a name="cdcaddmetafilecomment"></a><a name="addmetafilecomment"></a>CDC::AddMetaFileComment

Copia el comentario de un búfer en un metarchivo de formato mejorado especificado.

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>Parámetros

*nDataSize*<br/>
Especifica la longitud del búfer de comentarios, en bytes.

*pCommentData*<br/>
Apunta al búfer que contiene el comentario.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Un comentario puede incluir cualquier información privada, por ejemplo, la fuente de la imagen y la fecha en que se creó. Un comentario debe comenzar con una firma de aplicación, seguido de los datos. Los comentarios no deben contener datos específicos de la posición. Los datos específicos de la posición especifican la ubicación de un registro y no se deben incluir porque un metarchivo puede estar incrustado en otro metarchivo. Esta función solo se puede utilizar con metarchivos mejorados.

## <a name="cdcalphablend"></a><a name="alphablend"></a>CDC::AlphaBlend

Llame a esta función miembro para mostrar mapas de bits que tienen píxeles transparentes o semitransparentes.

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>Parámetros

*xDest*<br/>
Especifica la coordenada x, en unidades lógicas, de la esquina superior izquierda del rectángulo de destino.

*yDest*<br/>
Especifica la coordenada y, en unidades lógicas, de la esquina superior izquierda del rectángulo de destino.

*nDestWidth*<br/>
Especifica el ancho, en unidades lógicas, del rectángulo de destino.

*nDestHeight*<br/>
Especifica el alto, en unidades lógicas, del rectángulo de destino.

*pSrcDC*<br/>
Un puntero al contexto del dispositivo de origen.

*xSrc*<br/>
Especifica la coordenada x, en unidades lógicas, de la esquina superior izquierda del rectángulo de origen.

*ySrc*<br/>
Especifica la coordenada y, en unidades lógicas, de la esquina superior izquierda del rectángulo de origen.

*nSrcWidth*<br/>
Especifica el ancho, en unidades lógicas, del rectángulo de origen.

*nSrcHeight*<br/>
Especifica el alto, en unidades lógicas, del rectángulo de origen.

*Mezcla*<br/>
Especifica una estructura [BLENDFUNCTION.](/windows/win32/api/wingdi/ns-wingdi-blendfunction)

### <a name="return-value"></a>Valor devuelto

TRUE si es correcto; en caso contrario, FALSE.

### <a name="remarks"></a>Observaciones

Consulte [AlphaBlend](/windows/win32/api/wingdi/nf-wingdi-alphablend) en el Windows SDK para obtener más información.

## <a name="cdcanglearc"></a><a name="anglearc"></a>CDC::AngleArc

Dibuja un segmento de línea y un arco.

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x lógica del centro del círculo.

*y y*<br/>
Especifica la coordenada y lógica del centro del círculo.

*nRadius*<br/>
Especifica el radio del círculo en unidades lógicas. Este valor debe ser positivo.

*fStartAngle*<br/>
Especifica el ángulo inicial en grados con respecto al eje X.

*fSweepAngle*<br/>
Especifica el ángulo de barrido en grados con respecto al ángulo inicial.

### <a name="return-value"></a>Valor devuelto

Si es correcta, su valor es distinto de cero. En caso contrario, es cero.

### <a name="remarks"></a>Observaciones

El segmento de línea se dibuja desde la posición actual hasta el principio del arco. El arco se dibuja a lo largo del perímetro de un círculo con el radio y el centro dados. La longitud del arco se define mediante los ángulos de inicio y barrido dados.

`AngleArc`mueve la posición actual al punto final del arco. El arco dibujado por esta función puede parecer elíptico, dependiendo del modo de transformación y asignación actual. Antes de dibujar el arco, esta función dibuja el segmento de línea desde la posición actual hasta el principio del arco. El arco se dibuja construyendo un círculo imaginario con el radio especificado alrededor del punto central especificado. El punto inicial del arco se determina midiendo en sentido contrario a las agujas del reloj desde el eje X del círculo por el número de grados en el ángulo inicial. El punto final se encuentra de forma similar midiendo en sentido contrario a las agujas del reloj desde el punto inicial por el número de grados en el ángulo de barrido.

Si el ángulo de barrido es superior a 360 grados, el arco se barre varias veces. Esta función dibuja líneas utilizando el lápiz actual. La figura no está llena.

## <a name="cdcarc"></a><a name="arc"></a>CDC::Arc

Dibuja un arco elíptico.

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parámetros

*x1*<br/>
Especifica la coordenada x de la esquina superior izquierda del rectángulo delimitador (en unidades lógicas).

*y1*<br/>
Especifica la coordenada y de la esquina superior izquierda del rectángulo delimitador (en unidades lógicas).

*x2*<br/>
Especifica la coordenada x de la esquina inferior derecha del rectángulo delimitador (en unidades lógicas).

*y2*<br/>
Especifica la coordenada y de la esquina inferior derecha del rectángulo delimitador (en unidades lógicas).

*x3*<br/>
Especifica la coordenada x del punto que define el punto inicial del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco.

*y3*<br/>
Especifica la coordenada y del punto que define el punto inicial del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco.

*x4*<br/>
Especifica la coordenada x del punto que define el punto final del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco.

*y4*<br/>
Especifica la coordenada y del punto que define el punto final del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco.

*lpRect*<br/>
Especifica el rectángulo delimitador (en unidades lógicas). Puede pasar un objeto LPRECT o [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parámetro.

*ptStart*<br/>
Especifica las coordenadas x e y del punto que define el punto inicial del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco. Puede pasar una estructura [POINT](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parámetro.

*ptEnd*<br/>
Especifica las coordenadas x e y del punto que define el punto final del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco. Puede pasar una `POINT` estructura `CPoint` o un objeto para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El arco dibujado mediante la función es un segmento de la elipse definido por el rectángulo delimitador especificado.

El punto inicial real del arco es el punto en el que un rayo dibujado desde el centro del rectángulo delimitador a través del punto inicial especificado interseca la elipse. El punto final real del arco es el punto en el que un rayo dibujado desde el centro del rectángulo delimitador a través del punto final especificado interseca la elipse. El arco se dibuja en sentido contrario a las agujas del reloj. Puesto que un arco no es una figura cerrada, no se rellena. Tanto el ancho como el alto del rectángulo deben ser mayores que 2 unidades y menos de 32.767 unidades.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

## <a name="cdcarcto"></a><a name="arcto"></a>CDC::ArcTo

Dibuja un arco elíptico.

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parámetros

*x1*<br/>
Especifica la coordenada x de la esquina superior izquierda del rectángulo delimitador (en unidades lógicas).

*y1*<br/>
Especifica la coordenada y de la esquina superior izquierda del rectángulo delimitador (en unidades lógicas).

*x2*<br/>
Especifica la coordenada x de la esquina inferior derecha del rectángulo delimitador (en unidades lógicas).

*y2*<br/>
Especifica la coordenada y de la esquina inferior derecha del rectángulo delimitador (en unidades lógicas).

*x3*<br/>
Especifica la coordenada x del punto que define el punto inicial del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco.

*y3*<br/>
Especifica la coordenada y del punto que define el punto inicial del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco.

*x4*<br/>
Especifica la coordenada x del punto que define el punto final del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco.

*y4*<br/>
Especifica la coordenada y del punto que define el punto final del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco.

*lpRect*<br/>
Especifica el rectángulo delimitador (en unidades lógicas). Puede pasar un puntero a una estructura de datos [RECT](/windows/win32/api/windef/ns-windef-rect) o un [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto para este parámetro.

*ptStart*<br/>
Especifica las coordenadas x e y del punto que define el punto inicial del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco. Puede pasar una estructura de datos [POINT](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parámetro.

*ptEnd*<br/>
Especifica las coordenadas x e y del punto que define el punto final del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco. Puede pasar una `POINT` estructura de `CPoint` datos o un objeto para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función `CDC::Arc`es similar a , excepto que se actualiza la posición actual. Los puntos ( *x1*, *y1*) y ( *x2*, *y2*) especifican el rectángulo delimitador. Una elipse formada por el rectángulo delimitador dado define la curva del arco. El arco se extiende en sentido antihorario (la dirección de arco predeterminada) desde el punto donde interseca la línea radial desde el centro del rectángulo delimitador hasta ( *x3*, *y3*). El arco termina donde interseca la línea radial desde el centro del rectángulo delimitador a ( *x4*, *y4*). Si el punto inicial y el punto final son los mismos, se dibuja una elipse completa.

Se dibuja una línea desde la posición actual hasta el punto inicial del arco. Si no se produce ningún error, la posición actual se establece en el punto final del arco. El arco se dibuja utilizando la pluma actual; no está lleno.

## <a name="cdcattach"></a><a name="attach"></a>CDC::Adjuntar

Utilice esta función miembro para `CDC` asociar un *hDC* al objeto.

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>Parámetros

*Hdc*<br/>
Un contexto de dispositivo Windows.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El *hDC* se `m_hDC`almacena en ambos, el `m_hAttribDC`contexto del dispositivo de salida y en , el contexto del dispositivo de atributo.

## <a name="cdcbeginpath"></a><a name="beginpath"></a>CDC::BeginPath

Abre un corchete de ruta en el contexto del dispositivo.

```
BOOL BeginPath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Una vez abierto un corchete de ruta de acceso, una aplicación puede comenzar a llamar a funciones de dibujo GDI para definir los puntos que se encuentran en la ruta de acceso. Una aplicación puede cerrar un corchete `EndPath` de ruta de acceso abierto mediante una llamada a la función miembro. Cuando una `BeginPath`aplicación llama , se descartan las rutas de acceso anteriores.

Consulte [BeginPath](/windows/win32/api/wingdi/nf-wingdi-beginpath) en el Windows SDK para obtener una lista de las funciones de dibujo que definen puntos en una ruta de acceso.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

## <a name="cdcbitblt"></a><a name="bitblt"></a>CDC::BitBlt

Copia un mapa de bits del contexto del dispositivo de origen a este contexto de dispositivo actual.

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo de destino.

*y y*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo de destino.

*nAncho*<br/>
Especifica el ancho (en unidades lógicas) del rectángulo de destino y el mapa de bits de origen.

*nAltura*<br/>
Especifica la altura (en unidades lógicas) del rectángulo de destino y el mapa de bits de origen.

*pSrcDC*<br/>
Puntero a `CDC` un objeto que identifica el contexto del dispositivo desde el que se copiará el mapa de bits. Debe ser NULL si *dwRop* especifica una operación ráster que no incluye un origen.

*xSrc*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del mapa de bits de origen.

*ySrc*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del mapa de bits de origen.

*dwRop*<br/>
Especifica la operación de trama que se va a realizar. Los códigos de operación ráster definen cómo la GDI combina colores en las operaciones de salida que implican un pincel actual, un posible mapa de bits de origen y un mapa de bits de destino. Consulte [BitBlt](/windows/win32/api/wingdi/nf-wingdi-bitblt) en el Windows SDK para obtener una lista de los códigos de operación ráster para *dwRop* y sus descripciones

Para obtener una lista completa de códigos de operación ráster, consulte Acerca de los códigos de [operación ráster](/windows/win32/gdi/raster-operation-codes) en el Windows SDK.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La aplicación puede alinear las ventanas o las `BitBlt` áreas de cliente en los límites de bytes para asegurarse de que las operaciones se producen en rectángulos alineados con bytes. (Establezca los indicadores CS_BYTEALIGNWINDOW o CS_BYTEALIGNCLIENT al registrar las clases de ventana.)

`BitBlt`Las operaciones en rectángulos alineados `BitBlt` con bytes son considerablemente más rápidas que las operaciones en rectángulos que no están alineados con bytes. Si desea especificar estilos de clase como la alineación de bytes para su propio contexto de dispositivo, tendrá que registrar una clase de ventana en lugar de confiar en las clases de Microsoft Foundation para hacerlo por usted. Utilice la función global [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).

GDI transforma *nWidth* y *nHeight*, una vez mediante el contexto del dispositivo de destino y una vez mediante el contexto del dispositivo de origen. Si las extensiones resultantes no coinciden, `StretchBlt` GDI utiliza la función de Windows para comprimir o estirar el mapa de bits de origen según sea necesario.

Si los mapas de bits de destino, origen y `BitBlt` patrón no tienen el mismo formato de color, la función convierte los mapas de bits de origen y patrón para que coincidan con el destino. Los colores de primer plano y de fondo del mapa de bits de destino se utilizan en la conversión.

Cuando `BitBlt` la función convierte un mapa de bits monocromo en color, establece los bits blancos (1) en el color de fondo y los bits negros (0) en el color de primer plano. Se utilizan los colores de primer plano y de fondo del contexto del dispositivo de destino. Para convertir el color `BitBlt` en monocromo, establece los píxeles que coinciden con el color de fondo en blanco y establece todos los demás píxeles en negro. `BitBlt`utiliza los colores de primer plano y de fondo del contexto del dispositivo de color para convertir de color a monocromo.

Tenga en cuenta que `BitBlt`no todos los contextos de dispositivo admiten . Para comprobar si un contexto `BitBlt`de `GetDeviceCaps` dispositivo determinado admite , utilice la función miembro y especifique el índice RASTERCAPS.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC::CreateCompatibleDC](#createcompatibledc).

## <a name="cdccdc"></a><a name="cdc"></a>CDC::CDC

Construye un objeto `CDC`.

```
CDC();
```

## <a name="cdcchord"></a><a name="chord"></a>CDC::Chord

Dibuja un acorde (una figura cerrada delimitada por la intersección de una elipse y un segmento de línea).

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parámetros

*x1*<br/>
Especifica la coordenada x de la esquina superior izquierda del rectángulo delimitador del acorde (en unidades lógicas).

*y1*<br/>
Especifica la coordenada y de la esquina superior izquierda del rectángulo delimitador del acorde (en unidades lógicas).

*x2*<br/>
Especifica la coordenada x de la esquina inferior derecha del rectángulo delimitador del acorde (en unidades lógicas).

*y2*<br/>
Especifica la coordenada y de la esquina inferior derecha del rectángulo delimitador del acorde (en unidades lógicas).

*x3*<br/>
Especifica la coordenada x del punto que define el punto inicial del acorde (en unidades lógicas).

*y3*<br/>
Especifica la coordenada y del punto que define el punto inicial del acorde (en unidades lógicas).

*x4*<br/>
Especifica la coordenada x del punto que define el punto final del acorde (en unidades lógicas).

*y4*<br/>
Especifica la coordenada y del punto que define el punto final del acorde (en unidades lógicas).

*lpRect*<br/>
Especifica el rectángulo delimitador (en unidades lógicas). Puede pasar un objeto LPRECT o [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parámetro.

*ptStart*<br/>
Especifica las coordenadas x e y del punto que define el punto inicial del acorde (en unidades lógicas). Este punto no tiene que estar exactamente en el acorde. Puede pasar una `POINT` estructura `CPoint` o un objeto para este parámetro.

*ptEnd*<br/>
Especifica las coordenadas x e y del punto que define el punto final del acorde (en unidades lógicas). Este punto no tiene que estar exactamente en el acorde. Puede pasar una estructura [POINT](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Los parámetros ( *x1*, *y1*) y ( *x2*, *y2*) especifican las esquinas superior izquierda e inferior derecha, respectivamente, de un rectángulo que delimita la elipse que forma parte del acorde. Los parámetros ( *x3*, *y3*) y ( *x4*, *y4*) especifican los puntos finales de una línea que interseca la elipse. El acorde se dibuja utilizando el lápiz seleccionado y se rellena con el pincel seleccionado.

La figura dibujada por la `Chord` función se extiende hasta, pero no incluye las coordenadas derecha e inferior. Esto significa que la altura de la figura es *y2* - *y1* y la anchura de la figura es *x2* - *x1*.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

## <a name="cdcclosefigure"></a><a name="closefigure"></a>CDC::CloseFigure

Cierra una figura abierta en una ruta de acceso.

```
BOOL CloseFigure();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La función cierra la figura dibujando una línea desde la posición actual hasta el primer punto de `MoveTo` la figura (normalmente, el punto especificado por la llamada más reciente a la función miembro) y conecta las líneas mediante el estilo de combinación de líneas. Si una figura se `LineTo` cierra mediante `CloseFigure`la función miembro en lugar de , los límites finales se utilizan para crear la esquina en lugar de una combinación. `CloseFigure`sólo debe llamarse si hay un corchete de ruta abierta en el contexto del dispositivo.

Una figura de una ruta de acceso está abierta a menos que se cierre explícitamente mediante esta función. (Una figura puede estar abierta incluso si el punto actual y el punto inicial de la figura son los mismos.) Cualquier línea o curva agregada `CloseFigure` al trazado después de iniciar una nueva figura.

## <a name="cdccreatecompatibledc"></a><a name="createcompatibledc"></a>CDC::CreateCompatibleDC

Crea un contexto de dispositivo de memoria compatible con el dispositivo especificado por *pDC*.

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>Parámetros

*pDC*<br/>
Puntero a un contexto de dispositivo. Si *pDC* es NULL, la función crea un contexto de dispositivo de memoria que es compatible con la visualización del sistema.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Un contexto de dispositivo de memoria es un bloque de memoria que representa una superficie de visualización. Se puede utilizar para preparar imágenes en la memoria antes de copiarlas en la superficie real del dispositivo compatible.

Cuando se crea un contexto de dispositivo de memoria, GDI selecciona automáticamente un mapa de bits de stock monocromo 1 por 1 para él. Las funciones de salida GDI solo se pueden utilizar con un contexto de dispositivo de memoria si se ha creado y seleccionado un mapa de bits en ese contexto.

Esta función solo se puede utilizar para crear contextos de dispositivo compatibles para dispositivos que admiten operaciones ráster. Consulte la función miembro [CDC::BitBlt](#bitblt) para obtener información sobre las transferencias de bloques de bits entre contextos de dispositivo. Para determinar si un contexto de dispositivo admite operaciones `CDC::GetDeviceCaps`ráster, consulte la capacidad de ráster RC_BITBLT en la función miembro .

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

## <a name="cdccreatedc"></a><a name="createdc"></a>CDC::CreateDC

Crea un contexto de dispositivo para el dispositivo especificado.

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parámetros

*lpszDriverName*<br/>
Señala una cadena terminada en null que especifica el nombre de archivo (sin extensión) del controlador de dispositivo (por ejemplo, "EPSON"). También puede pasar `CString` un objeto para este parámetro.

*lpszDeviceName*<br/>
Señala a una cadena terminada en null que especifica el nombre del dispositivo específico que se admitirá (por ejemplo, "EPSON FX-80"). El parámetro *lpszDeviceName* se utiliza si el módulo admite más de un dispositivo. También puede pasar `CString` un objeto para este parámetro.

*lpszOutput*<br/>
Apunta a una cadena terminada en null que especifica el nombre de archivo o dispositivo para el medio de salida físico (archivo o puerto de salida). También puede pasar `CString` un objeto para este parámetro.

*lpInitData*<br/>
Apunta a `DEVMODE` una estructura que contiene datos de inicialización específicos del dispositivo para el controlador de dispositivo. La `DocumentProperties` función de Windows recupera esta estructura rellenada para un dispositivo determinado. El parámetro *lpInitData* debe ser NULL si el controlador de dispositivo va a usar la inicialización predeterminada (si existe) especificada por el usuario a través del Panel de control.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El IMPRESIÓN. El archivo de encabezado H es necesario si se utiliza la estructura [DEVMODE.](/windows/win32/api/wingdi/ns-wingdi-devmodea)

Los nombres de dispositivo salsiguen estas convenciones: dos puntos finales (:) se recomienda, pero opcional. Windows elimina los dos puntos finales para que un nombre de dispositivo que termine con dos puntos se asigne al mismo puerto que el mismo nombre sin dos puntos. Los nombres de controlador y puerto no deben contener espacios iniciales o finales. Las funciones de salida GDI no se pueden utilizar con contextos de información.

## <a name="cdccreateic"></a><a name="createic"></a>CDC::CreateIC

Crea un contexto de información para el dispositivo especificado.

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parámetros

*lpszDriverName*<br/>
Señala una cadena terminada en null que especifica el nombre de archivo (sin extensión) del controlador de dispositivo (por ejemplo, "EPSON"). Puede pasar `CString` un objeto para este parámetro.

*lpszDeviceName*<br/>
Señala a una cadena terminada en null que especifica el nombre del dispositivo específico que se admitirá (por ejemplo, "EPSON FX-80"). El parámetro *lpszDeviceName* se utiliza si el módulo admite más de un dispositivo. Puede pasar `CString` un objeto para este parámetro.

*lpszOutput*<br/>
Apunta a una cadena terminada en null que especifica el nombre de archivo o dispositivo para el medio de salida físico (archivo o puerto). Puede pasar `CString` un objeto para este parámetro.

*lpInitData*<br/>
Apunta a datos de inicialización específicos del dispositivo para el controlador de dispositivo. El parámetro *lpInitData* debe ser NULL si el controlador de dispositivo va a usar la inicialización predeterminada (si existe) especificada por el usuario a través del Panel de control. Consulte `CreateDC` el formato de datos para la inicialización específica del dispositivo.

### <a name="return-value"></a>Valor devuelto

Si es correcta, su valor es distinto de cero. En caso contrario, es cero.

### <a name="remarks"></a>Observaciones

El contexto de información proporciona una forma rápida de obtener información sobre el dispositivo sin crear un contexto de dispositivo.

Los nombres de dispositivo salsiguen estas convenciones: dos puntos finales (:) se recomienda, pero opcional. Windows elimina los dos puntos finales para que un nombre de dispositivo que termine con dos puntos se asigne al mismo puerto que el mismo nombre sin dos puntos. Los nombres de controlador y puerto no deben contener espacios iniciales o finales. Las funciones de salida GDI no se pueden utilizar con contextos de información.

## <a name="cdcdeletedc"></a><a name="deletedc"></a>CDC::DeleteDC

En general, no llame a esta función; el destructor lo hará por ti.

```
BOOL DeleteDC();
```

### <a name="return-value"></a>Valor devuelto

Distinto de cero si la función se completó correctamente; de lo contrario 0.

### <a name="remarks"></a>Observaciones

La `DeleteDC` función miembro elimina los contextos `m_hDC` de dispositivo `CDC` de Windows que están asociados en el objeto actual. Si `CDC` este objeto es el último contexto de dispositivo activo para un dispositivo determinado, se notifica al dispositivo y se liberan todos los recursos de almacenamiento y del sistema utilizados por el dispositivo.

Una aplicación no `DeleteDC` debe llamar si se han seleccionado objetos en el contexto del dispositivo. Los objetos deben seleccionarse primero fuera del contexto del dispositivo antes de eliminarlos.

Una aplicación no debe eliminar un contexto de dispositivo cuyo identificador se obtuvo mediante una llamada a [CWnd::GetDC](../../mfc/reference/cwnd-class.md#getdc). En su lugar, debe llamar a [CWnd::ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) para liberar el contexto del dispositivo. Las [clases CClientDC](../../mfc/reference/cclientdc-class.md) y [CWindowDC](../../mfc/reference/cwindowdc-class.md) se proporcionan para ajustar esta funcionalidad.

La `DeleteDC` función se utiliza generalmente para eliminar contextos de dispositivo creados con [CreateDC](#createdc), [CreateIC](#createic)o [CreateCompatibleDC](#createcompatibledc).

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcdeletetempmap"></a><a name="deletetempmap"></a>CDC::DeleteTempMap

Llamado automáticamente `CWinApp` por el controlador `DeleteTempMap` de tiempo `CDC` de `FromHandle`inactividad, elimina los objetos `hDC`temporales creados `CDC` por , pero no destruye los identificadores de contexto de dispositivo ( s) asociados temporalmente con los objetos.

```
static void PASCAL DeleteTempMap();
```

## <a name="cdcdetach"></a><a name="detach"></a>CDC::Dsetach

Llame a esta `m_hDC` función para separar (el contexto del dispositivo de salida) del `CDC` objeto y establezca ambos `m_hDC` y `m_hAttribDC` NULL.

```
HDC Detach();
```

### <a name="return-value"></a>Valor devuelto

Un contexto de dispositivo Windows.

## <a name="cdcdptohimetric"></a><a name="dptohimetric"></a>CDC::DPtoHIMETRIC

Utilice esta función cuando asigne tamaños HIMETRIC a OLE, convirtiendo píxeles a HIMETRIC.

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*lpSize*<br/>
Apunta a una estructura [SIZE](/windows/win32/api/windef/ns-windef-size) o a un objeto [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Observaciones

Si el modo de asignación del objeto de contexto de dispositivo es MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC o MM_HIMETRIC, la conversión se basa en el número de píxeles de la pulgada física. Si el modo de asignación es uno de los otros modos no restringidos (por ejemplo, MM_TEXT), la conversión se basa en el número de píxeles de la pulgada lógica.

## <a name="cdcdptolp"></a><a name="dptolp"></a>CDC::DPtoLP

Convierte unidades de dispositivo en unidades lógicas.

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de estructuras [POINT](/windows/win32/api/windef/ns-windef-point) u objetos [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*nCount*<br/>
El número de puntos de la matriz.

*lpRect*<br/>
Apunta a una estructura [RECT](/windows/win32/api/windef/ns-windef-rect) u [objeto CRect.](../../atl-mfc-shared/reference/crect-class.md) Este parámetro se utiliza para el caso simple de convertir un rectángulo de puntos de dispositivo a puntos lógicos.

*lpSize*<br/>
Apunta a una estructura [SIZE](/windows/win32/api/windef/ns-windef-size) o a un objeto [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Observaciones

La función asigna las coordenadas de cada punto, o dimensión de un tamaño, desde el sistema de coordenadas del dispositivo al sistema de coordenadas lógicas de GDI. La conversión depende del modo de asignación actual y de la configuración de los orígenes y extensiones de la ventana y la ventana gráfica del dispositivo.

## <a name="cdcdraw3drect"></a><a name="draw3drect"></a>CDC::Draw3dRect

Llame a esta función miembro para dibujar un rectángulo tridimensional.

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Especifica el rectángulo delimitador (en unidades lógicas). Puede pasar un puntero a una estructura [RECT](/windows/win32/api/windef/ns-windef-rect) o un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parámetro.

*clrTopLeft*<br/>
Especifica el color de los lados superior e izquierdo del rectángulo tridimensional.

*clrBottomRight*<br/>
Especifica el color de los lados inferior y derecho del rectángulo tridimensional.

*X*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo tridimensional.

*y y*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo tridimensional.

*Cx*<br/>
Especifica el ancho del rectángulo tridimensional.

*Cy*<br/>
Especifica la altura del rectángulo tridimensional.

### <a name="remarks"></a>Observaciones

El rectángulo se dibujará con los lados superior e izquierdo en el color especificado por *clrTopLeft* y los lados inferior y derecho en el color especificado por *clrBottomRight*.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

## <a name="cdcdrawdragrect"></a><a name="drawdragrect"></a>CDC::DrawDragRect

Llame a esta función miembro repetidamente para volver a dibujar un rectángulo de arrastre.

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Apunta a una estructura [RECT](/windows/win32/api/windef/ns-windef-rect) o a un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que especifica las coordenadas lógicas de un rectángulo, en este caso, la posición final del rectángulo que se va a dibujar.

*Tamaño*<br/>
Especifica el desplazamiento desde la esquina superior izquierda del borde exterior hasta la esquina superior izquierda del borde interior (es decir, el grosor del borde) de un rectángulo.

*lpRectLast*<br/>
Apunta a una estructura [RECT](/windows/win32/api/windef/ns-windef-rect) o a un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que especifica las coordenadas lógicas de la posición de un rectángulo, en este caso, la posición original del rectángulo que se va a volver a dibujar.

*sizeLast*<br/>
Especifica el desplazamiento desde la esquina superior izquierda del borde exterior hasta la esquina superior izquierda del borde interior (es decir, el grosor del borde) del rectángulo original que se va a dibujar.

*Pbrush*<br/>
Puntero a un objeto de pincel. Establézcalo en NULL para usar el pincel de semitonos predeterminado.

*pBrushLast*<br/>
Puntero al último objeto de pincel utilizado. Establézcalo en NULL para usar el pincel de semitonos predeterminado.

### <a name="remarks"></a>Observaciones

Llámalo en un bucle mientras muestras la posición del ratón, para dar retroalimentación visual. Cuando se `DrawDragRect`llama a , se borra el rectángulo anterior y se dibuja uno nuevo. Por ejemplo, a medida que el usuario `DrawDragRect` arrastre un rectángulo a través de la pantalla, borrará el rectángulo original y volverá a dibujar uno nuevo en su nueva posición. De forma `DrawDragRect` predeterminada, dibuja el rectángulo mediante un pincel de semitonos para eliminar el parpadeo y crear la apariencia de un rectángulo que se mueve suavemente.

La primera vez `DrawDragRect`que se llama a , el parámetro *lpRectLast* debe ser NULL.

## <a name="cdcdrawedge"></a><a name="drawedge"></a>CDC::DrawEdge

Llame a esta función miembro para dibujar los bordes de un rectángulo del tipo y estilo especificados.

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Puntero a `RECT` una estructura que contiene las coordenadas lógicas del rectángulo.

*nEdge*<br/>
Especifica el tipo de arista interior y exterior que se va a dibujar. Este parámetro debe ser una combinación de un indicador de borde interno y un indicador de borde exterior. Consulte [DrawEdge](/windows/win32/api/winuser/nf-winuser-drawedge) en el Windows SDK para obtener una tabla de los tipos del parámetro.

*nFlags*<br/>
Las marcas que especifican el tipo de borde que se va a dibujar. Consulte `DrawEdge` en el Windows SDK para obtener una tabla de los valores del parámetro. Para las líneas diagonales, los indicadores BF_RECT especifican el punto final del vector delimitado por el parámetro rectángulo.

### <a name="return-value"></a>Valor devuelto

Si es correcta, su valor es distinto de cero. En caso contrario, es cero.

## <a name="cdcdrawescape"></a><a name="drawescape"></a>CDC::DrawEscape

Accede a las capacidades de dibujo de una pantalla de vídeo que no están disponibles directamente a través de la interfaz del dispositivo gráfico (GDI).

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>Parámetros

*nEscape*<br/>
Especifica la función de escape que se va a realizar.

*nInputSize*<br/>
Especifica el número de bytes de datos a los que apunta el parámetro *lpszInputData.*

*lpszInputData*<br/>
Apunta a la estructura de entrada necesaria para el escape especificado.

### <a name="return-value"></a>Valor devuelto

Especifica el resultado de la función. Mayor que cero si se realiza correctamente, excepto para QUERYESCSUPPORT dibujar escape, que comprueba solo la implementación; o cero si el escape no se implementa; o menos de cero si se produjo un error.

### <a name="remarks"></a>Observaciones

Cuando una `DrawEscape`aplicación llama a , los datos identificados por *nInputSize* y *lpszInputData* se pasan directamente al controlador de pantalla especificado.

## <a name="cdcdrawfocusrect"></a><a name="drawfocusrect"></a>CDC::DrawFocusRect

Dibuja un rectángulo en el estilo utilizado para indicar que el rectángulo tiene el foco.

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Apunta a una estructura [RECT](/windows/win32/api/windef/ns-windef-rect) o a un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que especifica las coordenadas lógicas del rectángulo que se va a dibujar.

### <a name="remarks"></a>Observaciones

Puesto que se trata de una función XOR booleana, llamar a esta función una segunda vez con el mismo rectángulo quita el rectángulo de la pantalla. El rectángulo dibujado por esta función no se puede desplazar. Para desplazar un área que contiene un `DrawFocusRect` rectángulo dibujado por esta función, primero llame `DrawFocusRect` para quitar el rectángulo de la pantalla, luego desplácese por el área y, a continuación, llame de nuevo para dibujar el rectángulo en la nueva posición.

> [!CAUTION]
> `DrawFocusRect`sólo funciona en modo MM_TEXT. En otros modos, esta función no dibuja el rectángulo de foco correctamente, pero no devuelve valores de error.

## <a name="cdcdrawframecontrol"></a><a name="drawframecontrol"></a>CDC::DrawFrameControl

Llame a esta función miembro para dibujar un control de marco del tipo y estilo especificados.

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Puntero a `RECT` una estructura que contiene las coordenadas lógicas del rectángulo.

*nType*<br/>
Especifica el tipo de control de marco que se va a dibujar. Vea el parámetro *uType* en [DrawFrameControl](/windows/win32/api/winuser/nf-winuser-drawframecontrol) en el Windows SDK para obtener una lista de los valores posibles de este parámetro.

*nEstado*<br/>
Especifica el estado inicial del control de fotogramas. Puede ser uno o varios de los valores `DrawFrameControl` descritos para el *uState* parámetro en el Windows SDK. Utilice el DFCS_ADJUSTRECT de valor *nState* para ajustar el rectángulo delimitador para excluir el borde circundante del botón pulsador.

### <a name="return-value"></a>Valor devuelto

Si es correcta, su valor es distinto de cero. En caso contrario, es cero.

### <a name="remarks"></a>Observaciones

En varios casos, *nState* depende del parámetro *nType.* La lista siguiente muestra la relación entre los cuatro valores *nType* y *nState:*

- DFC_BUTTON

  - DFCS_BUTTON3STATE botón de tres estados

  - casilla de verificación DFCS_BUTTONCHECK

  - DFCS_BUTTONPUSH pulsador

  - Botón de DFCS_BUTTONRADIO De radio

  - DFCS_BUTTONRADIOIMAGE imagen para el botón de radio (imagen de necesidades no cuadradas)

  - Máscara DFCS_BUTTONRADIOMASK para el botón de opción (máscara de necesidades no cuadradas)

- DFC_CAPTION

  - DFCS_CAPTIONCLOSE botón Cerrar

  - Botón ayuda de DFCS_CAPTIONHELP

  - DFCS_CAPTIONMAX botón Maximizar

  - botón DFCS_CAPTIONMIN Minimizar

  - DFCS_CAPTIONRESTORE botón Restaurar

- DFC_MENU

  - DFCS_MENUARROW flecha del submenú

  - DFCS_MENUBULLET Bala

  - marca de verificación DFCS_MENUCHECK

- DFC_SCROLL

  - barra de desplazamiento del cuadro combinado DFCS_SCROLLCOMBOBOX

  - DFCS_SCROLLDOWN flecha hacia abajo de la barra de desplazamiento

  - DFCS_SCROLLLEFT Flecha izquierda de la barra de desplazamiento

  - DFCS_SCROLLRIGHT Flecha derecha de la barra de desplazamiento

  - DFCS_SCROLLSIZEGRIP Pinza de tamaño en la esquina inferior derecha de la ventana

  - DFCS_SCROLLUP Flecha arriba de la barra de desplazamiento

### <a name="example"></a>Ejemplo

Este código dibuja el pinzamiento de tamaño en la esquina inferior derecha de la ventana. Es adecuado para `OnPaint` el controlador de un cuadro de diálogo, que no tiene estilos y normalmente no contiene otros controles (como una barra de estado) que pueden darle una pinza de tamaño.

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

## <a name="cdcdrawicon"></a><a name="drawicon"></a>CDC::DrawIcon

Dibuja un icono en el dispositivo representado `CDC` por el objeto actual.

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del icono.

*y y*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del icono.

*hIcon*<br/>
Identifica el identificador del icono que se va a dibujar.

*Punto*<br/>
Especifica las coordenadas x e y lógicas de la esquina superior izquierda del icono. Puede pasar una estructura [POINT](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parámetro.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si la función se completó correctamente; de lo contrario 0.

### <a name="remarks"></a>Observaciones

La función coloca la esquina superior izquierda del icono en la ubicación especificada por *x* e *y*. La ubicación está sujeta al modo de asignación actual del contexto del dispositivo.

El recurso de icono debe haberse `CWinApp::LoadIcon`cargado `CWinApp::LoadStandardIcon`previamente mediante las funciones , , o `CWinApp::LoadOEMIcon`. El `MM_TEXT` modo de asignación debe seleccionarse antes de utilizar esta función.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic).

## <a name="cdcdrawstate"></a><a name="drawstate"></a>CDC::DrawState

Llame a esta función miembro para mostrar una imagen y aplicar un efecto visual para indicar un estado, como un estado deshabilitado o predeterminado.

> [!NOTE]
> Para todos los estados *nFlag* excepto DSS_NORMAL, la imagen se convierte en monocromo antes de aplicar el efecto visual.

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>Parámetros

*Pt*<br/>
Especifica la ubicación de la imagen.

*Tamaño*<br/>
Especifica el tamaño de la imagen.

*hBitmap*<br/>
Identificador de un mapa de bits.

*nFlags*<br/>
Indicadores que especifican el tipo y el estado de la imagen. Consulte [DrawState](/windows/win32/api/winuser/nf-winuser-drawstatew) en el Windows SDK para los posibles *nFlags* tipos y estados.

*hBrush*<br/>
Un mango para un cepillo.

*pBitmap*<br/>
Un puntero a un CBitmap objeto.

*Pbrush*<br/>
Un puntero a un CBrush objeto.

*hIcon*<br/>
Identificador de un icono.

*lpszText*<br/>
Un puntero al texto.

*bPrefixText*<br/>
Texto que puede contener un acelerador mnemotécnico. El *lData* parámetro especifica la dirección de la cadena y el *nTextLen* parámetro especifica la longitud. Si *nTextLen* es 0, se supone que la cadena está terminada en null.

*nTextLen*<br/>
Longitud de la cadena de texto señalada por *lpszText*. Si *nTextLen* es 0, se supone que la cadena está terminada en null.

*lpDrawProc*<br/>
Puntero a una función de devolución de llamada utilizada para representar una imagen. Este parámetro es necesario si el tipo de imagen en *nFlags* es DST_COMPLEX. Es opcional y puede ser NULL si el tipo de imagen es DST_TEXT. Para todos los demás tipos de imagen, se omite este parámetro. Para obtener más información acerca de la función de devolución de llamada, vea la [función DrawStateProc](/windows/win32/api/winuser/nc-winuser-drawstateproc) en el Windows SDK.

*lData*<br/>
Especifica información sobre la imagen. El significado de este parámetro depende del tipo de imagen.

### <a name="return-value"></a>Valor devuelto

Si es correcta, su valor es distinto de cero. En caso contrario, es cero.

## <a name="cdcdrawtext"></a><a name="drawtext"></a>CDC::DrawText

Llame a esta función miembro para dar formato al texto en el rectángulo especificado. Para especificar opciones de formato adicionales, utilice [CDC::DrawTextEx](#drawtextex).

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>Parámetros

*lpszString*<br/>
Apunta a la cadena que se va a dibujar. Si *nCount* es -1, la cadena debe estar terminada en null.

*nCount*<br/>
Especifica el número de caracteres de la cadena. Si *nCount* es -1, se supone *que lpszString* es un puntero `DrawText` largo a una cadena terminada en null y calcula el recuento de caracteres automáticamente.

*lpRect*<br/>
Apunta a una estructura [RECT](/windows/win32/api/windef/ns-windef-rect) o un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que contiene el rectángulo (en coordenadas lógicas) en el que se va a dar formato al texto.

*Str*<br/>
Un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto que contiene los caracteres especificados que se van a dibujar.

*nFormato*<br/>
Especifica el método de dar formato al texto. Puede ser cualquier combinación de los valores descritos para el parámetro *uFormat* en [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) en el Windows SDK. (combinar utilizando el operador OR bit a bit):

> [!NOTE]
> Algunas combinaciones de indicadores *uFormat* pueden hacer que se modifique la cadena pasada. El uso de DT_MODIFYSTRING con DT_END_ELLIPSIS o DT_PATH_ELLIPSIS puede hacer que `CString` se modifique la cadena, lo que provoca una aserción en la invalidación. Los valores DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP y DT_NOPREFIX no se pueden utilizar con el valor DT_TABSTOP.

### <a name="return-value"></a>Valor devuelto

La altura del texto si la función se realiza correctamente.

### <a name="remarks"></a>Observaciones

Da formato al texto expandiendo las pestañas en espacios apropiados, alineando el texto a la izquierda, derecha o el centro del rectángulo dado y dividiendo el texto en líneas que se ajustan dentro del rectángulo dado. El tipo de formato se especifica mediante *nFormat*.

Esta función miembro utiliza la fuente, el color de texto y el color de fondo seleccionados del contexto del dispositivo para dibujar el texto. A menos que se `DrawText` utilice el formato de DT_NOCLIP, recorta el texto para que el texto no aparezca fuera del rectángulo especificado. Se supone que todo el formato tiene varias líneas a menos que se dé el formato DT_SINGLELINE.

Si la fuente seleccionada es demasiado grande `DrawText` para el rectángulo especificado, la función miembro no intenta sustituir una fuente más pequeña.

Si se especifica el DT_CALCRECT marca, el rectángulo especificado por *lpRect* se actualizará para reflejar el ancho y alto necesariopara dibujar el texto.

Si se ha establecido el TA_UPDATECP indicador de alineación `DrawText` de texto (consulte [CDC::SetTextAlign](#settextalign)), mostrará el texto comenzando en la posición actual, en lugar de a la izquierda del rectángulo especificado. `DrawText`no ajustará el texto cuando se haya establecido la marca TA_UPDATECP (es decir, la DT_WORDBREAK marca no tendrá ningún efecto).

El color del texto se puede establecer mediante [CDC::SetTextColor](#settextcolor).

## <a name="cdcdrawtextex"></a><a name="drawtextex"></a>CDC::DrawTextEx

Da formato al texto del rectángulo especificado.

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>Parámetros

*lpszString*<br/>
Apunta a la cadena que se va a dibujar. Si *nCount* es -1, la cadena debe ser null terminated.

*nCount*<br/>
Especifica el número de caracteres de la cadena. Si *nCount* es -1, se supone *que lpszString* es un puntero `DrawText` largo a una cadena terminada en null y calcula el recuento de caracteres automáticamente.

*lpRect*<br/>
Apunta a una estructura [RECT](/windows/win32/api/windef/ns-windef-rect) o un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que contiene el rectángulo (en coordenadas lógicas) en el que se va a dar formato al texto.

*Str*<br/>
Un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto que contiene los caracteres especificados que se van a dibujar.

*nFormato*<br/>
Especifica el método de dar formato al texto. Puede ser cualquier combinación de los valores descritos para el parámetro *uFormat* en [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) en el Windows SDK. (Combinar utilizando el operador **OR** bit a bit):

> [!NOTE]
> Algunas combinaciones de indicadores *uFormat* pueden hacer que se modifique la cadena pasada. El uso de DT_MODIFYSTRING con DT_END_ELLIPSIS o DT_PATH_ELLIPSIS puede hacer que `CString` se modifique la cadena, lo que provoca una aserción en la invalidación. Los valores DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP y DT_NOPREFIX no se pueden utilizar con el valor DT_TABSTOP.

*lpDTParams*<br/>
Puntero a una estructura [DRAWTEXTPARAMS](/windows/win32/api/winuser/ns-winuser-drawtextparams) que especifica opciones de formato adicionales. Este parámetro puede ser NULL.

### <a name="remarks"></a>Observaciones

Da formato al texto expandiendo las pestañas en espacios apropiados, alineando el texto a la izquierda, derecha o el centro del rectángulo dado y dividiendo el texto en líneas que se ajustan dentro del rectángulo dado. El tipo de formato se especifica mediante *nFormat* y *lpDTParams*. Para obtener más información, vea [CDC::DrawText](#drawtext) y [DrawTextEx](/windows/win32/api/winuser/nf-winuser-drawtextexw) en el Windows SDK.

El color del texto se puede establecer mediante [CDC::SetTextColor](#settextcolor).

## <a name="cdcellipse"></a><a name="ellipse"></a>CDC::Elipse

Dibuja una elipse.

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>Parámetros

*x1*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo delimitador de la elipse.

*y1*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo delimitador de la elipse.

*x2*<br/>
Especifica la coordenada x lógica de la esquina inferior derecha del rectángulo delimitador de la elipse.

*y2*<br/>
Especifica la coordenada y lógica de la esquina inferior derecha del rectángulo delimitador de la elipse.

*lpRect*<br/>
Especifica el rectángulo delimitador de la elipse. También puede pasar un [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El centro de la elipse es el centro del rectángulo delimitador especificado por *x1*, *y1*, *x2*e *y2,* o *lpRect*. La elipse se dibuja con la pluma actual, y su interior se rellena con el pincel actual.

La figura dibujada por esta función se extiende hasta, pero no incluye, las coordenadas derecha e inferior. Esto significa que la altura de la figura es *y2* - *y1* y la anchura de la figura es *x2* - *x1*.

Si el ancho o el alto del rectángulo delimitador es 0, no se dibuja ninguna elipse.

## <a name="cdcenddoc"></a><a name="enddoc"></a>CDC::EndDoc

Finaliza un trabajo de impresión iniciado por una llamada a la [StartDoc](#startdoc) función miembro.

```
int EndDoc();
```

### <a name="return-value"></a>Valor devuelto

Mayor o igual que 0 si la función es correcta, o un valor negativo si se produjo un error.

### <a name="remarks"></a>Observaciones

Esta función miembro reemplaza el escape de impresora ENDDOC y debe llamarse inmediatamente después de finalizar un trabajo de impresión correcto.

Si una aplicación encuentra un error de impresión o una operación de `EndDoc` impresión cancelada, no debe intentar finalizar la operación mediante cualquiera o [AbortDoc](#abortdoc). GDI finaliza automáticamente la operación antes de devolver el valor de error.

Esta función no debe utilizarse dentro de metarchivos.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC::StartDoc](#startdoc).

## <a name="cdcendpage"></a><a name="endpage"></a>CDC::EndPage

Informa al dispositivo que la aplicación ha terminado de escribir en una página.

```
int EndPage();
```

### <a name="return-value"></a>Valor devuelto

Mayor o igual que 0 si la función es correcta, o un valor negativo si se produjo un error.

### <a name="remarks"></a>Observaciones

Esta función miembro se utiliza normalmente para dirigir el controlador de dispositivo para avanzar a una nueva página.

Esta función miembro reemplaza el escape de la impresora NEWFRAME. A diferencia de NEWFRAME, siempre se llama a esta función después de imprimir una página.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC::StartDoc](#startdoc).

## <a name="cdcendpath"></a><a name="endpath"></a>CDC::EndPath

Cierra un corchete de ruta y selecciona la ruta definida por el corchete en el contexto del dispositivo.

```
BOOL EndPath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC::BeginPath](#beginpath).

## <a name="cdcenumobjects"></a><a name="enumobjects"></a>CDC::EnumObjects

Enumera las plumas y pinceles disponibles en un contexto de dispositivo.

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>Parámetros

*nObjectType*<br/>
Especifica el tipo de objeto. Puede tener los valores OBJ_BRUSH o OBJ_PEN.

*lpfn*<br/>
Es la dirección de instancia de procedimiento de la función de devolución de llamada proporcionada por la aplicación. Consulte la sección "Comentarios" a continuación.

*lpData*<br/>
Señala los datos proporcionados por la aplicación. Los datos se pasan a la función de devolución de llamada junto con la información del objeto.

### <a name="return-value"></a>Valor devuelto

Especifica el último valor devuelto por la [función](callback-functions-used-by-mfc.md#enum_objects)de devolución de llamada . Su significado está definido por el usuario.

### <a name="remarks"></a>Observaciones

Para cada objeto de un tipo determinado, se llama a la función de devolución de llamada que se pasa con la información de ese objeto. El sistema llama a la función de devolución de llamada hasta que no hay más objetos o la función de devolución de llamada devuelve 0.

Tenga en cuenta que las nuevas características de Microsoft Visual `EnumObjects`C++ permiten utilizar una función normal como la función pasada a . La dirección `EnumObjects` a la que se pasa es un puntero a una función exportada con **EXPORT** y con la convención de llamada Pascal. En las aplicaciones de modo de protección, no es necesario crear esta función con la función MakeProcInstance de Windows o liberar la función después de su uso con la función de Windows FreeProcInstance.

Tampoco es necesario exportar el nombre de función en una instrucción **EXPORTS** en el archivo de definición de módulo de la aplicación. En su lugar, puede utilizar el modificador de función **EXPORT,** como en

**INt EXPORTACIÓN DE DEVOLUCIÓN DE LLAMADA** AFunction **(LPSTR,** **LPSTR);**

para hacer que el compilador emita el registro de exportación adecuado para exportar por nombre sin alias. Esto funciona para la mayoría de las necesidades. Para algunos casos especiales, como exportar una función ordinal o crear un alias de la exportación, todavía debe utilizar una instrucción **EXPORTS** en un archivo de definición de módulo.

Para compilar programas de Microsoft Foundation, normalmente usará las opciones del compilador /GA y /GEs. La opción del compilador /Gw no se utiliza con las clases de Microsoft Foundation. (Si utiliza la función `MakeProcInstance`windows , deberá convertir explícitamente el puntero de función devuelto de FARPROC al tipo necesario en esta API.) Las interfaces de registro de devolución de llamada ahora son seguras para tipos (debe pasar un puntero de función que apunte al tipo correcto de función para la devolución de llamada específica).

Tenga en cuenta también que todas las funciones de devolución de llamada deben capturar las excepciones de Microsoft Foundation antes de volver a Windows, ya que las excepciones no se pueden producir a través de los límites de devolución de llamada. Para obtener más información acerca de las excepciones, vea el artículo [Excepciones](../../mfc/exception-handling-in-mfc.md).

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

## <a name="cdcescape"></a><a name="escape"></a>CDC::Escape

Esta función miembro está prácticamente obsoleta para la programación de Win32.

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>Parámetros

*nEscape*<br/>
Especifica la función de escape que se va a realizar.

Para obtener una lista completa de las funciones de escape, consulte [Escape](/windows/win32/api/wingdi/nf-wingdi-escape) en el Windows SDK.

*nCount*<br/>
Especifica el número de bytes de datos a los que apunta *lpszInData*.

*lpszInData*<br/>
Señala la estructura de datos de entrada necesaria para este escape.

*lpOutData*<br/>
Señala a la estructura que va a recibir la salida de este escape. El parámetro *lpOutData* es NULL si no se devuelve ningún dato.

*nInputSize*<br/>
Especifica el número de bytes de datos a los que apunta el parámetro *lpszInputData.*

*lpszInputData*<br/>
Apunta a la estructura de entrada necesaria para el escape especificado.

*nOutputSize*<br/>
Especifica el número de bytes de datos a los que apunta el parámetro *lpszOutputData.*

*lpszOutputData*<br/>
Apunta a la estructura que recibe la salida de este escape. Este parámetro debe ser NULL si no se devuelve ningún dato.

### <a name="return-value"></a>Valor devuelto

Se devuelve un valor positivo si la función se realiza correctamente, excepto el escape QUERYESCSUPPORT, que solo comprueba la implementación. Se devuelve cero si no se implementa el escape. Se devuelve un valor negativo si se ha producido un error. Los siguientes son valores de error comunes:

- SP_ERROR Error general.

- SP_OUTOFDISK No hay suficiente espacio en disco disponible actualmente para la cola de impresión y no habrá más espacio disponible.

- SP_OUTOFMEMORY No hay suficiente memoria disponible para el spooling.

- SP_USERABORT Usuario terminó el trabajo a través del Administrador de impresión.

### <a name="remarks"></a>Observaciones

De los escapes de la impresora original, solo QUERYESCSUPPORT es compatible con aplicaciones Win32. Todos los demás escapes de impresora están obsoletos y solo se admiten para la compatibilidad con aplicaciones de 16 bits.

Para la programación `CDC` de Win32, ahora proporciona seis funciones miembro que reemplazan sus escapes de impresora correspondientes:

- [CDC::AbortDoc](#abortdoc)

- [CDC::EndDoc](#enddoc)

- [CDC::EndPage](#endpage)

- [CDC::SetAbortProc](#setabortproc)

- [CDC::StartDoc](#startdoc)

- [CDC::StartPage](#startpage)

Además, [CDC::GetDeviceCaps](#getdevicecaps) admite índices Win32 que reemplazan a otros escapes de impresora. Consulte [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) en el Windows SDK para obtener más información.

Esta función miembro permite a las aplicaciones acceder a las instalaciones de un dispositivo determinado que no están disponibles directamente a través de GDI.

Utilice la primera versión si la aplicación utiliza valores de escape predefinidos. Utilice la segunda versión si la aplicación define valores de escape privados. Consulte [ExtEscape](/windows/win32/api/wingdi/nf-wingdi-extescape) en el Windows SDK para obtener más información acerca de la segunda versión.

## <a name="cdcexcludecliprect"></a><a name="excludecliprect"></a>CDC::ExcludeClipRect

Crea una nueva región de recorte que consta de la región de recorte existente menos el rectángulo especificado.

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parámetros

*x1*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo.

*y1*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo.

*x2*<br/>
Especifica la coordenada x lógica de la esquina inferior derecha del rectángulo.

*y2*<br/>
Especifica la coordenada y lógica de la esquina inferior derecha del rectángulo.

*lpRect*<br/>
Especifica el rectángulo. También puede `CRect` ser un objeto.

### <a name="return-value"></a>Valor devuelto

Especifica el tipo de la nueva región de recorte. Puede ser cualquiera de los siguientes valores:

- COMPLEXREGION La región tiene bordes superpuestos.

- ERROR No se ha creado ninguna región.

- NULLREGION La región está vacía.

- SIMPLEREGION La región no tiene bordes superpuestos.

### <a name="remarks"></a>Observaciones

El ancho del rectángulo, especificado por el valor absoluto de *x2* - *x1*, no debe superar las 32.767 unidades. Este límite también se aplica a la altura del rectángulo.

## <a name="cdcexcludeupdatergn"></a><a name="excludeupdatergn"></a>CDC::ExcludeUpdateRgn

Impide dibujar dentro de áreas no válidas de una ventana excluyendo `CDC` una región actualizada en la ventana de la región de recorte asociada al objeto.

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>Parámetros

*pWnd*<br/>
Señala al objeto de ventana cuya ventana se está actualizando.

### <a name="return-value"></a>Valor devuelto

El tipo de región excluida. Puede ser cualquiera de los siguientes valores:

- COMPLEXREGION La región tiene bordes superpuestos.

- ERROR No se ha creado ninguna región.

- NULLREGION La región está vacía.

- SIMPLEREGION La región no tiene bordes superpuestos.

## <a name="cdcextfloodfill"></a><a name="extfloodfill"></a>CDC::ExtFloodFill

Rellena un área de la superficie de visualización con el pincel actual.

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x lógica del punto donde comienza el relleno.

*y y*<br/>
Especifica la coordenada y lógica del punto donde comienza el relleno.

*crColor*<br/>
Especifica el color del contorno o del área que se va a rellenar. La interpretación de *crColor* depende del valor de *nFillType*.

*nFillType*<br/>
Especifica el tipo de relleno de inundación que se va a realizar. Debe ser cualquiera de los siguientes valores:

- FLOODFILLBORDER El área de relleno está delimitada por el color especificado por *crColor*. Este estilo es idéntico al `FloodFill`relleno realizado por .

- FLOODFILLSURFACE El área de relleno se define por el color especificado por *crColor*. El relleno continúa hacia afuera en todas las direcciones, siempre y cuando se encuentre el color. Este estilo es útil para rellenar áreas con contornos multicolores.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si la función es correcta; de lo contrario 0 si no se pudo completar el relleno, si el punto dado tiene el color de contorno especificado por *crColor* (si se solicitó FLOODFILLBORDER), si el punto dado no tiene el color especificado por *crColor* (si se solicitó FLOODFILLSURFACE), o si el punto está fuera de la región de recorte.

### <a name="remarks"></a>Observaciones

Esta función miembro ofrece `FloodFill` más flexibilidad que porque puede especificar un tipo de relleno en *nFillType*.

Si *nFillType* se establece en FLOODFILLBORDER, se supone que el área está completamente delimitada por el color especificado por *crColor*. La función comienza en el punto especificado por *x* e *y* y rellena todas las direcciones hasta el límite de color.

Si *nFillType* se establece en FLOODFILLSURFACE, la función comienza en el punto especificado por *x* e *y* y continúa en todas las direcciones, rellenando todas las áreas adyacentes que contienen el color especificado por *crColor*.

Solo los contextos de dispositivos de memoria `ExtFloodFill`y los dispositivos que admiten la tecnología de visualización de ráster admiten la tecnología . Para obtener más información, vea el [GetDeviceCaps](#getdevicecaps) función miembro.

## <a name="cdcexttextout"></a><a name="exttextout"></a>CDC::ExtTextOut

Llame a esta función miembro para escribir una cadena de caracteres dentro de una región rectangular mediante la fuente seleccionada actualmente.

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x lógica de la celda de caracteres para el primer carácter de la cadena especificada.

*y y*<br/>
Especifica la coordenada y lógica de la parte superior de la celda de caracteres para el primer carácter de la cadena especificada.

*nOpciones*<br/>
Especifica el tipo de rectángulo. Este parámetro puede ser uno, ambos o ninguno de los siguientes valores:

- ETO_CLIPPED Especifica que el texto se recorta al rectángulo.

- ETO_OPAQUE Especifica que el color de fondo actual rellena el rectángulo. (Puede establecer y consultar el color de fondo actual con el [SetBkColor](#setbkcolor) y [GetBkColor](#getbkcolor) funciones miembro.)

*lpRect*<br/>
Apunta a una estructura [RECT](/windows/win32/api/windef/ns-windef-rect) que determina las dimensiones del rectángulo. Este parámetro puede ser NULL. También puede pasar un [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto para este parámetro.

*lpszString*<br/>
Apunta a la cadena de caracteres especificada que se va a dibujar. También puede pasar un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto para este parámetro.

*nCount*<br/>
Especifica el número de caracteres de la cadena.

*lpDxWidths*<br/>
Apunta a una matriz de valores que indican la distancia entre los orígenes de las celdas de caracteres adyacentes. Por ejemplo, las unidades lógicas *lpDxWidths*[ *i*] separarán los orígenes de la celda de caracteres *i* y la celda de caracteres *i* + 1. Si *lpDxWidths* es `ExtTextOut` NULL, utiliza el espaciado predeterminado entre caracteres.

*Str*<br/>
Objeto `CString` que contiene los caracteres especificados que se van a dibujar.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La región rectangular puede ser opaca (rellena con el color de fondo actual) y puede ser una región de recorte.

Si *nOptions* es 0 y *lpRect* es NULL, la función escribe texto en el contexto del dispositivo sin usar una región rectangular. De forma predeterminada, la función no usa ni actualiza la posición actual. Si una aplicación necesita actualizar la `ExtTextOut`posición actual cuando `CDC` llama a , la aplicación puede llamar a la función miembro [SetTextAlign](#settextalign) con *nFlags* establecido en TA_UPDATECP. Cuando se establece esta marca, Windows omite *x* e *y* en las llamadas posteriores y `ExtTextOut` utiliza la posición actual en su lugar. Cuando una aplicación utiliza TA_UPDATECP para `ExtTextOut` actualizar la posición actual, establece la posición actual en el final de la línea de texto anterior o en la posición especificada por el último elemento de la matriz a la que apunta *lpDxWidths,* lo que sea mayor.

## <a name="cdcfillpath"></a><a name="fillpath"></a>CDC::FillPath

Cierra las figuras abiertas en el trazado actual y rellena el interior del trazado utilizando el pincel actual y el modo de relleno de polígonos.

```
BOOL FillPath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Una vez que se llena su interior, la ruta se descarta del contexto del dispositivo.

## <a name="cdcfillrect"></a><a name="fillrect"></a>CDC::FillRect

Llame a esta función miembro para rellenar un rectángulo determinado mediante el pincel especificado.

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Apunta a una estructura [RECT](/windows/win32/api/windef/ns-windef-rect) que contiene las coordenadas lógicas del rectángulo que se va a rellenar. También puede pasar un [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto para este parámetro.

*Pbrush*<br/>
Identifica el pincel utilizado para rellenar el rectángulo.

### <a name="remarks"></a>Observaciones

La función rellena el rectángulo completo, incluidos los bordes izquierdo y superior, pero no rellena los bordes derecho e inferior.

El pincel debe crearse mediante las funciones miembro de [CBrush](../../mfc/reference/cbrush-class.md) [CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)y [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush), o recuperarse mediante la `GetStockObject` función Windows .

Al rellenar el rectángulo `FillRect` especificado, no incluye los lados derecho e inferior del rectángulo. GDI rellena un rectángulo hasta, pero no incluye, la columna derecha y la fila inferior, independientemente del modo de asignación actual. `FillRect`compara los valores `top`de `bottom` `left`los `right` miembros , , , y del rectángulo especificado. Si `bottom` es menor o `top`igual `right` que , o `left`si es menor o igual que , el rectángulo no se dibuja.

`FillRect`es similar a [CDC::FillSolidRect](#fillsolidrect); sin `FillRect` embargo, toma un pincel y por lo tanto se puede utilizar para rellenar un rectángulo con un color sólido, un color tramado, pinceles sombreados o un patrón. `FillSolidRect`utiliza sólo colores sólidos (indicados por un parámetro COLORREF). `FillRect`por lo general `FillSolidRect`es más lento que .

## <a name="cdcfillrgn"></a><a name="fillrgn"></a>CDC::FillRgn

Rellena la región especificada por *pRgn* con el pincel especificado por *pBrush*.

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parámetros

*pRgn*<br/>
Un puntero a la región que se va a rellenar. Las coordenadas de la región dada se especifican en unidades lógicas.

*Pbrush*<br/>
Identifica el pincel que se utilizará para rellenar la región.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El pincel debe crearse `CBrush` utilizando las `CreateHatchBrush`funciones miembro , `CreatePatternBrush`, `CreateSolidBrush`, o ser recuperado por `GetStockObject`.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).

## <a name="cdcfillsolidrect"></a><a name="fillsolidrect"></a>CDC::FillSolidRect

Llame a esta función miembro para rellenar el rectángulo especificado con el color sólido especificado.

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Especifica el rectángulo delimitador (en unidades lógicas). Puede pasar un puntero a una estructura `CRect` de datos [RECT](/windows/win32/api/windef/ns-windef-rect) o un objeto para este parámetro.

*clr* Especifica el color que se utilizará para rellenar el rectángulo.

*X*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo.

*y y*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo de destino.

*Cx*<br/>
Especifica el ancho del rectángulo.

*Cy*<br/>
Especifica la altura del rectángulo.

### <a name="remarks"></a>Observaciones

`FillSolidRect`es muy similar a [CDC::FillRect](#fillrect); sin `FillSolidRect` embargo, utiliza sólo colores sólidos `FillRect` (indicados por el parámetro COLORREF), mientras que toma un pincel y, por lo tanto, se puede utilizar para rellenar un rectángulo con un color sólido, un color tramado, pinceles sombreados o un patrón. `FillSolidRect`por lo `FillRect`general es más rápido que .

> [!NOTE]
> Cuando se `FillSolidRect`llama a , el color de fondo, que se estableció previamente mediante [SetBkColor](#setbkcolor), se establece en el color indicado por *clr*.

## <a name="cdcflattenpath"></a><a name="flattenpath"></a>CDC::FlattenPath

Transforma las curvas del trazado seleccionado en el contexto del dispositivo actual y convierte cada curva en una secuencia de líneas.

```
BOOL FlattenPath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

## <a name="cdcfloodfill"></a><a name="floodfill"></a>CDC::FloodFill

Rellena un área de la superficie de visualización con el pincel actual.

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x lógica del punto donde comienza el relleno.

*y y*<br/>
Especifica la coordenada y lógica del punto donde comienza el relleno.

*crColor*<br/>
Especifica el color del contorno.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si la función es correcta; de lo contrario, se devuelve 0 si no se pudo completar el relleno, el punto dado tiene el color de contorno especificado por *crColor*o el punto está fuera de la región de recorte.

### <a name="remarks"></a>Observaciones

Se supone que el área está delimitada según lo especificado por *crColor*. La `FloodFill` función comienza en el punto especificado por *x* e *y* y continúa en todas las direcciones hasta el límite de color.

Solo los contextos de dispositivo de memoria y `FloodFill` los dispositivos que admiten la tecnología de visualización de ráster admiten la función miembro. Para obtener información acerca `GetDeviceCaps` de RC_BITBLT capacidad, vea la función miembro.

La `ExtFloodFill` función proporciona una capacidad similar pero una mayor flexibilidad.

## <a name="cdcframerect"></a><a name="framerect"></a>CDC::FrameRect

Dibuja un borde alrededor del rectángulo especificado por *lpRect*.

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Apunta a una estructura [RECT](/windows/win32/api/windef/ns-windef-rect) o un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que contiene las coordenadas lógicas de las esquinas superior izquierda e inferior derecha del rectángulo. También puede pasar `CRect` un objeto para este parámetro.

*Pbrush*<br/>
Identifica el pincel que se utilizará para enmarcar el rectángulo.

### <a name="remarks"></a>Observaciones

La función utiliza el pincel dado para dibujar el borde. La anchura y la altura del borde siempre es de 1 unidad lógica.

Si la coordenada `bottom` del rectángulo es `top`menor o `right` igual que , `left`o si es menor o igual que , el rectángulo no se dibuja.

El borde `FrameRect` dibujado por está en la misma `Rectangle` posición que un borde `Rectangle` dibujado por la función miembro utilizando las mismas coordenadas (si utiliza un lápiz que es 1 unidad lógica de ancho). El interior del rectángulo no `FrameRect`se rellena con .

## <a name="cdcframergn"></a><a name="framergn"></a>CDC::FrameRgn

Dibuja un borde alrededor de la región especificada por *pRgn* utilizando el pincel especificado por *pBrush*.

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parámetros

*pRgn*<br/>
Apunta al `CRgn` objeto que identifica la región que se va a encerrar en un borde. Las coordenadas de la región dada se especifican en unidades lógicas.

*Pbrush*<br/>
Apunta al `CBrush` objeto que identifica el pincel que se va a utilizar para dibujar el borde.

*nAncho*<br/>
Especifica el ancho del borde en trazos de pincel verticales en unidades de dispositivo.

*nAltura*<br/>
Especifica la altura del borde en trazos de pincel horizontales en unidades de dispositivo.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn).

## <a name="cdcfromhandle"></a><a name="fromhandle"></a>CDC::FromHandle

Devuelve un puntero `CDC` a un objeto cuando se le da un identificador a un contexto de dispositivo.

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>Parámetros

*Hdc*<br/>
Contiene un identificador para un contexto de dispositivo Windows.

### <a name="return-value"></a>Valor devuelto

El puntero puede ser temporal y no debe almacenarse más allá del uso inmediato.

### <a name="remarks"></a>Observaciones

Si no hay un objeto `CDC` asociado al identificador, se crea y asocia un objeto `CDC` temporal.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcgetarcdirection"></a><a name="getarcdirection"></a>CDC::GetArcDirection

Devuelve la dirección de arco actual para el contexto del dispositivo.

```
int GetArcDirection() const;
```

### <a name="return-value"></a>Valor devuelto

Especifica la dirección del arco actual, si se realiza correctamente. A continuación se muestran los valores devueltos válidos:

- AD_COUNTERCLOCKWISE Arcos y rectángulos dibujados en sentido contrario a las agujas del reloj.

- AD_CLOCKWISE Arcos y rectángulos dibujados en el sentido de las agujas del reloj.

Si se produce un error, el valor devuelto es cero.

### <a name="remarks"></a>Observaciones

Las funciones de arco y rectángulo utilizan la dirección del arco.

## <a name="cdcgetaspectratiofilter"></a><a name="getaspectratiofilter"></a>CDC::GetAspectRatioFilter

Recupera la configuración del filtro de relación de aspecto actual.

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>Valor devuelto

Objeto `CSize` que representa la relación de aspecto utilizada por el filtro de relación de aspecto actual.

### <a name="remarks"></a>Observaciones

La relación de aspecto es la relación formada por el ancho y la altura de píxeles de un dispositivo. La información sobre la relación de aspecto de un dispositivo se utiliza en la creación, selección y visualización de fuentes. Windows proporciona un filtro especial, el filtro de relación de aspecto, para seleccionar fuentes diseñadas para una relación de aspecto determinada de todas las fuentes disponibles. El filtro utiliza la relación `SetMapperFlags` de aspecto especificada por la función miembro.

## <a name="cdcgetbkcolor"></a><a name="getbkcolor"></a>CDC::GetBkColor

Devuelve el color de fondo actual.

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>Valor devuelto

Un valor de color RGB.

### <a name="remarks"></a>Observaciones

Si el modo de fondo es OPAQUE, el sistema utiliza el color de fondo para rellenar los huecos en líneas con estilo, los huecos entre las líneas sombreadas en los pinceles y el fondo en las celdas de caracteres. El sistema también utiliza el color de fondo al convertir mapas de bits entre contextos de dispositivo sin color y monocromo.

## <a name="cdcgetbkmode"></a><a name="getbkmode"></a>CDC::GetBkMode

Devuelve el modo de fondo.

```
int GetBkMode() const;
```

### <a name="return-value"></a>Valor devuelto

El modo de fondo actual, que puede ser OPAQUE o TRANSPARENT.

### <a name="remarks"></a>Observaciones

El modo de fondo define si el sistema elimina los colores de fondo existentes en la superficie de dibujo antes de dibujar texto, pinceles sombreados o cualquier estilo de plumilla que no sea una línea sólida.

## <a name="cdcgetboundsrect"></a><a name="getboundsrect"></a>CDC::GetBoundsRect

Devuelve el rectángulo delimitador acumulado actual para el contexto de dispositivo especificado.

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parámetros

*lpRectBounds*<br/>
Apunta a un búfer que recibirá el rectángulo delimitador actual. El rectángulo se devuelve en coordenadas lógicas.

*Banderas*<br/>
Especifica si el rectángulo delimitador se va a borrar después de que se devuelve. Este parámetro debe ser cero o establecerse en el siguiente valor:

- DCB_RESET Fuerza el rectángulo delimitador que se borrará después de devolverlo.

### <a name="return-value"></a>Valor devuelto

Especifica el estado actual del rectángulo delimitador si la función se realiza correctamente. Puede ser una combinación de los siguientes valores:

- DCB_ACCUMULATE se está produciendo la acumulación de rectángulo delimitador.

- DCB_RESET rectángulo delimitador está vacío.

- DCB_SET Rectángulo delimitador no está vacío.

- DCB_ENABLE Acumulación de límites está activada.

- DCB_DISABLE La acumulación de límites está desactivada.

## <a name="cdcgetbrushorg"></a><a name="getbrushorg"></a>CDC::GetBrushOrg

Recupera el origen (en unidades de dispositivo) del pincel seleccionado actualmente para el contexto del dispositivo.

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>Valor devuelto

El origen actual del pincel (en unidades de dispositivo) como un objeto [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

### <a name="remarks"></a>Observaciones

El origen inicial del pincel está en (0,0) del área de cliente. El valor devuelto especifica este punto en unidades de dispositivo en relación con el origen de la ventana de escritorio.

## <a name="cdcgetcharacterplacement"></a><a name="getcharacterplacement"></a>CDC::GetCharacterPlacement

Recupera varios tipos de información en una cadena de caracteres.

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>Parámetros

*lpString*<br/>
Puntero a la cadena de caracteres que se va a procesar.

*nCount*<br/>
Especifica la longitud de la cadena. Para la versión ANSI, es un recuento BYTE y para la función Unicode es un recuento WORD. Para obtener más información, vea [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw).

*nMaxExtent*<br/>
Especifica la extensión máxima (en unidades lógicas) a la que se procesa la cadena. Los caracteres que, si se procesan, superarían esta extensión se omiten. Los cálculos para cualquier ordenación o matriz de glifos requeridos solo se aplican a los caracteres incluidos. Este parámetro solo se utiliza si el valor GCP_MAXEXTENT se especifica en el parámetro *dwFlags.* A medida que la función procesa la cadena de entrada, cada carácter y su extensión se agregan a la salida, extensión y otras matrices solo si la extensión total aún no ha superado el máximo. Una vez alcanzado el límite, el procesamiento se detendrá.

*lpResults*<br/>
Puntero a una estructura [GCP_Results](/windows/win32/api/wingdi/ns-wingdi-gcp_resultsw) que recibe los resultados de la función.

*dwFlags*<br/>
Especifica cómo procesar la cadena en las matrices necesarias. Este parámetro puede ser uno o varios de los valores enumerados en la sección *dwFlags* del tema [GetCharacterPlacement.](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)

*Str*<br/>
Un puntero a un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto para procesar.

### <a name="return-value"></a>Valor devuelto

Si la función se realiza correctamente, el valor devuelto es el ancho y alto de la cadena en unidades lógicas.

Si la función no se realiza correctamente, el valor devuelto es cero.

### <a name="remarks"></a>Observaciones

Esta función miembro emula la funcionalidad de la función [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw), como se describe en el Windows SDK.

## <a name="cdcgetcharabcwidths"></a><a name="getcharabcwidths"></a>CDC::GetCharABCWidths

Recupera los anchos de caracteres consecutivos en un intervalo especificado de la fuente TrueType actual.

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>Parámetros

*nFirstChar*<br/>
Especifica el primer carácter del intervalo de caracteres de la fuente actual para el que se devuelven los anchos de caracteres.

*nLastChar*<br/>
Especifica el último carácter del intervalo de caracteres de la fuente actual para el que se devuelven los anchos de caracteres.

*lpabc*<br/>
Apunta a una matriz de estructuras [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) que reciben los anchos de caracteres cuando se devuelve la función. Esta matriz debe contener `ABC` al menos tantas estructuras como caracteres en el intervalo especificado por los parámetros *nFirstChar* y *nLastChar.*

*lpABCF*<br/>
Apunta a un búfer proporcionado por la aplicación con una matriz de estructuras [ABCFLOAT](/windows/win32/api/wingdi/ns-wingdi-abcfloat) para recibir los anchos de caracteres cuando se devuelve la función. Los anchos devueltos por esta función están en el formato de punto flotante IEEE.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Los anchos se devuelven en unidades lógicas. Esta función solo se realiza correctamente con fuentes TrueType.

El rasterizador TrueType proporciona espaciado de caracteres "ABC" después de seleccionar un tamaño de punto específico. Espaciado "A" es la distancia que se agrega a la posición actual antes de colocar el glifo. El espaciado "B" es el ancho de la parte negra del glifo. El espaciado "C" se agrega a la posición actual para tener en cuenta el espacio en blanco a la derecha del glifo. El ancho avanzado total es dado por A + B + C.

Cuando `GetCharABCWidths` la función miembro recupera los anchos negativos "A" o "C" para un carácter, ese carácter incluye voladizos o voladizos.

Para convertir los anchos ABC en unidades de diseño de fuente, `lfHeight` una aplicación debe crear una fuente cuyo alto `ntmSizeEM` (como se especifica en el miembro de la estructura [LOGFONT)](/windows/win32/api/wingdi/ns-wingdi-logfontw) es igual al valor almacenado en el miembro de la estructura [NEWTEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-newtextmetricw) (El valor `ntmSizeEM` del miembro se puede recuperar mediante una llamada a la [EnumFontFamilies](/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw) Windows función.)

Los anchos ABC del carácter predeterminado se utilizan para caracteres que están fuera del intervalo de la fuente seleccionada actualmente.

Para recuperar el ancho de los caracteres en fuentes que no son TrueType, las aplicaciones deben usar la función [GetCharWidth](/windows/win32/api/wingdi/nf-wingdi-getcharwidthw) de Windows.

## <a name="cdcgetcharabcwidthsi"></a><a name="getcharabcwidthsi"></a>CDC::GetCharABCWidthsI

Recupera los anchos, en unidades lógicas, de índices de glifo consecutivos en un intervalo especificado de la fuente TrueType actual.

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>Parámetros

*giFirst*<br/>
Especifica el primer índice de glifo en el grupo de índices de pictogramas consecutivos de la fuente actual. Este parámetro solo se utiliza si el parámetro *pgi* es NULL.

*Cgi*<br/>
Especifica el número de índices de glifo.

*Pgi*<br/>
Puntero a una matriz que contiene índices de glifos. Si el valor es NULL, se utiliza el parámetro *giFirst* en su lugar. El parámetro *cgi* especifica el número de índices de glifo en esta matriz.

*lpabc*<br/>
Puntero a una matriz de estructuras [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) que reciben los anchos de caracteres. Esta matriz debe contener `ABC` al menos tantas estructuras como índices de glifo especificados por el parámetro *cgi.*

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función miembro emula la funcionalidad de la función [GetCharABCWidthsI](/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsi), como se describe en el Windows SDK.

## <a name="cdcgetcharwidth"></a><a name="getcharwidth"></a>CDC::GetCharWidth

Recupera los anchos de caracteres individuales en un grupo `m_hAttribDC`consecutivo de caracteres de la fuente actual, utilizando , el contexto del dispositivo de entrada.

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>Parámetros

*nFirstChar*<br/>
Especifica el primer carácter de un grupo consecutivo de caracteres de la fuente actual.

*nLastChar*<br/>
Especifica el último carácter de un grupo consecutivo de caracteres de la fuente actual.

*lpBuffer*<br/>
Apunta a un búfer que recibirá los valores de ancho de un grupo consecutivo de caracteres en la fuente actual.

*lpFloatBuffer*<br/>
Apunta a un búfer para recibir los anchos de caracteres. Los anchos devueltos están en el formato de punto flotante IEEE de 32 bits. (Las anchuras se miden a lo largo de la línea base de los caracteres.)

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Por ejemplo, si *nFirstChar* identifica la letra 'a' y *nLastChar* identifica la letra 'z', la función recupera el ancho de todos los caracteres en minúsculas.

La función almacena los valores en el búfer al que apunta *lpBuffer*. Este búfer debe ser lo suficientemente grande como para contener todos los anchos. Es decir, debe haber al menos 26 entradas en el ejemplo dado.

Si un carácter del grupo consecutivo de caracteres no existe en una fuente determinada, se le asignará el valor de ancho del carácter predeterminado.

## <a name="cdcgetcharwidthi"></a><a name="getcharwidthi"></a>CDC::GetCharWidthI

Recupera los anchos, en coordenadas lógicas, de índices de glifo consecutivos en un rango especificado de la fuente actual.

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parámetros

*giFirst*<br/>
Especifica el primer índice de glifo en el grupo de índices de pictogramas consecutivos de la fuente actual. Este parámetro solo se utiliza si el parámetro *pgi* es NULL.

*Cgi*<br/>
Especifica el número de índices de glifo.

*Pgi*<br/>
Puntero a una matriz que contiene índices de glifos. Si el valor es NULL, se utiliza el parámetro *giFirst* en su lugar. El parámetro *cgi* especifica el número de índices de glifo en esta matriz.

*lpBuffer*<br/>
Puntero a un búfer que recibe los anchos.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función miembro emula la funcionalidad de la función [GetCharWidthI](/windows/win32/api/wingdi/nf-wingdi-getcharwidthi), como se describe en el Windows SDK.

## <a name="cdcgetclipbox"></a><a name="getclipbox"></a>CDC::GetClipBox

Recupera las dimensiones del rectángulo delimitador más estrecho alrededor del contorno delimitador actual.

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Apunta a la estructura [RECT](/windows/win32/api/windef/ns-windef-rect) o al objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que va a recibir las dimensiones del rectángulo.

### <a name="return-value"></a>Valor devuelto

Tipo de región de recorte. Puede ser cualquiera de los siguientes valores:

- LA región de recorte COMPLEXREGION tiene bordes superpuestos.

- ERROR El contexto del dispositivo no es válido.

- La región de recorte NULLREGION está vacía.

- La región de recorte SIMPLEREGION no tiene bordes superpuestos.

### <a name="remarks"></a>Observaciones

Las cotas se copian en el búfer al que apunta *lpRect*.

## <a name="cdcgetcoloradjustment"></a><a name="getcoloradjustment"></a>CDC::GetColorAdjustment

Recupera los valores de ajuste de color para el contexto del dispositivo.

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>Parámetros

*lpColorAdjust*<br/>
Apunta a una estructura de datos [COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) para recibir los valores de ajuste de color.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

## <a name="cdcgetcurrentbitmap"></a><a name="getcurrentbitmap"></a>CDC::GetCurrentBitmap

Devuelve un puntero al `CBitmap` objeto seleccionado actualmente.

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>Valor devuelto

Puntero a `CBitmap` un objeto, si se realiza correctamente; NULL.

### <a name="remarks"></a>Observaciones

Esta función miembro puede devolver objetos temporales.

## <a name="cdcgetcurrentbrush"></a><a name="getcurrentbrush"></a>CDC::GetCurrentBrush

Devuelve un puntero al `CBrush` objeto seleccionado actualmente.

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>Valor devuelto

Puntero a `CBrush` un objeto, si se realiza correctamente; NULL.

### <a name="remarks"></a>Observaciones

Esta función miembro puede devolver objetos temporales.

## <a name="cdcgetcurrentfont"></a><a name="getcurrentfont"></a>CDC::GetCurrentFont

Devuelve un puntero al `CFont` objeto seleccionado actualmente.

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>Valor devuelto

Puntero a `CFont` un objeto, si se realiza correctamente; NULL.

### <a name="remarks"></a>Observaciones

Esta función miembro puede devolver objetos temporales.

## <a name="cdcgetcurrentpalette"></a><a name="getcurrentpalette"></a>CDC::GetCurrentPalette

Devuelve un puntero al `CPalette` objeto seleccionado actualmente.

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>Valor devuelto

Puntero a `CPalette` un objeto, si se realiza correctamente; NULL.

### <a name="remarks"></a>Observaciones

Esta función miembro puede devolver objetos temporales.

## <a name="cdcgetcurrentpen"></a><a name="getcurrentpen"></a>CDC::GetCurrentPen

Devuelve un puntero al `CPen` objeto seleccionado actualmente.

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>Valor devuelto

Puntero a `CPen` un objeto, si se realiza correctamente; NULL.

### <a name="remarks"></a>Observaciones

Esta función miembro puede devolver objetos temporales.

## <a name="cdcgetcurrentposition"></a><a name="getcurrentposition"></a>CDC::GetCurrentPosition

Recupera la posición actual (en coordenadas lógicas).

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>Valor devuelto

La posición actual `CPoint` como un objeto.

### <a name="remarks"></a>Observaciones

La posición actual se `MoveTo` puede establecer con la función miembro.

## <a name="cdcgetdcbrushcolor"></a><a name="getdcbrushcolor"></a>CDC::GetDCBrushColor

Recupera el color de pincel actual.

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>Valor devuelto

Si la función se realiza correctamente, el valor devuelto es el valor [COLORREF](/windows/win32/gdi/colorref) para el color de pincel actual.

Si la función no se realiza correctamente, el valor devuelto es CLR_INVALID.

### <a name="remarks"></a>Observaciones

Esta función miembro emula la funcionalidad de la función [GetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-getdcbrushcolor), como se describe en el Windows SDK.

## <a name="cdcgetdcpencolor"></a><a name="getdcpencolor"></a>CDC::GetDCPenColor

Recupera el color del lápiz actual.

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>Valor devuelto

Si la función se realiza correctamente, el valor devuelto es el valor [COLORREF](/windows/win32/gdi/colorref) para el color de lápiz actual.

Si la función no se realiza correctamente, el valor devuelto es CLR_INVALID.

### <a name="remarks"></a>Observaciones

Esta función miembro utiliza la función [GetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-getdcpencolor)de Win32 , como se describe en el Windows SDK.

## <a name="cdcgetdevicecaps"></a><a name="getdevicecaps"></a>CDC::GetDeviceCaps

Recupera una amplia gama de información específica del dispositivo sobre el dispositivo de visualización.

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>Parámetros

*nIndex*<br/>
Especifica el tipo de información que se va a devolver. Consulte [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) en el Windows SDK para obtener una lista de valores.

### <a name="return-value"></a>Valor devuelto

El valor de la capacidad solicitada si la función se realiza correctamente.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).

## <a name="cdcgetfontdata"></a><a name="getfontdata"></a>CDC::GetFontData

Recupera información de métricades de fuentes de un archivo de fuente escalable.

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>Parámetros

*dwTable*<br/>
Especifica el nombre de la tabla de métricas que se va a devolver. Este parámetro puede ser una de las tablas de métricas documentadas en la especificación TrueType Font Files publicada por Microsoft Corporation. Si este parámetro es 0, la información se recupera a partir del principio del archivo de fuente.

*dwOffset*<br/>
Especifica el desplazamiento desde el principio de la tabla en la que se va a empezar a recuperar información. Si este parámetro es 0, la información se recupera a partir del principio de la tabla especificada por el *dwTable* parámetro. Si este valor es mayor o igual que `GetFontData` el tamaño de la tabla, devuelve 0.

*lpData*<br/>
Apunta a un búfer que recibirá la información de fuente. Si este valor es NULL, la función devuelve el tamaño del búfer necesario para los datos de fuente especificados en el parámetro *dwTable.*

*cbData*<br/>
Especifica la longitud, en bytes, de la información que se va a recuperar. Si este parámetro `GetFontData` es 0, devuelve el tamaño de los datos especificados en el *dwTable* parámetro.

### <a name="return-value"></a>Valor devuelto

Especifica el número de bytes devueltos en el búfer al que apunta *lpData* si la función se realiza correctamente; de lo contrario -1.

### <a name="remarks"></a>Observaciones

La información que se va a recuperar se identifica especificando un desplazamiento en el archivo de fuente y la longitud de la información que se va a devolver.

Una aplicación a `GetFontData` veces puede usar la función miembro para guardar una fuente TrueType con un documento. Para ello, la aplicación determina si la fuente se puede incrustar y, a continuación, recupera todo el archivo de fuente, especificando 0 para los parámetros *dwTable*, *dwOffset*y *cbData.*

Las aplicaciones pueden determinar si se puede `otmfsType` incrustar una fuente comprobando el miembro de la estructura [OUTLINETEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) Si se `otmfsType` establece el bit 1 de, no se permite incrustar para la fuente. Si el bit 1 está claro, la fuente se puede incrustar. Si se establece el bit 2, la incrustación es de solo lectura.

Si una aplicación intenta utilizar esta función para recuperar información `GetFontData` para una fuente que no es TrueType, la función miembro devuelve -1.

## <a name="cdcgetfontlanguageinfo"></a><a name="getfontlanguageinfo"></a>CDC::GetFontLanguageInfo

Devuelve información sobre la fuente seleccionada actualmente para el contexto de visualización especificado.

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>Valor devuelto

El valor devuelto identifica las características de la fuente seleccionada actualmente. Para obtener una lista completa de los valores posibles, vea [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo).

### <a name="remarks"></a>Observaciones

Esta función miembro emula la funcionalidad de la función [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo), como se describe en el Windows SDK.

## <a name="cdcgetglyphoutline"></a><a name="getglyphoutline"></a>CDC::GetGlyphOutline

Recupera la curva de contorno o mapa de bits para un carácter de contorno en la fuente actual.

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>Parámetros

*Nchar*<br/>
Especifica el carácter para el que se va a devolver la información.

*nFormato*<br/>
Especifica el formato en el que la función debe devolver información. Puede ser uno de los siguientes valores, o 0:

|Value|Significado|
|-----------|-------------|
|GGO_BITMAP|Devuelve el mapa de bits del glifo. Cuando se devuelve la función, el búfer al que apunta *lpBuffer* contiene un mapa de bits de 1 bit por píxel cuyas filas comienzan en límites de doble palabra.|
|GGO_NATIVE|Devuelve los puntos de datos de curva en el formato nativo del rasterizador, utilizando unidades de dispositivo. Cuando se especifica este valor, se omite cualquier transformación especificada en *lpmat2.*|

Cuando el valor de *nFormat* es 0, la función rellena una estructura [GLYPHMETRICS](/windows/win32/api/wingdi/ns-wingdi-glyphmetrics) pero no devuelve datos de esquema de glifo.

*lpgm*<br/>
Apunta a una estructura GLYPHMETRICS que describe la colocación del glifo en la celda de caracteres.

*cbBuffer*<br/>
Especifica el tamaño del búfer en el que la función copia información sobre el carácter de esquema. Si este valor es 0 y el *nFormat* parámetro es el GGO_BITMAP o GGO_NATIVE valores, la función devuelve el tamaño requerido del búfer.

*lpBuffer*<br/>
Apunta a un búfer en el que la función copia información sobre el carácter de esquema. Si *nFormat* especifica el valor GGO_NATIVE, la información se copia en forma de estructuras TTPOLYGONHEADER y TTPOLYCURVE. Si este valor es NULL y *nFormat* es el valor GGO_BITMAP o GGO_NATIVE, la función devuelve el tamaño necesario del búfer.

*lpmat2*<br/>
Apunta a una estructura [MAT2](/windows/win32/api/wingdi/ns-wingdi-mat2) que contiene una matriz de transformación para el carácter. Este parámetro no puede ser NULL, incluso cuando se especifica el valor de GGO_NATIVE para *nFormat*.

### <a name="return-value"></a>Valor devuelto

El tamaño, en bytes, del búfer necesario para la información recuperada si *cbBuffer* es 0 o *lpBuffer* es NULL. De lo contrario, es un valor positivo si la función es correcta, o -1 si hay un error.

### <a name="remarks"></a>Observaciones

Una aplicación puede rotar caracteres recuperados en formato de mapa de bits especificando una matriz de transformación 2 por 2 en la estructura a la que apunta *lpmat2*.

Un contorno de glifo se devuelve como una serie de contornos. Cada contorno se define mediante una estructura [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) seguida de tantas `TTPOLYCURVE` estructuras como sean necesarias para describirlo. Todos los puntos se devuelven como estructuras [POINTFX](/windows/win32/api/wingdi/ns-wingdi-pointfx) y representan posiciones absolutas, no movimientos relativos. El punto de `pfxStart` partida dado por el miembro de la estructura [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) es el punto en el que comienza el contorno de un contorno. Las estructuras [TTPOLYCURVE](/windows/win32/api/wingdi/ns-wingdi-ttpolycurve) siguientes pueden ser registros de polilínea o registros de spline. Los registros de polilínea son una serie de puntos; las líneas dibujadas entre los puntos describen el contorno del carácter. Los registros de spline representan las curvas cuadráticas utilizadas por TrueType (es decir, b-splines cuadráticas).

## <a name="cdcgetgraphicsmode"></a><a name="getgraphicsmode"></a>CDC::GetGraphicsMode

Recupera el modo de gráficos actual para el contexto de dispositivo especificado.

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>Valor devuelto

Devuelve el modo de gráficos actual en caso de éxito. Para obtener una lista de los valores que puede devolver este método, vea [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

Devuelve 0 en caso de error.

Para obtener información de error extendida, llame a [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Observaciones

Este método ajusta la función [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode)de Windows GDI .

## <a name="cdcgethalftonebrush"></a><a name="gethalftonebrush"></a>CDC::GetHalftoneBrush

Llame a esta función miembro para recuperar un pincel de medios tonos.

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>Valor devuelto

Un puntero `CBrush` a un objeto si se realiza correctamente; NULL.

### <a name="remarks"></a>Observaciones

Un pincel de medios tonos muestra píxeles que son alternativamente colores de primer plano y de fondo para crear un patrón tramado. A continuación se muestra un ejemplo de un patrón tramado creado por un pincel de medios tonos.

![Detalle de un trazo del lápiz interpolado](../../mfc/reference/media/vc318s1.gif "Detalle de un trazo del lápiz interpolado")

## <a name="cdcgetkerningpairs"></a><a name="getkerningpairs"></a>CDC::GetKerningPairs

Recupera los pares de kerning de caracteres para la fuente que está seleccionada actualmente en el contexto de dispositivo especificado.

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>Parámetros

*nPairs*<br/>
Especifica el número de estructuras [KERNINGPAIR](/windows/win32/api/wingdi/ns-wingdi-kerningpair) a las que apunta *lpkrnpair*. La función no copiará más pares de kerning que los especificados por *nPairs*.

*lpkrnpair*<br/>
Apunta a una `KERNINGPAIR` matriz de estructuras que reciben los pares de kerning cuando se devuelve la función. Esta matriz debe contener al menos tantas estructuras como se especifica en *nPairs*. Si este parámetro es NULL, la función devuelve el número total de pares de kerning para la fuente.

### <a name="return-value"></a>Valor devuelto

Especifica el número de pares de kerning recuperados o el número total de pares de kerning en la fuente, si la función se realiza correctamente. Se devuelve cero si se produce un error en la función o no hay pares de kerning para la fuente.

## <a name="cdcgetlayout"></a><a name="getlayout"></a>CDC::GetLayout

Llame a esta función miembro para determinar el diseño del texto y los gráficos para un contexto de dispositivo, como una impresora o un metarchivo.

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>Valor devuelto

Si se realiza correctamente, los indicadores de diseño para el contexto de dispositivo actual. De lo contrario, GDI_ERROR. Para obtener información de error extendida, llame a [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror). Para obtener una lista de los indicadores de diseño, vea [CDC::SetLayout](#setlayout).

### <a name="remarks"></a>Observaciones

El diseño predeterminado es de izquierda a derecha.

## <a name="cdcgetmapmode"></a><a name="getmapmode"></a>CDC::GetMapMode

Recupera el modo de asignación actual.

```
int GetMapMode() const;
```

### <a name="return-value"></a>Valor devuelto

El modo de asignación.

### <a name="remarks"></a>Observaciones

Para obtener una descripción de `SetMapMode` los modos de asignación, consulte la función miembro.

> [!NOTE]
> Si llama a [SetLayout](#setlayout) para cambiar el controlador `SetLayout` de dominio a diseño de derecha a izquierda, cambia automáticamente el modo de asignación a MM_ISOTROPIC. Por lo tanto, `GetMapMode` cualquier llamada posterior a la devolución MM_ISOTROPIC.

## <a name="cdcgetmiterlimit"></a><a name="getmiterlimit"></a>CDC::GetMiterLimit

Devuelve el límite de inglete para el contexto del dispositivo.

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El límite de inglete se utiliza al dibujar líneas geométricas que tienen uniones de inglete.

## <a name="cdcgetnearestcolor"></a><a name="getnearestcolor"></a>CDC::GetNearestColor

Devuelve el color sólido que mejor coincide con un color lógico especificado.

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>Parámetros

*crColor*<br/>
Especifica el color que se va a coincidir.

### <a name="return-value"></a>Valor devuelto

Un valor de color RGB (rojo, verde, azul) que define el color sólido más cercano al valor *crColor* que el dispositivo puede representar.

### <a name="remarks"></a>Observaciones

El dispositivo dado debe ser capaz de representar este color.

## <a name="cdcgetoutlinetextmetrics"></a><a name="getoutlinetextmetrics"></a>CDC::GetOutlineTextMetrics

Recupera información de métricas para fuentes TrueType.

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>Parámetros

*lpotm*<br/>
Apunta a una matriz de estructuras [OUTLINETEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) Si este parámetro es NULL, la función devuelve el tamaño del búfer necesario para los datos de métrica recuperados.

*cbData*<br/>
Especifica el tamaño, en bytes, del búfer al que se devuelve la información.

*lpotm*<br/>
Apunta a `OUTLINETEXTMETRIC` una estructura. Si este parámetro es NULL, la función devuelve el tamaño del búfer necesario para la información de métrica recuperada.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La estructura [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) contiene la mayor parte de la información de métricades de fuente proporcionada con el formato TrueType, incluida una estructura [TEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-textmetricw) Los últimos cuatro `OUTLINETEXTMETRIC` miembros de la estructura son punteros a cadenas. Las aplicaciones deben asignar espacio para estas cadenas además del espacio necesario para los demás miembros. Dado que no hay ningún límite impuesto por el sistema para el tamaño de las cadenas, el método más sencillo para `GetOutlineTextMetrics` asignar memoria es recuperar el tamaño necesario especificando NULL para *lpotm* en la primera llamada a la función.

## <a name="cdcgetoutputcharwidth"></a><a name="getoutputcharwidth"></a>CDC::GetOutputCharWidth

Utiliza el contexto `m_hDC`del dispositivo de salida , y recupera los anchos de caracteres individuales en un grupo consecutivo de caracteres de la fuente actual.

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parámetros

*nFirstChar*<br/>
Especifica el primer carácter de un grupo consecutivo de caracteres de la fuente actual.

*nLastChar*<br/>
Especifica el último carácter de un grupo consecutivo de caracteres de la fuente actual.

*lpBuffer*<br/>
Apunta a un búfer que recibirá los valores de ancho de un grupo consecutivo de caracteres en la fuente actual.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Por ejemplo, si *nFirstChar* identifica la letra 'a' y *nLastChar* identifica la letra 'z', la función recupera el ancho de todos los caracteres en minúsculas.

La función almacena los valores en el búfer al que apunta *lpBuffer*. Este búfer debe ser lo suficientemente grande como para contener todos los anchos; es decir, debe haber al menos 26 entradas en el ejemplo dado.

Si un carácter del grupo consecutivo de caracteres no existe en una fuente determinada, se le asignará el valor de ancho del carácter predeterminado.

## <a name="cdcgetoutputtabbedtextextent"></a><a name="getoutputtabbedtextextent"></a>CDC::GetOutputTabbedTextExtent

Llame a esta función miembro para calcular el ancho y alto de una cadena de caracteres mediante [m_hDC](#m_hdc), el contexto del dispositivo de salida.

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parámetros

*lpszString*<br/>
Apunta a una cadena de caracteres que se va a medir. También puede pasar un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto para este parámetro.

*nCount*<br/>
Especifica la [longitud de la cadena](/windows/win32/gdi/specifying-length-of-text-output-string) señalada por *lpszString*.

*nTabPositions*<br/>
Especifica el número de posiciones de tabulación en la matriz a la que apunta *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Apunta a una matriz de enteros que contiene las posiciones de tabulación en unidades lógicas. Las tabulaciones deben ordenarse en orden creciente; el valor x más pequeño debe ser el primer elemento de la matriz. No se permiten pestañas atrás.

*Str*<br/>
Objeto `CString` que contiene los caracteres especificados que se van a medir.

### <a name="return-value"></a>Valor devuelto

Las dimensiones de la cadena (en unidades lógicas) en un [CSize](../../atl-mfc-shared/reference/csize-class.md) objeto.

### <a name="remarks"></a>Observaciones

Si la cadena contiene uno o más caracteres de tabulación, el ancho de la cadena se basa en las tabulaciones especificadas por *lpnTabStopPositions*. La función utiliza la fuente seleccionada actualmente para calcular las dimensiones de la cadena.

La región de recorte actual no desfasa el ancho y alto devueltos por la `GetOutputTabbedTextExtent` función.

Dado que algunos dispositivos no colocan caracteres en matrices de celdas normales (es decir, kern los caracteres), la suma de las extensiones de los caracteres de una cadena puede no ser igual a la extensión de la cadena.

Si *nTabPositions* es 0 y *lpnTabStopPositions* es NULL, las fichas se expanden a ocho anchos de caracteres promedio. Si *nTabPositions* es 1, las tabulaciones se separarán por la distancia especificada por el primer valor de la matriz a la que *apunta lpnTabStopPositions.* Si *lpnTabStopPositions* apunta a más de un valor único, se establece una tabulación para cada valor de la matriz, hasta el número especificado por *nTabPositions*.

## <a name="cdcgetoutputtextextent"></a><a name="getoutputtextextent"></a>CDC::GetOutputTextExtent

Llame a esta función miembro para usar el contexto del dispositivo de salida, [m_hDC](#m_hdc), y calcular el ancho y alto de una línea de texto, utilizando la fuente actual.

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parámetros

*lpszString*<br/>
Apunta a una cadena de caracteres. También puede pasar un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto para este parámetro.

*nCount*<br/>
Especifica la [longitud de la cadena](/windows/win32/gdi/specifying-length-of-text-output-string) señalada por *lpszString*.

*Str*<br/>
Objeto `CString` que contiene los caracteres especificados que se van a medir.

### <a name="return-value"></a>Valor devuelto

Las dimensiones de la cadena (en unidades lógicas) devueltas en un [CSize](../../atl-mfc-shared/reference/csize-class.md) objeto.

### <a name="remarks"></a>Observaciones

La región de recorte actual no afecta `GetOutputTextExtent`a la anchura y la altura devueltas por .

Puesto que algunos dispositivos no colocan caracteres en matrices de celdas normales (es decir, llevan a cabo el kerning), la suma de las extensiones de los caracteres de una cadena puede no ser igual a la extensión de la cadena.

## <a name="cdcgetoutputtextmetrics"></a><a name="getoutputtextmetrics"></a>CDC::GetOutputTextMetrics

Recupera las métricas de la `m_hDC`fuente actual mediante , el contexto del dispositivo de salida.

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parámetros

*lpMetrics*<br/>
Apunta a la estructura [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) que recibe las métricas.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

## <a name="cdcgetpath"></a><a name="getpath"></a>CDC::GetPath

Recupera las coordenadas que definen los puntos finales de las líneas y los puntos de control de las curvas que se encuentran en la ruta seleccionada en el contexto del dispositivo.

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una [POINT](/windows/win32/api/windef/ns-windef-point) matriz de `CPoint` estructuras de datos POINT u objetos donde se colocan los puntos finales de línea y los puntos de control de curva.

*lpTypes*<br/>
Apunta a una matriz de bytes donde se colocan los tipos de vértice. Los valores son uno de los siguientes:

- PT_MOVETO Especifica que el punto correspondiente en *lpPoints* inicia una figura desarticulada.

- PT_LINETO Especifica que el punto anterior y el punto correspondiente en *lpPoints* son los puntos finales de una línea.

- PT_BEZIERTO Especifica que el punto correspondiente en *lpPoints* es un punto de control o punto final para una curva de Bézier.

PT_BEZIERTO tipos siempre se producen en conjuntos de tres. El punto del trazado inmediatamente anterior define el punto inicial de la curva de Bézier. Los dos primeros puntos PT_BEZIERTO son los puntos de control, y el tercer punto de PT_BEZIERTO es el punto final (si está codificado de forma rígida).

   Un PT_LINETO o PT_BEZIERTO tipo puede combinarse con el siguiente indicador (mediante el operador bit a bit **OR**) para indicar que el punto correspondiente es el último punto de una figura y que la figura debe cerrarse:

- PT_CLOSEFIGURE Especifica que la figura se cierra automáticamente después de dibujar la línea o curva correspondiente. La figura se cierra dibujando una línea desde el punto final de línea o curva hasta el punto correspondiente al último PT_MOVETO.

*nCount*<br/>
Especifica el número total de estructuras de datos [POINT](/windows/win32/api/windef/ns-windef-point) que se pueden colocar en la matriz *lpPoints.* Este valor debe ser el mismo que el número de bytes que se pueden colocar en la matriz *lpTypes.*

### <a name="return-value"></a>Valor devuelto

Si el *nCount* parámetro es distinto de cero, el número de puntos enumerados. Si *nCount* es 0, el número total `GetPath` de puntos de la ruta de acceso (y no escribe nada en los búferes). Si *nCount* es distinto de cero y es menor que el número de puntos de la ruta de acceso, el valor devuelto es -1.

### <a name="remarks"></a>Observaciones

El contexto del dispositivo debe contener una ruta de acceso cerrada. Los puntos de la ruta de acceso se devuelven en coordenadas lógicas. Los puntos se almacenan en la `GetPath` ruta en coordenadas de dispositivo, por lo que cambia los puntos de las coordenadas del dispositivo a las coordenadas lógicas mediante la inversa de la transformación actual. La `FlattenPath` función miembro `GetPath`se puede llamar antes , para convertir todas las curvas del trazado en segmentos de línea.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC::BeginPath](#beginpath).

## <a name="cdcgetpixel"></a><a name="getpixel"></a>CDC::GetPixel

Recupera el valor de color RGB del píxel en el punto especificado por *x* e *y*.

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x lógica del punto que se va a examinar.

*y y*<br/>
Especifica la coordenada y lógica del punto que se va a examinar.

*Punto*<br/>
Especifica las coordenadas x e y lógicas del punto que se va a examinar.

### <a name="return-value"></a>Valor devuelto

Para cualquier versión de la función, un valor de color RGB para el color del punto dado. Es -1 si las coordenadas no especifican un punto en la región de recorte.

### <a name="remarks"></a>Observaciones

El punto debe estar en la región de recorte. Si el punto no está en la región de recorte, la función no tiene ningún efecto y devuelve -1.

No todos los dispositivos admiten la función `GetPixel`. Para obtener más información, vea la capacidad de ráster de RC_BITBLT en el [GetDeviceCaps](#getdevicecaps) función miembro.

La `GetPixel` función miembro tiene dos formas. La primera toma dos valores de coordenadas; el segundo toma una estructura [POINT](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

## <a name="cdcgetpolyfillmode"></a><a name="getpolyfillmode"></a>CDC::GetPolyFillMode

Recupera el modo de relleno de polígonos actual.

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>Valor devuelto

El modo de relleno de polígono actual, ALTERNATE o WINDING, si la función se realiza correctamente.

### <a name="remarks"></a>Observaciones

Consulte `SetPolyFillMode` la función miembro para obtener una descripción de los modos de relleno de polígonos.

## <a name="cdcgetrop2"></a><a name="getrop2"></a>CDC::GetROP2

Recupera el modo de dibujo actual.

```
int GetROP2() const;
```

### <a name="return-value"></a>Valor devuelto

El modo de dibujo. Para obtener una lista de los `SetROP2` valores del modo de dibujo, consulte la función miembro.

### <a name="remarks"></a>Observaciones

El modo de dibujo especifica cómo se combinan los colores del lápiz y el interior de los objetos rellenos con el color que ya está en la superficie de visualización.

## <a name="cdcgetsafehdc"></a><a name="getsafehdc"></a>CDC::GetSafeHdc

Llame a esta función miembro para obtener [m_hDC](#m_hdc), el contexto del dispositivo de salida.

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>Valor devuelto

Un identificador de contexto de dispositivo.

### <a name="remarks"></a>Observaciones

Esta función miembro también funciona con punteros nulos.

## <a name="cdcgetstretchbltmode"></a><a name="getstretchbltmode"></a>CDC::GetStretchBltMode

Recupera el modo de estiramiento de mapa de bits actual.

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>Valor devuelto

El valor devuelto especifica el modo de estiramiento de mapa de bits actual (STRETCH_ANDSCANS, STRETCH_DELETESCANS o STRETCH_ORSCANS) si la función se realiza correctamente.

### <a name="remarks"></a>Observaciones

El modo de estiramiento de mapa de bits define cómo se `StretchBlt` quita la información de los mapas de bits que se estiran o comprimen mediante la función miembro.

Los modos STRETCH_ANDSCANS y STRETCH_ORSCANS se utilizan normalmente para conservar los píxeles de primer plano en mapas de bits monocromos. El modo STRETCH_DELETESCANS se utiliza normalmente para conservar el color en los mapas de bits de color.

## <a name="cdcgettabbedtextextent"></a><a name="gettabbedtextextent"></a>CDC::GetTabbedTextExtent

Llame a esta función miembro para calcular el ancho y alto de una cadena de caracteres mediante [m_hAttribDC](#m_hattribdc), el contexto del dispositivo de atributo.

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parámetros

*lpszString*<br/>
Apunta a una cadena de caracteres. También puede pasar un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto para este parámetro.

*nCount*<br/>
Especifica la [longitud de la cadena](/windows/win32/gdi/specifying-length-of-text-output-string) señalada por *lpszString*.

*nTabPositions*<br/>
Especifica el número de posiciones de tabulación en la matriz a la que apunta *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Apunta a una matriz de enteros que contiene las posiciones de tabulación en unidades lógicas. Las tabulaciones deben ordenarse en orden creciente; el valor x más pequeño debe ser el primer elemento de la matriz. No se permiten pestañas atrás.

*Str*<br/>
Objeto `CString` que contiene los caracteres especificados que se van a dibujar.

### <a name="return-value"></a>Valor devuelto

Las dimensiones de la cadena (en unidades lógicas) en un [CSize](../../atl-mfc-shared/reference/csize-class.md) objeto.

### <a name="remarks"></a>Observaciones

Si la cadena contiene uno o más caracteres de tabulación, el ancho de la cadena se basa en las tabulaciones especificadas por *lpnTabStopPositions*. La función utiliza la fuente seleccionada actualmente para calcular las dimensiones de la cadena.

La región de recorte actual no desfasa el ancho y alto devueltos por la `GetTabbedTextExtent` función.

Dado que algunos dispositivos no colocan caracteres en matrices de celdas normales (es decir, kern los caracteres), la suma de las extensiones de los caracteres de una cadena puede no ser igual a la extensión de la cadena.

Si *nTabPositions* es 0 y *lpnTabStopPositions* es NULL, las fichas se expanden a ocho veces el ancho medio de caracteres. Si *nTabPositions* es 1, las tabulaciones se separarán por la distancia especificada por el primer valor de la matriz a la que *apunta lpnTabStopPositions.* Si *lpnTabStopPositions* apunta a más de un valor único, se establece una tabulación para cada valor de la matriz, hasta el número especificado por *nTabPositions*.

## <a name="cdcgettextalign"></a><a name="gettextalign"></a>CDC::GetTextAlign

Recupera el estado de los indicadores de alineación de texto para el contexto del dispositivo.

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>Valor devuelto

El estado de los indicadores de alineación de texto. El valor devuelto es uno o varios de los siguientes valores:

- TA_BASELINE Especifica la alineación del eje X y la línea base de la fuente elegida dentro del rectángulo delimitador.

- TA_BOTTOM Especifica la alineación del eje X y la parte inferior del rectángulo delimitador.

- TA_CENTER Especifica la alineación del eje Y y el centro del rectángulo delimitador.

- TA_LEFT Especifica la alineación del eje Y y el lado izquierdo del rectángulo delimitador.

- TA_NOUPDATECP Especifica que la posición actual no se actualiza.

- TA_RIGHT Especifica la alineación del eje Y y el lado derecho del rectángulo delimitador.

- TA_TOP Especifica la alineación del eje X y la parte superior del rectángulo delimitador.

- TA_UPDATECP Especifica que se actualiza la posición actual.

### <a name="remarks"></a>Observaciones

Los indicadores de alineación de texto determinan cómo las `TextOut` funciones miembro y `ExtTextOut` alinean una cadena de texto en relación con el punto inicial de la cadena. Los indicadores de alineación de texto no son necesariamente indicadores de un solo bit y pueden ser iguales a 0. Para probar si se establece una marca, una aplicación debe seguir estos pasos:

1. Aplique el operador OR bit a bit a la bandera y sus indicadores relacionados, agrupados de la siguiente manera:

   - TA_LEFT, TA_CENTER y TA_RIGHT

   - TA_BASELINE, TA_BOTTOM y TA_TOP

   - TA_NOUPDATECP y TA_UPDATECP

1. Aplique el operador AND bit a bit al `GetTextAlign`resultado y al valor devuelto de .

1. Prueba de la igualdad de este resultado y la bandera.

## <a name="cdcgettextcharacterextra"></a><a name="gettextcharacterextra"></a>CDC::GetTextCharacterExtra

Recupera la configuración actual para la cantidad de espaciado entre caracteres.

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>Valor devuelto

La cantidad del espaciado entre caracteres.

### <a name="remarks"></a>Observaciones

GDI agrega este espaciado a cada carácter, incluidos los caracteres de interrupción, cuando escribe una línea de texto en el contexto del dispositivo.

El valor predeterminado para la cantidad de espaciado entre caracteres es 0.

## <a name="cdcgettextcolor"></a><a name="gettextcolor"></a>CDC::GetTextColor

Recupera el color de texto actual.

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>Valor devuelto

El color del texto actual como un valor de color RGB.

### <a name="remarks"></a>Observaciones

El color del texto es el color de primer plano de los caracteres dibujados mediante las funciones miembro de salida de texto GDI [TextOut](#textout), [ExtTextOut](#exttextout)y [TabbedTextOut](#tabbedtextout).

## <a name="cdcgettextextent"></a><a name="gettextextent"></a>CDC::GetTextExtent

Llame a esta función miembro para calcular el ancho y alto de una línea de texto mediante la fuente actual para determinar las dimensiones.

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parámetros

*lpszString*<br/>
Apunta a una cadena de caracteres. También puede pasar un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto para este parámetro.

*nCount*<br/>
Especifica el número de caracteres de la cadena.

*Str*<br/>
Objeto `CString` que contiene los caracteres especificados.

### <a name="return-value"></a>Valor devuelto

Las dimensiones de la cadena (en unidades lógicas) en un [CSize](../../atl-mfc-shared/reference/csize-class.md) objeto.

### <a name="remarks"></a>Observaciones

La información se recupera de [m_hAttribDC](#m_hattribdc), el contexto del dispositivo de atributo.

De forma `GetTextExtent` predeterminada, se supone que el texto para el que recupera la cota se establece a lo largo de una línea horizontal (es decir, el escape es 0). Si crea una fuente que especifica un escape distinto de cero, debe convertir el ángulo del texto explícitamente para obtener las dimensiones de la cadena.

La región de recorte actual no afecta `GetTextExtent`a la anchura y la altura devueltas por .

Puesto que algunos dispositivos no colocan caracteres en matrices de celdas normales (es decir, llevan a cabo el kerning), la suma de las extensiones de los caracteres de una cadena puede no ser igual a la extensión de la cadena.

## <a name="cdcgettextextentexpointi"></a><a name="gettextextentexpointi"></a>CDC::GetTextExtentExPointi

Recupera el número de caracteres de una cadena especificada que caben dentro de un espacio especificado y rellena una matriz con la extensión de texto para cada uno de esos caracteres.

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*pgiIn*<br/>
Puntero a una matriz de índices de glifo para los que se van a recuperar extensiones.

*Cgi*<br/>
Especifica el número de glifos de la matriz a la que apunta *pgiIn*.

*nMaxExtent*<br/>
Especifica el ancho máximo permitido, en unidades lógicas, de la cadena con formato.

*lpnFit*<br/>
Puntero a un entero que recibe un recuento del número máximo de caracteres que caben en el espacio especificado por *nMaxExtent*. Cuando *lpnFit* es NULL, *nMaxExtent* se omite.

*alpDx*<br/>
Puntero a una matriz de enteros que recibe extensiones de glifo parciales. Cada elemento de la matriz proporciona la distancia, en unidades lógicas, entre el principio de la matriz de índices de glifos y uno de los glifos que cabe en el espacio especificado por *nMaxExtent*. Aunque esta matriz debe tener al menos tantos elementos como índices de glifo especificados por *cgi*, la función rellena la matriz con extensiones solo para tantos índices de glifo como especifique *lpnFit*. Si *lpnDx* es NULL, la función no calcula los anchos de cadena parciales.

*lpSize*<br/>
Puntero a una estructura [SIZE](/windows/win32/api/windef/ns-windef-size) que recibe las dimensiones de la matriz de índices de glifo, en unidades lógicas. Este valor no puede ser NULL.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función miembro emula la funcionalidad de la función [GetTextExtentExPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentexpointi), como se describe en el Windows SDK.

## <a name="cdcgettextextentpointi"></a><a name="gettextextentpointi"></a>CDC::GetTextExtentPointI

Recupera el ancho y alto de la matriz especificada de índices de glifo.

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*pgiIn*<br/>
Puntero a una matriz de índices de glifo para los que se van a recuperar extensiones.

*Cgi*<br/>
Especifica el número de glifos de la matriz a la que apunta *pgiIn*.

*lpSize*<br/>
Puntero a una estructura [SIZE](/windows/win32/api/windef/ns-windef-size) que recibe las dimensiones de la matriz de índices de glifo, en unidades lógicas. Este valor no puede ser NULL.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función miembro emula la funcionalidad de la función [GetTextExtentPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentpointi), como se describe en el Windows SDK.

## <a name="cdcgettextface"></a><a name="gettextface"></a>CDC::GetTextFace

Llame a esta función miembro para copiar el nombre de tipo de letra de la fuente actual en un búfer.

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>Parámetros

*nCount*<br/>
Especifica el tamaño del búfer (en bytes). Si el nombre del tipo de letra es mayor que el número de bytes especificado por este parámetro, el nombre se trunca.

*lpszFacename*<br/>
Apunta al búfer para el nombre del tipo de letra.

*rString*<br/>
Una referencia a un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto.

### <a name="return-value"></a>Valor devuelto

El número de bytes copiados en el búfer, sin incluir el carácter nulo de terminación. Es 0 si se produce un error.

### <a name="remarks"></a>Observaciones

El nombre de tipo de letra se copia como una cadena terminada en null.

## <a name="cdcgettextmetrics"></a><a name="gettextmetrics"></a>CDC::GetTextMetrics

Recupera las métricas de la fuente actual mediante el contexto del dispositivo de atributo.

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parámetros

*lpMetrics*<br/>
Apunta a la estructura [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) que recibe las métricas.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

## <a name="cdcgetviewportext"></a><a name="getviewportext"></a>CDC::GetViewportExt

Recupera las extensiones x e y de la ventana gráfica del contexto del dispositivo.

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>Valor devuelto

Las extensiones x e y (en unidades de dispositivo) como un `CSize` objeto.

## <a name="cdcgetviewportorg"></a><a name="getviewportorg"></a>CDC::GetViewportOrg

Recupera las coordenadas x e y del origen de la ventana gráfica asociada al contexto del dispositivo.

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>Valor devuelto

El origen de la ventana gráfica (en coordenadas de dispositivo) como un `CPoint` objeto.

## <a name="cdcgetwindow"></a><a name="getwindow"></a>CDC::GetWindow

Devuelve la ventana asociada al contexto del dispositivo de visualización.

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>Valor devuelto

Puntero a `CWnd` un objeto si se realiza correctamente; NULL.

### <a name="remarks"></a>Observaciones

Esta es una función avanzada. Por ejemplo, es posible que esta función miembro no devuelva la ventana de vista al imprimir o en vista previa de impresión. Siempre devuelve la ventana asociada a la salida. Las funciones de salida que utilizan el controlador de dominio dado se dibujan en esta ventana.

## <a name="cdcgetwindowext"></a><a name="getwindowext"></a>CDC::GetWindowExt

Recupera las extensiones x e y de la ventana asociada al contexto del dispositivo.

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>Valor devuelto

Las extensiones x e y (en unidades lógicas) como un `CSize` objeto.

## <a name="cdcgetwindoworg"></a><a name="getwindoworg"></a>CDC::GetWindowOrg

Recupera las coordenadas x e y del origen de la ventana asociada al contexto del dispositivo.

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>Valor devuelto

El origen de la ventana (en `CPoint` coordenadas lógicas) como un objeto.

## <a name="cdcgetworldtransform"></a><a name="getworldtransform"></a>CDC::GetWorldTransform

Recupera la transformación actual del espacio mundial en el espacio de página.

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>Parámetros

*rXform*<br/>
Referencia a una estructura [XFORM](/windows/win32/api/wingdi/ns-wingdi-xform) que recibe la transformación actual del espacio mundial al espacio de página.

### <a name="return-value"></a>Valor devuelto

Devuelve un valor distinto de cero en caso de éxito.

Devuelve 0 en caso de error.

Para obtener información de error extendida, llame a [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Observaciones

Este método ajusta la función GDI de Windows [GetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-getworldtransform).

## <a name="cdcgradientfill"></a><a name="gradientfill"></a>CDC::GradientFill

Llame a esta función miembro para rellenar estructuras de rectángulo y triángulo con color que se desvanece suavemente de un lado al otro.

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>Parámetros

*pVertices*<br/>
Puntero a una matriz de estructuras [TRIVERTEX](/windows/win32/api/wingdi/ns-wingdi-trivertex) que definen cada una de ellas un vértice de triángulo.

*nVertices*<br/>
El número de vértices.

*pMesh*<br/>
Matriz de [GRADIENT_TRIANGLE](/windows/win32/api/wingdi/ns-wingdi-gradient_triangle) estructuras en modo triángulo o una matriz de [estructuras GRADIENT_RECT](/windows/win32/api/wingdi/ns-wingdi-gradient_rect) en modo rectángulo.

*nMeshElements*<br/>
El número de elementos (triángulos o rectángulos) en *pMesh*.

*dwMode*<br/>
Especifica el modo de relleno degradado. Para obtener una lista de valores posibles, consulte [GradientFill](/windows/win32/api/wingdi/nf-wingdi-gradientfill) en el Windows SDK.

### <a name="return-value"></a>Valor devuelto

TRUE si es correcto; en caso contrario, FALSE.

### <a name="remarks"></a>Observaciones

Para obtener más `GradientFill` información, consulte en el Windows SDK.

## <a name="cdcgraystring"></a><a name="graystring"></a>CDC::GrayString

Dibuja texto atenuado (gris) en la ubicación dada escribiendo el texto en un mapa de bits de memoria, atenuando el mapa de bits y, a continuación, copiando el mapa de bits en la pantalla.

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parámetros

*Pbrush*<br/>
Identifica el pincel que se utilizará para atenuar (gris).

*lpfnOutput*<br/>
Especifica la dirección de instancia de procedimiento de la función de devolución de llamada proporcionada por la aplicación que dibujará la cadena. Para obtener más información, consulte `OutputFunc` la descripción de la [función](callback-functions-used-by-mfc.md#graystring)de devolución de llamada de Windows. Si este parámetro es NULL, `TextOut` el sistema utiliza la función de Windows para dibujar la cadena y se supone que *lpData* es un puntero largo a la cadena de caracteres que se va a generar.

*lpData*<br/>
Especifica un puntero lejano a los datos que se pasarán a la función de salida. Si *lpfnOutput* es NULL, *lpData* debe ser un puntero largo a la cadena que se va a generar.

*nCount*<br/>
Especifica el número de caracteres que se van a generar. Si este parámetro `GrayString` es 0, calcula la longitud de la cadena (suponiendo que *lpData* es un puntero a la cadena). Si *nCount* es 1 y la función señalada por *lpfnOutput* devuelve 0, la imagen se muestra pero no se atenúa.

*X*<br/>
Especifica la coordenada x lógica de la posición inicial del rectángulo que encierra la cadena.

*y y*<br/>
Especifica la coordenada y lógica de la posición inicial del rectángulo que encierra la cadena.

*nAncho*<br/>
Especifica el ancho (en unidades lógicas) del rectángulo que encierra la cadena. Si *nWidth* es `GrayString` 0, calcula el ancho del área, suponiendo *que lpData* es un puntero a la cadena.

*nAltura*<br/>
Especifica el alto (en unidades lógicas) del rectángulo que encierra la cadena. Si *nHeight* es `GrayString` 0, calcula la altura del área, suponiendo *que lpData* es un puntero a la cadena.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si se dibuja la `TextOut` cadena, o 0 si la función o la función de salida proporcionada por la aplicación devuelve0, o si no había memoria suficiente para crear un mapa de bits de memoria para la atenuación.

### <a name="remarks"></a>Observaciones

La función atenúa el texto independientemente del pincel y el fondo seleccionados. La `GrayString` función miembro utiliza la fuente seleccionada actualmente. El modo de asignación de MM_TEXT debe seleccionarse antes de utilizar esta función.

Una aplicación puede dibujar cadenas atenuadas (grises) en dispositivos `GrayString` que admiten un color gris sólido sin llamar a la función miembro. El color del sistema COLOR_GRAYTEXT es el color gris sólido que se utiliza para dibujar texto deshabilitado. La aplicación puede `GetSysColor` llamar a la función de Windows para recuperar el valor de color de COLOR_GRAYTEXT. Si el color es distinto de 0 (negro), la aplicación puede llamar a la `SetTextColor` función miembro para establecer el color de texto en el valor de color y, a continuación, dibujar la cadena directamente. Si el color recuperado es negro, `GrayString` la aplicación debe llamar a atenuar (gris) el texto.

Si *lpfnOutput* es NULL, GDI usa la función [TextOut](/windows/win32/api/wingdi/nf-wingdi-textoutw) de Windows y se supone que *lpData* es un puntero lejano al carácter que se va a generar. Si la función miembro no puede `TextOut` controlar los caracteres que se van a generar (por ejemplo, la cadena se almacena como un mapa de bits), la aplicación debe proporcionar su propia función de salida.

Tenga en cuenta también que todas las funciones de devolución de llamada deben capturar las excepciones de Microsoft Foundation antes de volver a Windows, ya que las excepciones no se pueden producir a través de los límites de devolución de llamada. Para obtener más información acerca de las excepciones, vea el artículo [Excepciones](../../mfc/exception-handling-in-mfc.md).

La función `GrayString` de devolución `__stdcall` de llamada que `__declspec`se pasa debe usar la convención de llamada y debe exportarse con .

Cuando el marco de trabajo está `GrayString` en modo de vista `TextOut` previa, una llamada a la función miembro se traduce a una llamada y no se llama a la función de devolución de llamada.

## <a name="cdchimetrictodp"></a><a name="himetrictodp"></a>CDC::HIMETRICtoDP

Utilice esta función al convertir tamaños HIMETRIC de OLE a píxeles.

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*lpSize*<br/>
Apunta a una estructura [SIZE](/windows/win32/api/windef/ns-windef-size) o a un objeto [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Observaciones

Si el modo de asignación del objeto de contexto de dispositivo es MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC o MM_HIMETRIC, la conversión se basa en el número de píxeles de la pulgada física. Si el modo de asignación es uno de los otros modos no restringidos (por ejemplo, MM_TEXT), la conversión se basa en el número de píxeles de la pulgada lógica.

## <a name="cdchimetrictolp"></a><a name="himetrictolp"></a>CDC::HIMETRICtoLP

Llame a esta función para convertir unidades HIMETRIC en unidades lógicas.

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*lpSize*<br/>
Apunta a una estructura [SIZE](/windows/win32/api/windef/ns-windef-size) o a un objeto [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Observaciones

Utilice esta función cuando obtenga tamaños HIMETRIC de OLE y desee convertirlos al modo de asignación natural de la aplicación.

La conversión se realiza primero convirtiendo las unidades HIMETRIC en píxeles y, a continuación, convirtiendo estas unidades en unidades lógicas utilizando las unidades de asignación actuales del contexto de dispositivo. Tenga en cuenta que las extensiones de la ventana y la ventana gráfica del dispositivo afectarán al resultado.

## <a name="cdcintersectcliprect"></a><a name="intersectcliprect"></a>CDC::IntersectClipRect

Crea una nueva región de recorte formando la intersección de la región actual y el rectángulo especificado por *x1*, *y1*, *x2*y *y2*.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parámetros

*x1*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo.

*y1*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo.

*x2*<br/>
Especifica la coordenada x lógica de la esquina inferior derecha del rectángulo.

*y2*<br/>
Especifica la coordenada y lógica de la esquina inferior derecha del rectángulo.

*lpRect*<br/>
Especifica el rectángulo. Puede pasar un `CRect` objeto o un `RECT` puntero a una estructura para este parámetro.

### <a name="return-value"></a>Valor devuelto

Tipo de la nueva región de recorte. Puede ser cualquiera de los siguientes valores:

- COMPLEXREGION Nueva región de recorte tiene bordes superpuestos.

- ERROR El contexto del dispositivo no es válido.

- NULLREGION Nueva región de recorte está vacía.

- SIMPLEREGION Nueva región de recorte no tiene bordes superpuestos.

### <a name="remarks"></a>Observaciones

GDI recorta toda la salida posterior para que quepa dentro del nuevo límite. La anchura y la altura no deben exceder de 32.767.

## <a name="cdcinvertrect"></a><a name="invertrect"></a>CDC::InvertRect

Invierte el contenido del rectángulo especificado.

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Apunta a `RECT` un que contiene las coordenadas lógicas del rectángulo que se va a invertir. También puede pasar `CRect` un objeto para este parámetro.

### <a name="remarks"></a>Observaciones

La inversión es una operación lógica de NOT y voltea los bits de cada píxel. En las pantallas monocromáticas, la función hace que los píxeles blancos sean blancos y negros. En las pantallas de color, la inversión depende de cómo se generen los colores para la visualización. Llamar `InvertRect` dos veces con el mismo rectángulo restaura la visualización a sus colores anteriores.

Si el rectángulo está vacío, no se dibuja nada.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

## <a name="cdcinvertrgn"></a><a name="invertrgn"></a>CDC::InvertRgn

Invierte los colores de la región especificada por *pRgn*.

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parámetros

*pRgn*<br/>
Identifica la región que se va a invertir. Las coordenadas de la región se especifican en unidades lógicas.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

En las pantallas monocromáticas, la función hace que los píxeles blancos sean blancos y negros. En las pantallas de color, la inversión depende de cómo se generen los colores para la visualización.

## <a name="cdcisprinting"></a><a name="isprinting"></a>CDC::IsPrinting

Determina si el contexto del dispositivo se está utilizando para la impresión.

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>Valor devuelto

Distinto de `CDC` cero si el objeto es un CONTROLADOR de dominio de impresora; de lo contrario 0.

## <a name="cdclineto"></a><a name="lineto"></a>CDC::LineTo

Dibuja una línea desde la posición actual hasta, pero sin incluir, el punto especificado por *x* e *y* (o *punto*).

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x lógica del punto final de la línea.

*y y*<br/>
Especifica la coordenada y lógica del punto final de la línea.

*Punto*<br/>
Especifica el punto final de la línea. Puede pasar una `POINT` estructura `CPoint` o un objeto para este parámetro.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si se dibuja la línea; de lo contrario 0.

### <a name="remarks"></a>Observaciones

La línea se dibuja con el lápiz seleccionado. La posición actual se establece en *x*, *y* o en *punto*.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdclptodp"></a><a name="lptodp"></a>CDC::LPtoDP

Convierte unidades lógicas en unidades de dispositivo.

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de puntos. Cada punto de la matriz es una estructura [POINT](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*nCount*<br/>
El número de puntos de la matriz.

*lpRect*<br/>
Apunta a una estructura [RECT](/windows/win32/api/windef/ns-windef-rect) o a un objeto [CRect.](../../atl-mfc-shared/reference/crect-class.md) Este parámetro se utiliza para el caso común de asignar un rectángulo de unidades lógicas a unidades de dispositivo.

*lpSize*<br/>
Apunta a una estructura [SIZE](/windows/win32/api/windef/ns-windef-size) o a un objeto [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Observaciones

La función asigna las coordenadas de cada punto, o dimensiones de un tamaño, desde el sistema de coordenadas lógicas de GDI a un sistema de coordenadas de dispositivo. La conversión depende del modo de asignación actual y de la configuración de los orígenes y extensiones de la ventana y la ventana gráfica del dispositivo.

Las coordenadas x e y de los puntos son enteros con signo de 2 bytes en el intervalo -32.768 a 32.767. En los casos en que el modo de asignación daría como resultado valores mayores que estos límites, el sistema establece los valores en -32.768 y 32.767, respectivamente.

## <a name="cdclptohimetric"></a><a name="lptohimetric"></a>CDC::LPtoHIMETRIC

Llame a esta función para convertir unidades lógicas en unidades HIMETRIC.

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*lpSize*<br/>
Apunta a `SIZE` una `CSize` estructura o a un objeto.

### <a name="remarks"></a>Observaciones

Utilice esta función cuando asigne tamaños HIMETRIC a OLE, convirtiendo desde el modo de asignación natural de la aplicación. Tenga en cuenta que las extensiones de la ventana y la ventana gráfica del dispositivo afectarán al resultado.

La conversión se realiza primero convirtiendo las unidades lógicas en píxeles utilizando las unidades de asignación actuales del contexto de dispositivo y, a continuación, convirtiendo estas unidades en unidades HIMETRIC.

## <a name="cdcm_hattribdc"></a><a name="m_hattribdc"></a>CDC::m_hAttribDC

El contexto del `CDC` dispositivo de atributo para este objeto.

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>Observaciones

De forma predeterminada, este `m_hDC`contexto de dispositivo es igual a . En general, `CDC` las llamadas GDI que solicitan `m_hAttribDC`información del contexto del dispositivo se dirigen a . Consulte la descripción de la clase [CDC](../../mfc/reference/cdc-class.md) para obtener más información sobre el uso de estos dos contextos de dispositivo.

## <a name="cdcm_hdc"></a><a name="m_hdc"></a>CDC::m_hDC

El contexto del `CDC` dispositivo de salida para este objeto.

```
HDC m_hDC;
```

### <a name="remarks"></a>Observaciones

De forma `m_hDC` predeterminada, `m_hAttribDC`es igual a , `CDC`el otro contexto de dispositivo ajustado por . En general, `CDC` las llamadas GDI `m_hDC` que crean la salida van al contexto del dispositivo. Puede inicializar `m_hDC` `m_hAttribDC` y apuntar a diferentes dispositivos. Consulte la descripción de la clase [CDC](../../mfc/reference/cdc-class.md) para obtener más información sobre el uso de estos dos contextos de dispositivo.

## <a name="cdcmaskblt"></a><a name="maskblt"></a>CDC::MaskBlt

Combina los datos de color para los mapas de bits de origen y destino utilizando la máscara y la operación ráster dadas.

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo de destino.

*y y*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo de destino.

*nAncho*<br/>
Especifica el ancho, en unidades lógicas, del rectángulo de destino y del mapa de bits de origen.

*nAltura*<br/>
Especifica el alto, en unidades lógicas, del rectángulo de destino y del mapa de bits de origen.

*pSrcDC*<br/>
Identifica el contexto del dispositivo desde el que se va a copiar el mapa de bits. Debe ser cero si el parámetro *dwRop* especifica una operación ráster que no incluye un origen.

*xSrc*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del mapa de bits de origen.

*ySrc*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del mapa de bits de origen.

*maskBitmap*<br/>
Identifica el mapa de bits de máscara monocromo combinado con el mapa de bits de color en el contexto del dispositivo de origen.

*xMask*<br/>
Especifica el desplazamiento de píxel horizontal para el mapa de bits de máscara especificado por el *parámetro maskBitmap.*

*yMask*<br/>
Especifica el desplazamiento de píxel vertical para el mapa de bits de máscara especificado por el *parámetro maskBitmap.*

*dwRop*<br/>
Especifica los códigos de operación ráster ternaria de primer plano y de fondo, que la función utiliza para controlar la combinación de datos de origen y destino. El código de operación ráster de fondo se almacena en el byte alto de la palabra alta de este valor; el código de operación ráster en primer plano se almacena en el byte bajo de la palabra alta de este valor; la palabra baja de este valor se omite y debe ser cero. La macro MAKEROP4 crea tales combinaciones de códigos de operación ráster de primer plano y de fondo. Consulte la sección Comentarios para obtener una explicación de primer plano y fondo en el contexto de esta función. Consulte `BitBlt` la función miembro para obtener una lista de códigos de operación ráster comunes.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Un valor de 1 en la máscara especificado por *maskBitmap* indica que el código de operación ráster en primer plano especificado por *dwRop* debe aplicarse en esa ubicación. Un valor de 0 en la máscara indica que el código de operación ráster de fondo especificado por *dwRop* debe aplicarse en esa ubicación. Si las operaciones ráster requieren un origen, el rectángulo de máscara debe cubrir el rectángulo de origen. Si no es así, se producirá un error en la función. Si las operaciones ráster no requieren un origen, el rectángulo de máscara debe cubrir el rectángulo de destino. Si no es así, se producirá un error en la función.

Si una transformación de rotación o cizallamiento está en vigor para el contexto del dispositivo de origen cuando se llama a esta función, se produce un error. Sin embargo, se permiten otros tipos de transformaciones.

Si los formatos de color de los mapas de bits de origen, patrón y destino difieren, esta función convierte el patrón o el formato de origen, o ambos, para que coincidan con el formato de destino. Si el mapa de bits de máscara no es un mapa de bits monocromo, se produce un error. Cuando se registra un metarchivo mejorado, se produce un error (y la función devuelve 0) si el contexto del dispositivo de origen identifica un contexto de dispositivo de metarchivo mejorado. No todos `MaskBlt`los dispositivos son compatibles con . Una aplicación `GetDeviceCaps` debe llamar para determinar si un dispositivo admite esta función. Si no se proporciona ningún mapa de `BitBlt`bits de máscara, esta función se comporta exactamente igual que , utilizando el código de operación ráster en primer plano. Los desplazamientos de píxeles en el mapa de bits de máscara se asignan al punto (0,0) en el mapa de bits del contexto del dispositivo de origen. Esto es útil para los casos en los que un mapa de bits de máscara contiene un conjunto de máscaras; una aplicación puede aplicar fácilmente cualquiera de ellos a una tarea de enmascaramiento `MaskBlt`ajustando los desplazamientos de píxeles y los tamaños de rectángulo enviados a .

## <a name="cdcmodifyworldtransform"></a><a name="modifyworldtransform"></a>CDC::ModifyWorldTransform

Cambia la transformación del mundo para un contexto de dispositivo mediante el modo especificado.

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>Parámetros

*rXform*<br/>
Referencia a una estructura [XFORM](/windows/win32/api/wingdi/ns-wingdi-xform) utilizada para modificar la transformación del mundo para el contexto de dispositivo especificado.

*Imode*<br/>
Especifica cómo los datos de transformación modifican la transformación del mundo actual. Para obtener una lista de los valores que puede tomar este parámetro, vea [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

### <a name="return-value"></a>Valor devuelto

Devuelve un valor distinto de cero en caso de éxito.

Devuelve 0 en caso de error.

Para obtener información de error extendida, llame a [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Observaciones

Este método ajusta la función GDI de Windows [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

## <a name="cdcmoveto"></a><a name="moveto"></a>CDC::MoveTo

Mueve la posición actual al punto especificado por *x* e *y* (o por *punto*).

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x lógica de la nueva posición.

*y y*<br/>
Especifica la coordenada y lógica de la nueva posición.

*Punto*<br/>
Especifica la nueva posición. Puede pasar una `POINT` estructura `CPoint` o un objeto para este parámetro.

### <a name="return-value"></a>Valor devuelto

Las coordenadas x e y de la `CPoint` posición anterior como objeto.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdcoffsetcliprgn"></a><a name="offsetcliprgn"></a>CDC::OffsetClipRgn

Mueve la región de recorte del contexto del dispositivo por los desplazamientos especificados.

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica el número de unidades lógicas que se moverán a la izquierda o a la derecha.

*y y*<br/>
Especifica el número de unidades lógicas que se moverán hacia arriba o hacia abajo.

*Tamaño*<br/>
Especifica la cantidad que se va a desfasar.

### <a name="return-value"></a>Valor devuelto

Tipo de la nueva región. Puede ser cualquiera de los siguientes valores:

- LA región de recorte COMPLEXREGION tiene bordes superpuestos.

- ERROR El contexto del dispositivo no es válido.

- La región de recorte NULLREGION está vacía.

- La región de recorte SIMPLEREGION no tiene bordes superpuestos.

### <a name="remarks"></a>Observaciones

La función mueve las unidades de región *x* a lo largo del eje X y las unidades *y* a lo largo del eje Y.

## <a name="cdcoffsetviewportorg"></a><a name="offsetviewportorg"></a>CDC::OffsetViewportOrg

Modifica las coordenadas del origen de la ventana gráfica en relación con las coordenadas del origen de la ventana gráfica actual.

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parámetros

*nAncho*<br/>
Especifica el número de unidades de dispositivo que se agregará a la coordenada x del origen actual.

*nAltura*<br/>
Especifica el número de unidades de dispositivo que se agregará a la coordenada y del origen actual.

### <a name="return-value"></a>Valor devuelto

El origen de la ventana gráfica `CPoint` anterior (en coordenadas de dispositivo) como un objeto.

## <a name="cdcoffsetwindoworg"></a><a name="offsetwindoworg"></a>CDC::OffsetWindowOrg

Modifica las coordenadas del origen de la ventana en relación con las coordenadas del origen actual de la ventana.

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parámetros

*nAncho*<br/>
Especifica el número de unidades lógicas que se agregará a la coordenada x del origen actual.

*nAltura*<br/>
Especifica el número de unidades lógicas que se agregará a la coordenada y del origen actual.

### <a name="return-value"></a>Valor devuelto

El origen de la ventana anterior `CPoint` (en coordenadas lógicas) como un objeto.

## <a name="cdcoperator-hdc"></a><a name="operator_hdc"></a>CDC::operador HDC

Utilice este operador para recuperar el `CDC` identificador de contexto de dispositivo del objeto.

```
operator HDC() const;
```

### <a name="return-value"></a>Valor devuelto

Si se realiza correctamente, el identificador del objeto de contexto de dispositivo; de lo contrario, NULL.

### <a name="remarks"></a>Observaciones

Puede usar el identificador para llamar a las API de Windows directamente.

## <a name="cdcpaintrgn"></a><a name="paintrgn"></a>CDC::PaintRgn

Rellena la región especificada por *pRgn* utilizando el pincel actual.

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parámetros

*pRgn*<br/>
Identifica la región que se va a rellenar. Las coordenadas de la región dada se especifican en unidades lógicas.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

## <a name="cdcpatblt"></a><a name="patblt"></a>CDC::PatBlt

Crea un patrón de bits en el dispositivo.

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo que va a recibir el patrón.

*y y*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo que va a recibir el patrón.

*nAncho*<br/>
Especifica el ancho (en unidades lógicas) del rectángulo que va a recibir el patrón.

*nAltura*<br/>
Especifica la altura (en unidades lógicas) del rectángulo que va a recibir el patrón.

*dwRop*<br/>
Especifica el código de operación ráster. Los códigos de operación ráster (ROP) definen cómo GDI combina colores en las operaciones de salida que implican un pincel actual, un posible mapa de bits de origen y un mapa de bits de destino. Este parámetro puede ser uno de los siguientes valores:

- PATCOPY Copia el patrón en el mapa de bits de destino.

- PATINVERT Combina el mapa de bits de destino con el patrón mediante el operador XOR booleano.

- DSTINVERT invierte el mapa de bits de destino.

- BLACKNESS Convierte toda la salida en negro.

- WHITENESS Convierte toda la salida en blanco.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El patrón es una combinación del pincel seleccionado y el patrón que ya está en el dispositivo. El código de operación ráster especificado por *dwRop* define cómo se deben combinar los patrones. Las operaciones ráster enumeradas para esta función son un subconjunto limitado de los 256 códigos de operación ráster ternario completos; en particular, no se puede utilizar un código de operación ráster que haga referencia a un origen.

No todos los contextos de dispositivo admiten la `PatBlt` función. Para determinar si un `PatBlt`contexto `GetDeviceCaps` de dispositivo admite , llame a la función miembro con el índice RASTERCAPS y compruebe el valor devuelto para el RC_BITBLT marca.

## <a name="cdcpie"></a><a name="pie"></a>CDC::Pie

Dibuja una cuña en forma de tarta dibujando un arco elíptico cuyo centro y dos puntos finales están unidos por líneas.

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parámetros

*x1*<br/>
Especifica la coordenada x de la esquina superior izquierda del rectángulo delimitador (en unidades lógicas).

*y1*<br/>
Especifica la coordenada y de la esquina superior izquierda del rectángulo delimitador (en unidades lógicas).

*x2*<br/>
Especifica la coordenada x de la esquina inferior derecha del rectángulo delimitador (en unidades lógicas).

*y2*<br/>
Especifica la coordenada y de la esquina inferior derecha del rectángulo delimitador (en unidades lógicas).

*x3*<br/>
Especifica la coordenada x del punto inicial del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco.

*y3*<br/>
Especifica la coordenada y del punto inicial del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco.

*x4*<br/>
Especifica la coordenada x del punto final del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco.

*y4*<br/>
Especifica la coordenada y del punto final del arco (en unidades lógicas). Este punto no tiene que estar exactamente en el arco.

*lpRect*<br/>
Especifica el rectángulo delimitador. Puede pasar un `CRect` objeto o un `RECT` puntero a una estructura para este parámetro.

*ptStart*<br/>
Especifica el punto inicial del arco. Este punto no tiene que estar exactamente en el arco. Puede pasar una estructura [POINT](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parámetro.

*ptEnd*<br/>
Especifica el punto final del arco. Este punto no tiene que estar exactamente en el arco. Puede pasar una `POINT` estructura `CPoint` o un objeto para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El centro del arco es el centro del rectángulo delimitador especificado por *x1*, *y1*, *x2*e *y2* (o por *lpRect*). Los puntos inicial y final del arco se especifican mediante *x3*, *y3*, *x4*e *y4* (o por *ptStart* y *ptEnd).*

El arco se dibuja con el lápiz seleccionado, moviéndose en sentido contrario a las agujas del reloj. Se dibujan dos líneas adicionales desde cada punto final hasta el centro del arco. El área en forma de pastel se rellena con el pincel actual. Si *x3* es igual a *x4* y *y3* es igual a *y4*, el resultado es una elipse con una sola línea desde el centro de la elipse hasta el punto ( *x3*, *y3*) o ( *x4*, *y4*).

La figura dibujada por esta función se extiende hasta pero no incluye las coordenadas derecha e inferior. Esto significa que la altura de la figura es *y2* - *y1* y la anchura de la figura es *x2* - *x1*. Tanto el ancho como el alto del rectángulo delimitador deben ser mayores que 2 unidades y menos de 32.767 unidades.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

## <a name="cdcplaymetafile"></a><a name="playmetafile"></a>CDC::PlayMetaFile

Reproduce el contenido del metarchivo especificado en el contexto del dispositivo.

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>Parámetros

*Hmf*<br/>
Identifica el metarchivo que se va a reproducir.

*hEnhMetaFile*<br/>
Identifica el metarchivo mejorado.

*lpBounds*<br/>
Apunta a `RECT` una `CRect` estructura o a un objeto que contiene las coordenadas del rectángulo delimitador utilizado para mostrar la imagen. Las coordenadas se especifican en unidades lógicas.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El metarchivo se puede reproducir cualquier número de veces.

La segunda `PlayMetaFile` versión de muestra la imagen almacenada en el metarchivo de formato mejorado dado. Cuando una aplicación llama `PlayMetaFile`a la segunda versión de , Windows utiliza el marco de imagen en el encabezado de metaarchivo mejorado para asignar la imagen al rectángulo al que apunta el parámetro *lpBounds.* (Esta imagen puede ser cizallada o girada estableciendo `PlayMetaFile`la transformación del mundo en el dispositivo de salida antes de llamar a .) Los puntos a lo largo de los bordes del rectángulo se incluyen en la imagen. Una imagen de metarchivo mejorado se puede recortar definiendo la región de recorte en el dispositivo de salida antes de reproducir el metarchivo mejorado.

Si un metarchivo mejorado contiene una paleta opcional, una aplicación puede lograr colores coherentes `PlayMetaFile`configurando una paleta de colores en el dispositivo de salida antes de llamar a la segunda versión de . Para recuperar la paleta `GetEnhMetaFilePaletteEntries` opcional, utilice la función Windows. Un metarchivo mejorado se puede incrustar en un metarchivo mejorado `PlayMetaFile` recién creado llamando a la segunda versión y reproduciendo el metarchivo mejorado de origen en el contexto del dispositivo para el nuevo metarchivo mejorado.

Esta función conserva los estados del contexto del dispositivo de salida. Esta función elimina cualquier objeto creado pero no eliminado en el metarchivo mejorado. Para detener esta función, `CancelDC` una aplicación puede llamar a la función de Windows desde otro subproceso para finalizar la operación. En este caso, la función devuelve cero.

## <a name="cdcplgblt"></a><a name="plgblt"></a>CDC::PlgBlt

Realiza una transferencia de bloque de bits de los bits de datos de color desde el rectángulo especificado en el contexto del dispositivo de origen al paralelogramo especificado en el contexto de dispositivo especificado.

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>Parámetros

*lpPoint*<br/>
Apunta a una matriz de tres puntos en el espacio lógico que identifica tres esquinas del paralelogramo de destino. La esquina superior izquierda del rectángulo de origen se asigna al primer punto de esta matriz, la esquina superior derecha al segundo punto de esta matriz y la esquina inferior izquierda al tercer punto. La esquina inferior derecha del rectángulo de origen se asigna al cuarto punto implícito del paralelogramo.

*pSrcDC*<br/>
Identifica el contexto del dispositivo de origen.

*xSrc*<br/>
Especifica la coordenada x, en unidades lógicas, de la esquina superior izquierda del rectángulo de origen.

*ySrc*<br/>
Especifica la coordenada y, en unidades lógicas, de la esquina superior izquierda del rectángulo de origen.

*nAncho*<br/>
Especifica el ancho, en unidades lógicas, del rectángulo de origen.

*nAltura*<br/>
Especifica el alto, en unidades lógicas, del rectángulo de origen.

*maskBitmap*<br/>
Identifica un mapa de bits monocromo opcional que se utiliza para enmascarar los colores del rectángulo de origen.

*xMask*<br/>
Especifica la coordenada x de la esquina superior izquierda del mapa de bits monocromo.

*yMask*<br/>
Especifica la coordenada y de la esquina superior izquierda del mapa de bits monocromo.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Si el identificador de máscara de bits especificado identifica un mapa de bits monocromo válido, la función utiliza este mapa de bits para enmascarar los bits de datos de color del rectángulo de origen.

El cuarto vértice del paralelogramo (D) se define tratando los tres primeros puntos (A, B y C) como vectores y calculando D a B + C - A.

Si la máscara de bits existe, un valor de 1 en la máscara indica que el color del píxel de origen se debe copiar en el destino. Un valor de 0 en la máscara indica que el color del píxel de destino no se debe cambiar.

Si el rectángulo de máscara es más pequeño que los rectángulos de origen y destino, la función replica el patrón de máscara.

Se permiten transformaciones de escalado, traducción y reflexión en el contexto del dispositivo de origen; sin embargo, las transformaciones de rotación y cizallamiento no lo son. Si el mapa de bits de máscara no es un mapa de bits monocromo, se produce un error. El modo de estiramiento para el contexto del dispositivo de destino se utiliza para determinar cómo estirar o comprimir los píxeles, si es necesario. Cuando se registra un metarchivo mejorado, se produce un error si el contexto del dispositivo de origen identifica un contexto de dispositivo de metarchivo mejorado.

Las coordenadas de destino se transforman según el contexto de dispositivo de destino; las coordenadas de origen se transforman según el contexto de dispositivo de origen. Si la transformación de origen tiene una rotación o una cizalla, se devuelve un error. Si los rectángulos de destino y de `PlgBlt` origen no tienen el mismo formato de color, convierte el rectángulo de origen para que coincida con el rectángulo de destino. No todos `PlgBlt`los dispositivos son compatibles con . Para obtener más información, consulte la descripción de la capacidad de ráster de RC_BITBLT en la `CDC::GetDeviceCaps` función miembro.

Si los contextos de dispositivo de `PlgBlt` origen y destino representan dispositivos incompatibles, devuelve un error.

## <a name="cdcpolybezier"></a><a name="polybezier"></a>CDC::PolyBezier

Dibuja una o más splines de Bzier.

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de estructuras de datos [POINT](/windows/win32/api/windef/ns-windef-point) que contienen los puntos finales y de control de las splines.

*nCount*<br/>
Especifica el número de puntos de la matriz *lpPoints.* Este valor debe ser una más de tres veces el número de splines que se van a dibujar, porque cada spline de Bzier requiere dos puntos de control y un punto final, y la spline inicial requiere un punto de partida adicional.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función dibuja splines Bzier cúbicas mediante los puntos finales y puntos de control especificados por el parámetro *lpPoints.* La primera spline se dibuja desde el primer punto hasta el cuarto punto utilizando el segundo y el tercer punto como puntos de control. Cada spline posterior de la secuencia necesita exactamente tres puntos más: el punto final de la spline anterior se utiliza como punto inicial, los dos puntos siguientes de la secuencia son puntos de control y el tercero es el punto final.

La función no utiliza ni `PolyBezier` actualiza la posición actual. La figura no está llena. Esta función dibuja líneas utilizando el lápiz actual.

## <a name="cdcpolybezierto"></a><a name="polybezierto"></a>CDC::PolyBezierTo

Dibuja una o más splines de Bzier.

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de estructuras de datos [POINT](/windows/win32/api/windef/ns-windef-point) que contiene los puntos finales y los puntos de control.

*nCount*<br/>
Especifica el número de puntos de la matriz *lpPoints.* Este valor debe ser tres veces el número de splines que se van a dibujar, porque cada spline de Bzier requiere dos puntos de control y un punto final.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función dibuja splines Bzier cúbicas utilizando los puntos de control especificados por el parámetro *lpPoints.* La primera spline se dibuja desde la posición actual hasta el tercer punto utilizando los dos primeros puntos como puntos de control. Para cada spline posterior, la función necesita exactamente tres puntos más y utiliza el punto final de la spline anterior como punto inicial para la siguiente. `PolyBezierTo`mueve la posición actual al punto final de la última spline de Bzier. La figura no está llena. Esta función dibuja líneas utilizando el lápiz actual.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC::BeginPath](#beginpath).

## <a name="cdcpolydraw"></a><a name="polydraw"></a>CDC::PolyDraw

Dibuja un conjunto de segmentos de línea y splines de Bzier.

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de estructuras de datos [POINT](/windows/win32/api/windef/ns-windef-point) que contiene los puntos finales para cada segmento de línea y los puntos finales y puntos de control para cada spline de Bzier.

*lpTypes*<br/>
Apunta a una matriz que especifica cómo se utiliza cada punto de la matriz *lpPoints.* Los valores pueden ser cualquier de los siguientes:

- PT_MOVETO Especifica que este punto inicia una figura desarticulada. Este punto se convierte en la nueva posición actual.

- PT_LINETO Especifica que se va a dibujar una línea desde la posición actual hasta este punto, que se convierte en la nueva posición actual.

- PT_BEZIERTO Especifica que este punto es un punto de control o punto final para una spline de Bzier.

PT_BEZIERTO tipos siempre se producen en conjuntos de tres. La posición actual define el punto de partida de la spline Bzier. Los dos primeros puntos PT_BEZIERTO son los puntos de control, y el tercer punto de PT_BEZIERTO es el punto final. El punto final se convierte en la nueva posición actual. Si no hay tres puntos PT_BEZIERTO consecutivos, se produce un error.

   Un tipo de PT_LINETO o PT_BEZIERTO se puede combinar con la siguiente constante mediante el operador OR bit a bit para indicar que el punto correspondiente es el último punto de una figura y que la figura está cerrada:

- PT_CLOSEFIGURE Especifica que la figura se cierra automáticamente después de que se realiza el tipo de PT_LINETO o PT_BEZIERTO para este punto. Se dibuja una línea desde este punto `MoveTo` hasta el PT_MOVETO o punto más reciente.

   Este indicador se combina con el tipo de PT_LINETO para una línea, o con el PT_BEZIERTO tipo de punto final para una spline de Bzier, mediante el operador **OR** bit a bit. La posición actual se establece en el punto final de la línea de cierre.

*nCount*<br/>
Especifica el número total de puntos de la matriz *lpPoints,* el mismo que el número de bytes de la matriz *lpTypes.*

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función se puede utilizar para dibujar figuras `CDC::MoveTo`disjuntas en lugar de llamadas consecutivas a , `CDC::LineTo`, y `CDC::PolyBezierTo` funciones miembro. Las líneas y splines se dibujan utilizando el lápiz actual y las figuras no se rellenan. Si se inicia una ruta `CDC::BeginPath` de acceso `PolyDraw` activa llamando a la función miembro, se agrega a la ruta de acceso. Los puntos contenidos en la matriz *lpPoints* y en `CDC::MoveTo` *lpTypes* indican si cada punto forma parte de una operación, `CDC::LineTo`una o una operación. `CDC::BezierTo` También es posible cerrar figuras. Esta función actualiza la posición actual.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC::BeginPath](#beginpath).

## <a name="cdcpolygon"></a><a name="polygon"></a>CDC::Polygon

Dibuja un polígono que consta de dos o más puntos (vértices) conectados por líneas, utilizando el lápiz actual.

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de puntos que especifica los vértices del polígono. Cada punto de la `POINT` matriz `CPoint` es una estructura o un objeto.

*nCount*<br/>
Especifica el número de vértices de la matriz.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El sistema cierra el polígono automáticamente, si es necesario, dibujando una línea desde el último vértice hasta el primero.

El modo de relleno de polígonos actual `GetPolyFillMode` se `SetPolyFillMode` puede recuperar o establecer mediante las funciones miembro y.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

## <a name="cdcpolyline"></a><a name="polyline"></a>CDC::Polyline

Dibuja un conjunto de segmentos de línea que conectan los puntos especificados por *lpPoints*.

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una `POINT` matriz `CPoint` de estructuras u objetos que se van a conectar.

*nCount*<br/>
Especifica el número de puntos de la matriz. Este valor debe ser al menos 2.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Las líneas se dibujan desde el primer punto a través de puntos posteriores utilizando el lápiz actual. A `LineTo` diferencia de `Polyline` la función miembro, la función no utiliza ni actualiza la posición actual.

Para obtener más información, consulte [PolyLine](/windows/win32/api/wingdi/nf-wingdi-polyline) en el Windows SDK.

## <a name="cdcpolylineto"></a><a name="polylineto"></a>CDC::PolylineTo

Dibuja una o más líneas rectas.

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de estructuras de datos [POINT](/windows/win32/api/windef/ns-windef-point) que contiene los vértices de la línea.

*nCount*<br/>
Especifica el número de puntos de la matriz.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Una línea se dibuja desde la posición actual hasta el primer punto especificado por el parámetro *lpPoints* utilizando el lápiz actual. Para cada línea adicional, la función se dibuja desde el punto final de la línea anterior hasta el siguiente punto especificado por *lpPoints*. `PolylineTo`mueve la posición actual al punto final de la última línea. Si los segmentos de línea dibujados por esta función forman una figura cerrada, la figura no se rellena.

## <a name="cdcpolypolygon"></a><a name="polypolygon"></a>CDC::PolyPolygon

Crea dos o más polígonos que se rellenan mediante el modo de relleno de polígonos actual.

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una `POINT` matriz `CPoint` de estructuras u objetos que definen los vértices de los polígonos.

*lpPolyCounts*<br/>
Apunta a una matriz de enteros, cada uno de los cuales especifica el número de puntos en uno de los polígonos de la matriz *lpPoints.*

*nCount*<br/>
El número de entradas de la matriz *lpPolyCounts.* Este número especifica el número de polígonos que se van a dibujar. Este valor debe ser al menos 2.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Los polígonos pueden estar desarticulados o superpuestos.

Cada polígono especificado en una `PolyPolygon` llamada a la función debe estar cerrado. A diferencia de `Polygon` los polígonos creados `PolyPolygon` por la función miembro, los polígonos creados por no se cierran automáticamente.

La función crea dos o más polígonos. Para crear un único polígono, `Polygon` una aplicación debe usar la función miembro.

El modo de relleno de polígonos actual `GetPolyFillMode` se `SetPolyFillMode` puede recuperar o establecer mediante las funciones miembro y.

## <a name="cdcpolypolyline"></a><a name="polypolyline"></a>CDC::PolyPolyline

Dibuja varias series de segmentos de línea conectados.

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de estructuras que contiene los vértices de las polilíneas. Las polilíneas se especifican consecutivamente.

*lpPolyPoints*<br/>
Apunta a una matriz de variables que especifica el número de puntos en la matriz *lpPoints* para el polígono correspondiente. Cada entrada debe ser mayor o igual que 2.

*nCount*<br/>
Especifica el número total de recuentos de la matriz *lpPolyPoints.*

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Los segmentos de línea se dibujan utilizando el lápiz actual. Las figuras formadas por los segmentos no se rellenan. Esta función no utiliza ni actualiza la posición actual.

## <a name="cdcptvisible"></a><a name="ptvisible"></a>CDC::PtVisible

Determina si el punto dado está dentro de la región de recorte del contexto del dispositivo.

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x lógica del punto.

*y y*<br/>
Especifica la coordenada y lógica del punto.

*Punto*<br/>
Especifica el punto para proteger las coordenadas lógicas. Puede pasar una `POINT` estructura `CPoint` o un objeto para este parámetro.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si el punto especificado está dentro de la región de recorte; de lo contrario 0.

## <a name="cdcqueryabort"></a><a name="queryabort"></a>CDC::QueryAbort

Llama a la función de anulación instalada por el [SetAbortProc](#setabortproc) función miembro para una aplicación de impresión y comprueba si se debe finalizar la impresión.

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>Valor devuelto

El valor devuelto es distinto de cero si la impresión debe continuar o si no hay ningún procedimiento de anulación. Es 0 si se debe terminar el trabajo de impresión. La función de anulación proporciona el valor devuelto.

## <a name="cdcrealizepalette"></a><a name="realizepalette"></a>CDC::RealizePalette

Asigna las entradas de la paleta lógica actual a la paleta del sistema.

```
UINT RealizePalette();
```

### <a name="return-value"></a>Valor devuelto

Indica cuántas entradas de la paleta lógica se asignaron a diferentes entradas en la paleta del sistema. Esto representa el número de entradas que esta función reasigna para adaptarse a los cambios en la paleta del sistema desde la última vez que se realizó la paleta lógica.

### <a name="remarks"></a>Observaciones

Una paleta de colores lógica actúa como un búfer entre las aplicaciones que consumen mucho color y el sistema, lo que permite a una aplicación utilizar tantos colores como sea necesario sin interferir con sus propios colores mostrados o con colores mostrados por otras ventanas.

Cuando una ventana tiene el `RealizePalette`foco de entrada y llama, Windows garantiza que la ventana mostrará todos los colores solicitados, hasta el número máximo disponible simultáneamente en la pantalla. Windows también muestra los colores que no se encuentran en la paleta de la ventana al hacer coincidirlos con los colores disponibles.

Además, Windows coincide con los colores solicitados por las ventanas inactivas que llaman a la función lo más cerca posible de los colores disponibles. Esto reduce significativamente los cambios no deseados en los colores que se muestran en las ventanas inactivas.

## <a name="cdcrectangle"></a><a name="rectangle"></a>CDC::Rectangle

Dibuja un rectángulo con el lápiz actual.

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>Parámetros

*x1*<br/>
Especifica la coordenada x de la esquina superior izquierda del rectángulo (en unidades lógicas).

*y1*<br/>
Especifica la coordenada y de la esquina superior izquierda del rectángulo (en unidades lógicas).

*x2*<br/>
Especifica la coordenada x de la esquina inferior derecha del rectángulo (en unidades lógicas).

*y2*<br/>
Especifica la coordenada y de la esquina inferior derecha del rectángulo (en unidades lógicas).

*lpRect*<br/>
Especifica el rectángulo en unidades lógicas. Puede pasar un `CRect` objeto o un `RECT` puntero a una estructura para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El interior del rectángulo se rellena con el pincel actual.

El rectángulo se extiende hasta, pero no incluye, las coordenadas derecha e inferior. Esto significa que la altura del rectángulo es *y2* - *y1* y el ancho del rectángulo es *x2* - *x1.* Tanto el ancho como el alto de un rectángulo deben ser mayores que 2 unidades y menos de 32.767 unidades.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

## <a name="cdcrectvisible"></a><a name="rectvisible"></a>CDC::RectVisible

Determina si alguna parte del rectángulo especificado se encuentra dentro de la región de recorte del contexto de visualización.

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Apunta a `RECT` una `CRect` estructura o a un objeto que contiene las coordenadas lógicas del rectángulo especificado.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si cualquier parte del rectángulo dado se encuentra dentro de la región de recorte; de lo contrario 0.

## <a name="cdcreleaseattribdc"></a><a name="releaseattribdc"></a>CDC::ReleaseAttribDC

Llame a esta `m_hAttribDC` función miembro para establecer en NULL.

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>Observaciones

Esto no hace `Detach` que ocurra un. Solo el contexto del dispositivo `CDC` de salida está asociado al objeto y solo se puede separar.

## <a name="cdcreleaseoutputdc"></a><a name="releaseoutputdc"></a>CDC::ReleaseOutputDC

Llame a esta función miembro para establecer el `m_hDC` miembro en NULL.

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>Observaciones

No se puede llamar a esta función `CDC` miembro cuando el contexto del dispositivo de salida está asociado al objeto. Utilice `Detach` la función miembro para separar el contexto del dispositivo de salida.

## <a name="cdcresetdc"></a><a name="resetdc"></a>CDC::ResetDC

Llame a esta función miembro para `CDC` actualizar el contexto del dispositivo ajustado por el objeto.

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>Parámetros

*lpDevMode*<br/>
Un puntero a `DEVMODE` una estructura de Windows.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El contexto del dispositivo se actualiza a `DEVMODE` partir de la información especificada en la estructura de Windows. Esta función miembro solo restablece el contexto del dispositivo de atributo.

Una aplicación normalmente `ResetDC` usará la función `WM_DEVMODECHANGE` miembro cuando una ventana procesa un mensaje. También puede utilizar esta función miembro para cambiar la orientación del papel o las bandejas de papel al imprimir un documento.

No puede utilizar esta función miembro para cambiar el nombre del controlador, el nombre del dispositivo o el puerto de salida. Cuando el usuario cambia la conexión de puerto o el nombre del dispositivo, debe eliminar el contexto del dispositivo original y crear un nuevo contexto de dispositivo con la nueva información.

Antes de llamar a esta función miembro, debe asegurarse de que se han seleccionado todos los objetos (excepto los objetos de stock) que se habían seleccionado en el contexto del dispositivo.

## <a name="cdcrestoredc"></a><a name="restoredc"></a>CDC::RestoreDC

Restaura el contexto del dispositivo al estado anterior identificado por *nSavedDC*.

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>Parámetros

*nSavedDC*<br/>
Especifica el contexto del dispositivo que se va a restaurar. Puede ser un valor devuelto `SaveDC` por una llamada de función anterior. Si *nSavedDC* es -1, se restaura el contexto de dispositivo guardado más recientemente.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si se restauró el contexto especificado; de lo contrario 0.

### <a name="remarks"></a>Observaciones

`RestoreDC`restaura el contexto del dispositivo sacando información de estado `SaveDC` de una pila creada por llamadas anteriores a la función miembro.

La pila puede contener la información de estado de varios contextos de dispositivo. Si el contexto especificado por *nSavedDC* no está `RestoreDC` en la parte superior de la pila, elimina toda la información de estado entre el contexto del dispositivo especificado por *nSavedDC* y la parte superior de la pila. La información eliminada se pierde.

## <a name="cdcroundrect"></a><a name="roundrect"></a>CDC::RoundRect

Dibuja un rectángulo con esquinas redondeadas utilizando el lápiz actual.

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>Parámetros

*x1*<br/>
Especifica la coordenada x de la esquina superior izquierda del rectángulo (en unidades lógicas).

*y1*<br/>
Especifica la coordenada y de la esquina superior izquierda del rectángulo (en unidades lógicas).

*x2*<br/>
Especifica la coordenada x de la esquina inferior derecha del rectángulo (en unidades lógicas).

*y2*<br/>
Especifica la coordenada y de la esquina inferior derecha del rectángulo (en unidades lógicas).

*x3*<br/>
Especifica el ancho de la elipse utilizada para dibujar las esquinas redondeadas (en unidades lógicas).

*y3*<br/>
Especifica la altura de la elipse utilizada para dibujar las esquinas redondeadas (en unidades lógicas).

*lpRect*<br/>
Especifica el rectángulo delimitador en unidades lógicas. Puede pasar un `CRect` objeto o un `RECT` puntero a una estructura para este parámetro.

*Punto*<br/>
La coordenada x de *punto* especifica el ancho de la elipse para dibujar las esquinas redondeadas (en unidades lógicas). La coordenada y del *punto* especifica la altura de la elipse para dibujar las esquinas redondeadas (en unidades lógicas). Puede pasar una `POINT` estructura `CPoint` o un objeto para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El interior del rectángulo se rellena con el pincel actual.

La figura que dibuja esta función se extiende hasta pero no incluye las coordenadas derecha e inferior. Esto significa que la altura de la figura es *y2* - *y1* y la anchura de la figura es *x2* - *x1*. Tanto la altura como la anchura del rectángulo delimitador deben ser mayores que 2 unidades y menos de 32.767 unidades.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

## <a name="cdcsavedc"></a><a name="savedc"></a>CDC::SaveDC

Guarda el estado actual del contexto del dispositivo copiando información de estado (como la región de recorte, los objetos seleccionados y el modo de asignación) en una pila de contexto mantenida por Windows.

```
virtual int SaveDC();
```

### <a name="return-value"></a>Valor devuelto

Entero que identifica el contexto del dispositivo guardado. Es 0 si se produce un error. Este valor devuelto se puede utilizar para `RestoreDC`restaurar el contexto del dispositivo llamando a .

### <a name="remarks"></a>Observaciones

El contexto del dispositivo guardado `RestoreDC`se puede restaurar posteriormente mediante .

`SaveDC`se puede utilizar cualquier número de veces para guardar cualquier número de estados de contexto de dispositivo.

## <a name="cdcscaleviewportext"></a><a name="scaleviewportext"></a>CDC::ScaleViewportExt

Modifica las extensiones de la ventana gráfica con respecto a los valores actuales.

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parámetros

*xNum*<br/>
Especifica la cantidad por la que se multiplicará la extensión x actual.

*xDenom*<br/>
Especifica la cantidad por la que se dividirá el resultado de multiplicar la extensión x actual por el valor del *xNum* parámetro.

*yNum*<br/>
Especifica la cantidad por la que se multiplicará la extensión y actual.

*yDenom*<br/>
Especifica la cantidad por la que se dividirá el resultado de multiplicar la extensión y actual por el valor del parámetro *yNum.*

### <a name="return-value"></a>Valor devuelto

Las extensiones de ventana gráfica anterior `CSize` (en unidades de dispositivo) como un objeto.

### <a name="remarks"></a>Observaciones

Las fórmulas se escriben de la siguiente manera:

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

Las nuevas extensiones de ventana gráfica se calculan multiplicando las extensiones actuales por el numerador dado y, a continuación, dividiendo por el denominador dado.

## <a name="cdcscalewindowext"></a><a name="scalewindowext"></a>CDC::ScaleWindowExt

Modifica las extensiones de ventana con respecto a los valores actuales.

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parámetros

*xNum*<br/>
Especifica la cantidad por la que se multiplicará la extensión x actual.

*xDenom*<br/>
Especifica la cantidad por la que se dividirá el resultado de multiplicar la extensión x actual por el valor del *xNum* parámetro.

*yNum*<br/>
Especifica la cantidad por la que se multiplicará la extensión y actual.

*yDenom*<br/>
Especifica la cantidad por la que se dividirá el resultado de multiplicar la extensión y actual por el valor del parámetro *yNum.*

### <a name="return-value"></a>Valor devuelto

Las extensiones de ventana anteriores `CSize` (en unidades lógicas) como un objeto.

### <a name="remarks"></a>Observaciones

Las fórmulas se escriben de la siguiente manera:

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

Las nuevas extensiones de ventana se calculan multiplicando las extensiones actuales por el numerador dado y, a continuación, dividiendo por el denominador dado.

## <a name="cdcscrolldc"></a><a name="scrolldc"></a>CDC::ScrollDC

Desplaza un rectángulo de bits horizontal y verticalmente.

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>Parámetros

*Dx*<br/>
Especifica el número de unidades de desplazamiento horizontal.

*Dy*<br/>
Especifica el número de unidades de desplazamiento verticales.

*lpRectScroll*<br/>
Apunta a `RECT` la `CRect` estructura u objeto que contiene las coordenadas del rectángulo desplazable.

*lpRectClip*<br/>
Apunta a `RECT` la `CRect` estructura u objeto que contiene las coordenadas del rectángulo delimitador. Cuando este rectángulo es más pequeño que el original al que apunta *lpRectScroll*, el desplazamiento solo se produce en el rectángulo más pequeño.

*pRgnUpdate*<br/>
Identifica la región descubierta por el proceso de desplazamiento. La `ScrollDC` función define esta región; no es necesariamente un rectángulo.

*lpRectUpdate*<br/>
Apunta a `RECT` la `CRect` estructura u objeto que recibe las coordenadas del rectángulo que limita la región de actualización de desplazamiento. Esta es la zona rectangular más grande que requiere repintado. Los valores de la estructura u objeto cuando se devuelve la función están en coordenadas de cliente, independientemente del modo de asignación para el contexto de dispositivo especificado.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si se ejecuta el desplazamiento; de lo contrario 0.

### <a name="remarks"></a>Observaciones

Si *lpRectUpdate* es NULL, Windows no calcula el rectángulo de actualización. Si *pRgnUpdate* y *lpRectUpdate* son NULL, Windows no calcula la región de actualización. Si *pRgnUpdate* no es NULL, Windows supone que contiene un puntero válido a la `ScrollDC` región descubierta por el proceso de desplazamiento (definido por la función miembro). La región de actualización devuelta en `CWnd::InvalidateRgn` *lpRectUpdate* se puede pasar si es necesario.

Una aplicación debe `ScrollWindow` utilizar la `CWnd` función miembro de la clase cuando es necesario desplazar se encuentra todo el área de cliente de una ventana. De lo contrario, debe usar `ScrollDC`.

## <a name="cdcselectclippath"></a><a name="selectclippath"></a>CDC::SelectClipPath

Selecciona la ruta actual como una región de recorte para el contexto del dispositivo, combinando la nueva región con cualquier región de recorte existente mediante el modo especificado.

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>Parámetros

*nMode*<br/>
Especifica la forma de utilizar la ruta de acceso. Se admiten los valores siguientes:

- RGN_AND La nueva región de recorte incluye la intersección (áreas superpuestas) de la región de recorte actual y el trazado actual.

- RGN_COPY La nueva región de recorte es la ruta actual.

- RGN_DIFF La nueva región de recorte incluye las áreas de la región de recorte actual y se excluyen las del trazado actual.

- RGN_OR La nueva región de recorte incluye la unión (áreas combinadas) de la región de recorte actual y la ruta actual.

- RGN_XOR La nueva región de recorte incluye la unión de la región de recorte actual y la ruta actual, pero sin las áreas superpuestas.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El contexto de dispositivo identificado debe contener una ruta de acceso cerrada.

## <a name="cdcselectcliprgn"></a><a name="selectcliprgn"></a>CDC::SelectClipRgn

Selecciona la región dada como la región de recorte actual para el contexto del dispositivo.

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>Parámetros

*pRgn*<br/>
Identifica la región que se va a seleccionar.

- Para la primera versión de esta función, si este valor es NULL, se selecciona todo el área de cliente y la salida sigue estando recortada a la ventana.

- Para la segunda versión de esta función, este identificador solo puede ser NULL cuando se especifica el modo RGN_COPY.

*nMode*<br/>
Especifica la operación que se va a realizar. Debe ser uno de los siguientes valores:

- RGN_AND La nueva región de recorte combina las áreas superpuestas de la región de recorte actual y la región identificada por *pRgn*.

- RGN_COPY La nueva región de recorte es una copia de la región identificada por *pRgn*. Esta es la funcionalidad es idéntica `SelectClipRgn`a la primera versión de . Si la región identificada por *pRgn* es NULL, la nueva región de recorte se convierte en la región de recorte predeterminada (una región nula).

- RGN_DIFF La nueva región de recorte combina las áreas de la región de recorte actual con las áreas excluidas de la región identificada por *pRgn*.

- RGN_OR La nueva región de recorte combina la región de recorte actual y la región identificada por *pRgn*.

- RGN_XOR La nueva región de recorte combina la región de recorte actual y la región identificada por *pRgn,* pero excluye las áreas superpuestas.

### <a name="return-value"></a>Valor devuelto

El tipo de la región. Puede ser cualquiera de los siguientes valores:

- COMPLEXREGION Nueva región de recorte tiene bordes superpuestos.

- ERROR El contexto o la región del dispositivo no son válidos.

- NULLREGION Nueva región de recorte está vacía.

- SIMPLEREGION Nueva región de recorte no tiene bordes superpuestos.

### <a name="remarks"></a>Observaciones

Solo se utiliza una copia de la región seleccionada. La región en sí se puede seleccionar para cualquier número de otros contextos de dispositivo, o se puede eliminar.

La función supone que las coordenadas de la región dada se especifican en unidades de dispositivo. Algunos dispositivos de impresora admiten la salida de texto con una resolución más alta que la salida de gráficos para conservar la precisión necesaria para expresar las métricas de texto. Estos dispositivos informan de unidades de dispositivo en la resolución más alta, es decir, en unidades de texto. A continuación, estos dispositivos escalan las coordenadas de los gráficos para que varias unidades de dispositivo notificadas se asignen a solo 1 unidad gráfica. Siempre debe llamar `SelectClipRgn` a la función utilizando unidades de texto.

Las aplicaciones que deben tomar el escalado de objetos gráficos en el GDI pueden utilizar el escape de impresora GETSCALINGFACTOR para determinar el factor de escala. Este factor de escala afecta al recorte. Si se utiliza una región para recortar gráficos, GDI divide las coordenadas por el factor de escala. Si la región se utiliza para recortar texto, GDI no realiza ningún ajuste de escala. Un factor de escala de 1 hace que las coordenadas se dividan por 2; un factor de escala de 2 hace que las coordenadas se dividan por 4; y así sucesivamente.

## <a name="cdcselectobject"></a><a name="selectobject"></a>CDC::SelectObject

Selecciona un objeto en el contexto del dispositivo.

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>Parámetros

*pPen*<br/>
Puntero a un [objeto CPen](../../mfc/reference/cpen-class.md) que se va a seleccionar.

*Pbrush*<br/>
Un puntero a un [CBrush](../../mfc/reference/cbrush-class.md) objeto que se va a seleccionar.

*pFont*<br/>
Un puntero a un [CFont](../../mfc/reference/cfont-class.md) objeto que se va a seleccionar.

*pBitmap*<br/>
Puntero a un [CBitmap](../../mfc/reference/cbitmap-class.md) objeto que se va a seleccionar.

*pRgn*<br/>
Puntero a un objeto [CRgn](../../mfc/reference/crgn-class.md) que se va a seleccionar.

*pObject*<br/>
Puntero a un [cGdiObject](../../mfc/reference/cgdiobject-class.md) objeto que se va a seleccionar.

### <a name="return-value"></a>Valor devuelto

Puntero al objeto que se va a reemplazar. Se trata de un puntero a un objeto `CGdiObject`de `CPen`una de las clases derivadas de , como , dependiendo de la versión de la función que se utilice. El valor devuelto es NULL si hay un error. Esta función puede devolver un puntero a un objeto temporal. Este objeto temporal solo es válido durante el procesamiento de un mensaje de Windows. Para obtener más información, vea `CGdiObject::FromHandle`.

La versión de la función miembro que toma `SelectClipRgn` un parámetro de región realiza la misma tarea que la función miembro. Su valor devuelto puede ser cualquiera de los siguientes:

- COMPLEXREGION Nueva región de recorte tiene bordes superpuestos.

- ERROR El contexto o la región del dispositivo no son válidos.

- NULLREGION Nueva región de recorte está vacía.

- SIMPLEREGION Nueva región de recorte no tiene bordes superpuestos.

### <a name="remarks"></a>Observaciones

Class `CDC` proporciona cinco versiones especializadas para determinados tipos de objetos GDI, incluidos bolígrafos, pinceles, fuentes, mapas de bits y regiones. El objeto recién seleccionado reemplaza el objeto anterior del mismo tipo. Por ejemplo, si *pObject* de `SelectObject` la versión general de apunta a un [CPen](../../mfc/reference/cpen-class.md) objeto, la función reemplaza el lápiz actual con el lápiz especificado por *pObject*.

Una aplicación puede seleccionar un mapa de bits solo en contextos de dispositivo de memoria y en un solo contexto de dispositivo de memoria a la vez. El formato del mapa de bits debe ser monocromo o compatible con el contexto del dispositivo; si no es `SelectObject` así, devuelve un error.

Para Windows 3.1 y `SelectObject` versiones posteriores, la función devuelve el mismo valor si se utiliza en un metarchivo o no. En versiones anteriores de Windows, `SelectObject` devolvía un valor distinto de cero para el éxito y 0 para el error cuando se usaba en un metarchivo.

## <a name="cdcselectpalette"></a><a name="selectpalette"></a>CDC::SelectPalette

Selecciona la paleta lógica especificada por *pPalette* como el objeto de paleta seleccionado del contexto del dispositivo.

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>Parámetros

*pPalette*<br/>
Identifica la paleta lógica que se va a seleccionar. Esta paleta ya debe `CPalette` haberse creado con la función miembro [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette).

*bForceBackground*<br/>
Especifica si la paleta lógica se ve forzada a ser una paleta de fondo. Si *bForceBackground* es distinto de cero, la paleta seleccionada siempre es una paleta de fondo, independientemente de si la ventana tiene el foco de entrada. Si *bForceBackground* es 0 y el contexto del dispositivo está asociado a una ventana, la paleta lógica es una paleta de primer plano cuando la ventana tiene el foco de entrada.

### <a name="return-value"></a>Valor devuelto

Puntero a `CPalette` un objeto que identifica la paleta lógica sustituyda por la paleta especificada por *pPalette*. Es NULL si hay un error.

### <a name="remarks"></a>Observaciones

La nueva paleta se convierte en el objeto de paleta utilizado por GDI para controlar los colores mostrados en el contexto del dispositivo y reemplaza la paleta anterior.

Una aplicación puede seleccionar una paleta lógica en más de un contexto de dispositivo. Sin embargo, los cambios en una paleta lógica afectarán a todos los contextos de dispositivo para los que está seleccionada. Si una aplicación selecciona una paleta en más de un contexto de dispositivo, todos los contextos de dispositivo deben pertenecer al mismo dispositivo físico.

## <a name="cdcselectstockobject"></a><a name="selectstockobject"></a>CDC::SelectStockObject

Selecciona un [objeto CGdiObject](../../mfc/reference/cgdiobject-class.md) que corresponde a uno de los rotuladores, pinceles o fuentes predefinidos.

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>Parámetros

*nIndex*<br/>
Especifica el tipo de objeto de stock deseado. Puede ser uno de los siguientes valores:

- BLACK_BRUSH cepillo negro.

- DKGRAY_BRUSH Pincel gris oscuro.

- GRAY_BRUSH Cepillo gris.

- HOLLOW_BRUSH Cepillo hueco.

- LTGRAY_BRUSH Cepillo gris claro.

- NULL_BRUSH Pincel nulo.

- WHITE_BRUSH cepillo blanco.

- BLACK_PEN pluma negra.

- NULL_PEN pluma nula.

- WHITE_PEN pluma blanca.

- ANSI_FIXED_FONT fuente fija del sistema ANSI.

- ANSI_VAR_FONT fuente del sistema variable ANSI.

- DEVICE_DEFAULT_FONT Fuente dependiente del dispositivo.

- OEM_FIXED_FONT fuente fija dependiente del OEM.

- SYSTEM_FONT La fuente del sistema. De forma predeterminada, Windows utiliza la fuente del sistema para dibujar menús, controles de cuadro de diálogo y otro texto. Es mejor, sin embargo, no confiar en SYSTEM_FONT obtener la fuente utilizada por los diálogos y ventanas. En su `SystemParametersInfo` lugar, utilice la función con el parámetro SPI_GETNONCLIENTMETRICS para recuperar la fuente actual. `SystemParametersInfo`tiene en cuenta el tema actual y proporciona información de fuente para subtítulos, menús y cuadros de diálogo de mensajes.

- SYSTEM_FIXED_FONT La fuente del sistema de ancho fijo utilizada en Windows anterior a la versión 3.0. Este objeto está disponible para la compatibilidad con versiones anteriores de Windows.

- DEFAULT_PALETTE Paleta de colores predeterminada. Esta paleta consta de los 20 colores estáticos de la paleta del sistema.

### <a name="return-value"></a>Valor devuelto

Puntero al `CGdiObject` objeto que se ha reemplazado si la función se realiza correctamente. El objeto real al que se apunta es un [CPen](../../mfc/reference/cpen-class.md), [CBrush](../../mfc/reference/cbrush-class.md), o [CFont](../../mfc/reference/cfont-class.md) objeto. Si la llamada no se realiza correctamente, el valor devuelto es NULL.

## <a name="cdcsetabortproc"></a><a name="setabortproc"></a>CDC::SetAbortProc

Instala el procedimiento de anulación para el trabajo de impresión.

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>Parámetros

*lpfn*<br/>
Un puntero a la función de anulación para instalar como el procedimiento de anulación. Para obtener más información sobre la función de devolución de llamada, vea Función de devolución de [llamada para CDC::SetAbortProc](callback-functions-used-by-mfc.md#setabortproc).

### <a name="return-value"></a>Valor devuelto

Especifica el resultado `SetAbortProc` de la función. Algunos de los siguientes valores son más probables que otros, pero todos son posibles.

- SP_ERROR Error general.

- SP_OUTOFDISK No hay suficiente espacio en disco disponible actualmente para la cola de impresión y no habrá más espacio disponible.

- SP_OUTOFMEMORY No hay suficiente memoria disponible para el spooling.

- SP_USERABORT Usuario terminó el trabajo a través del Administrador de impresión.

### <a name="remarks"></a>Observaciones

Si una aplicación permite que el trabajo de impresión se cancele durante la cola, debe establecer la función de anulación antes de que el trabajo de impresión se inicie con la función miembro [StartDoc.](#startdoc) El Administrador de impresión llama a la función de anulación durante la cola para permitir que la aplicación cancele el trabajo de impresión o procese condiciones de espacio fuera del disco. Si no se establece ninguna función de anulación, se producirá un error en el trabajo de impresión si no hay suficiente espacio en disco para la cola.

Tenga en cuenta que las características de Microsoft Visual C++ simplifican la creación de la función de devolución de llamada pasada a `SetAbortProc`. La dirección que `EnumObjects` se pasa a la función miembro es un puntero a una función exportada con `__declspec(dllexport)` y con la `__stdcall` convención de llamada.

Tampoco es necesario exportar el nombre de función en una instrucción **EXPORTS** en el archivo de definición de módulo de la aplicación. En su lugar, puede utilizar el modificador de función **EXPORT,** como en

**EXPORTACIÓN DE DEVOLUCIÓN DE LLAMADA BOOL** AFunction( **HDC**, `int` **);**

para hacer que el compilador emita el registro de exportación adecuado para exportar por nombre sin alias. Esto funciona para la mayoría de las necesidades. Para algunos casos especiales, como exportar una función ordinal o crear un alias de la exportación, todavía debe utilizar una instrucción **EXPORTS** en un archivo de definición de módulo.

Las interfaces de registro de devolución de llamada ahora son seguras para tipos (debe pasar un puntero de función que apunte al tipo correcto de función para la devolución de llamada específica).

Tenga en cuenta también que todas las funciones de devolución de llamada deben capturar las excepciones de Microsoft Foundation antes de volver a Windows, ya que las excepciones no se pueden producir a través de los límites de devolución de llamada. Para obtener más información acerca de las excepciones, vea el artículo [Excepciones](../../mfc/exception-handling-in-mfc.md).

## <a name="cdcsetarcdirection"></a><a name="setarcdirection"></a>CDC::SetArcDirection

Establece la dirección del dibujo que se utilizará para las funciones de arco y rectángulo.

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>Parámetros

*nArcDirection*<br/>
Especifica la nueva dirección del arco. Este parámetro puede ser cualquiera de los siguientes valores:

- AD_COUNTERCLOCKWISE figuras dibujadas en sentido contrario a las agujas del reloj.

- AD_CLOCKWISE figuras dibujadas en el sentido de las agujas del reloj.

### <a name="return-value"></a>Valor devuelto

Especifica la dirección del arco antiguo, si se realiza correctamente; de lo contrario 0.

### <a name="remarks"></a>Observaciones

La dirección predeterminada es en sentido contrario a las agujas del reloj. La `SetArcDirection` función especifica la dirección en la que se dibujan las siguientes funciones:

|Arc|Circular|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

## <a name="cdcsetattribdc"></a><a name="setattribdc"></a>CDC::SetAttribDC

Llame a esta función para `m_hAttribDC`establecer el contexto del dispositivo de atributo, .

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>Parámetros

*Hdc*<br/>
Un contexto de dispositivo Windows.

### <a name="remarks"></a>Observaciones

Esta función miembro no adjunta `CDC` el contexto del dispositivo al objeto. Solo el contexto del dispositivo `CDC` de salida está asociado a un objeto.

## <a name="cdcsetbkcolor"></a><a name="setbkcolor"></a>CDC::SetBkColor

Establece el color de fondo actual en el color especificado.

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>Parámetros

*crColor*<br/>
Especifica el nuevo color de fondo.

### <a name="return-value"></a>Valor devuelto

El color de fondo anterior como un valor de color RGB. Si se produce un error, el valor devuelto es 0x80000000.

### <a name="remarks"></a>Observaciones

Si el modo de fondo es OPAQUE, el sistema utiliza el color de fondo para rellenar los huecos en líneas con estilo, los huecos entre las líneas sombreadas en los pinceles y el fondo en las celdas de caracteres. El sistema también utiliza el color de fondo al convertir mapas de bits entre contextos de dispositivo sin color y monocromo.

Si el dispositivo no puede mostrar el color especificado, el sistema establece el color de fondo en el color físico más cercano.

## <a name="cdcsetbkmode"></a><a name="setbkmode"></a>CDC::SetBkMode

Establece el modo de fondo.

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>Parámetros

*nBkMode*<br/>
Especifica el modo que se va a establecer. Este parámetro puede ser cualquiera de los siguientes valores:

- El fondo oPACO se rellena con el color de fondo actual antes de dibujar el texto, el pincel sombreado o el lápiz. Este es el modo de fondo predeterminado.

- El fondo TRANSPARENTE no se cambia antes del dibujo.

### <a name="return-value"></a>Valor devuelto

El modo de fondo anterior.

### <a name="remarks"></a>Observaciones

El modo de fondo define si el sistema elimina los colores de fondo existentes en la superficie de dibujo antes de dibujar texto, pinceles sombreados o cualquier estilo de plumilla que no sea una línea sólida.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsetboundsrect"></a><a name="setboundsrect"></a>CDC::SetBoundsRect

Controla la acumulación de información de rectángulo delimitador para el contexto de dispositivo especificado.

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parámetros

*lpRectBounds*<br/>
Apunta a `RECT` una `CRect` estructura u objeto que se utiliza para establecer el rectángulo delimitador. Las cotas rectangulares se indican en coordenadas lógicas. Este parámetro puede ser NULL.

*Banderas*<br/>
Especifica cómo se combinará el nuevo rectángulo con el rectángulo acumulado. Este parámetro puede ser una combinación de los siguientes valores:

- DCB_ACCUMULATE Agregar el rectángulo especificado por *lpRectBounds* al rectángulo delimitador (mediante una operación de unión de rectángulos).

- DCB_DISABLE Desactivar la acumulación de límites.

- DCB_ENABLE Activar la acumulación de límites. (La configuración predeterminada para la acumulación de límites está deshabilitada.)

### <a name="return-value"></a>Valor devuelto

El estado actual del rectángulo delimitador, si la función es correcta. Al igual que *los indicadores*, el valor devuelto puede ser una combinación de **valores DCB_:**

- DCB_ACCUMULATE El rectángulo delimitador no está vacío. Este valor siempre se establecerá.

- DCB_DISABLE acumulación de Límites está desactivada.

- DCB_ENABLE acumulación de límites está activada.

### <a name="remarks"></a>Observaciones

Windows puede mantener un rectángulo delimitador para todas las operaciones de dibujo. La aplicación puede consultar y restablecer este rectángulo. Los límites de dibujo son útiles para invalidar cachés de mapa de bits.

## <a name="cdcsetbrushorg"></a><a name="setbrushorg"></a>CDC::SetBrushOrg

Especifica el origen que GDI asignará al siguiente pincel que la aplicación selecciona en el contexto del dispositivo.

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x (en unidades de dispositivo) del nuevo origen. Este valor debe estar en el rango 0-7.

*y y*<br/>
Especifica la coordenada y (en unidades de dispositivo) del nuevo origen. Este valor debe estar en el rango 0-7.

*Punto*<br/>
Especifica las coordenadas x e y del nuevo origen. Cada valor debe estar en el rango 0-7. Puede pasar una `POINT` estructura `CPoint` o un objeto para este parámetro.

### <a name="return-value"></a>Valor devuelto

El origen anterior del pincel en unidades de dispositivo.

### <a name="remarks"></a>Observaciones

Las coordenadas predeterminadas para el origen del pincel son (0, 0). Para modificar el origen de `UnrealizeObject` un pincel, llame a la función para el `CBrush` objeto, llame `SetBrushOrg`y, a continuación, llame a la `SelectObject` función miembro para seleccionar el pincel en el contexto del dispositivo.

No utilizar `SetBrushOrg` con `CBrush` objetos de stock.

## <a name="cdcsetcoloradjustment"></a><a name="setcoloradjustment"></a>CDC::SetColorAdjustment

Establece los valores de ajuste de color para el contexto del dispositivo utilizando los valores especificados.

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>Parámetros

*lpColorAdjust*<br/>
Apunta a una estructura de datos [COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) que contiene los valores de ajuste de color.

### <a name="return-value"></a>Valor devuelto

Si es correcta, su valor es distinto de cero. En caso contrario, es cero.

### <a name="remarks"></a>Observaciones

Los valores de ajuste de color se utilizan para ajustar `CDC::StretchBlt` el color de entrada del mapa de bits de origen para las llamadas a la función miembro cuando se establece el modo HALFTONE.

## <a name="cdcsetdcbrushcolor"></a><a name="setdcbrushcolor"></a>CDC::SetDCBrushColor

Establece el color actual del pincel del contexto del dispositivo (DC) en el valor de color especificado.

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>Parámetros

*crColor*<br/>
Especifica el nuevo color del pincel.

### <a name="return-value"></a>Valor devuelto

Si la función se realiza correctamente, el valor devuelto especifica el color del pincel de CC anterior como un valor COLORREF.

Si la función no se realiza correctamente, el valor devuelto es CLR_INVALID.

### <a name="remarks"></a>Observaciones

Este método emula la funcionalidad de la función [SetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-setdcbrushcolor), como se describe en el Windows SDK.

## <a name="cdcsetdcpencolor"></a><a name="setdcpencolor"></a>CDC::SetDCPenColor

Establece el color actual del lápiz de contexto de dispositivo (DC) en el valor de color especificado.

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>Parámetros

*crColor*<br/>
Especifica el nuevo color del lápiz.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función miembro utiliza la función de Win32 [SetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-setdcpencolor), como se describe en el Windows SDK.

## <a name="cdcsetgraphicsmode"></a><a name="setgraphicsmode"></a>CDC::SetGraphicsMode

Establece el modo de gráficos para el contexto de dispositivo especificado.

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>Parámetros

*Imode*<br/>
Especifica el modo de gráficos. Para obtener una lista de los valores que puede tomar este parámetro, vea [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

### <a name="return-value"></a>Valor devuelto

Devuelve el modo de gráficos antiguo en caso de éxito.

Devuelve 0 en caso de error. Para obtener información de error extendida, llame a [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Observaciones

Este método ajusta la función [DeSSetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode)de Windows GDI .

## <a name="cdcsetlayout"></a><a name="setlayout"></a>CDC::SetLayout

Llame a esta función miembro para cambiar el diseño del texto y los gráficos de un contexto de dispositivo de derecha a izquierda, el diseño estándar para referencias culturales como árabe y hebreo.

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>Parámetros

*dwLayout*<br/>
Diseño de contexto de dispositivo y marcas de control de mapa de bits. Puede ser una combinación de los siguientes valores.

|Value|Significado|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|Deshabilita cualquier reflexión para las llamadas a [CDC::BitBlt](#bitblt) y [CDC::StretchBlt](#stretchblt).|
|LAYOUT_RTL|Establece el diseño horizontal predeterminado para que sea de derecha a izquierda.|
|LAYOUT_LTR|Establece el diseño predeterminado que se debe de izquierda a derecha.|

### <a name="return-value"></a>Valor devuelto

Si se realiza correctamente, el diseño anterior del contexto del dispositivo.

Si no tiene éxito, GDI_ERROR. Para obtener información de error extendida, llame a [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Observaciones

Normalmente, no `SetLayout` se llama para una ventana. En su lugar, puede controlar el diseño de derecha a izquierda en una ventana estableciendo los estilos de [ventana extendidos](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) como WS_EX_RTLREADING. Un contexto de dispositivo, como una impresora o un metarchivo, no hereda este diseño. La única manera de establecer el contexto del dispositivo para `SetLayout`un diseño de derecha a izquierda es llamando a .

Si se llama a `SetLayout` **SetLayout(LAYOUT_RTL** ), cambia automáticamente el modo de asignación a MM_ISOTROPIC. Como resultado, una llamada posterior a [GetMapMode](#getmapmode) devolverá MM_ISOTROPIC en lugar de MM_TEXT.

En algunos casos, como con muchos mapas de bits, es posible que desee conservar el diseño de izquierda a derecha. En estos casos, represente `BitBlt` `StretchBlt`la imagen llamando o , luego establezca la marca de control de mapa de bits para *dwLayout* en LAYOUT_BITMAPORIENTATIONPRESERVED.

Una vez que se cambia el diseño con el LAYOUT_RTL marca, los indicadores que normalmente especifican a la derecha o a la izquierda se invierten. Para evitar confusiones, es posible que desee definir nombres alternativos para las marcas estándar. Para obtener una lista de nombres de marcas alternativas sugeridos, vea [SetLayout](/windows/win32/api/wingdi/nf-wingdi-setlayout) en el Windows SDK.

## <a name="cdcsetmapmode"></a><a name="setmapmode"></a>CDC::SetMapMode

Establece el modo de asignación.

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>Parámetros

*nMapMode*<br/>
Especifica el nuevo modo de asignación. Puede ser cualquiera de los siguientes valores:

- MM_ANISOTROPIC unidades lógicas se convierten en unidades arbitrarias con ejes de escala arbitraria. Establecer el modo de asignación en MM_ANISOTROPIC no cambia la configuración actual de la ventana o ventana gráfica. Para cambiar las unidades, la orientación y la escala, llame a las funciones miembro [SetWindowExt](#setwindowext) y [SetViewportExt.](#setviewportext)

- MM_HIENGLISH Cada unidad lógica se convierte en 0,001 pulgadas. X positivo está a la derecha; positivo y está arriba.

- MM_HIMETRIC Cada unidad lógica se convierte en 0,01 milímetros. X positivo está a la derecha; positivo y está arriba.

- MM_ISOTROPIC unidades lógicas se convierten en unidades arbitrarias con ejes igualmente escalados; es decir, 1 unidad a lo largo del eje X es igual a 1 unidad a lo largo del eje Y. Utilice `SetWindowExt` las `SetViewportExt` funciones miembro y para especificar las unidades deseadas y la orientación de los ejes. GDI realiza los ajustes necesarios para garantizar que las unidades x e y sigan siendo del mismo tamaño.

- MM_LOENGLISH Cada unidad lógica se convierte en 0,01 pulgadas. X positivo está a la derecha; positivo y está arriba.

- MM_LOMETRIC Cada unidad lógica se convierte en 0,1 milímetros. X positivo está a la derecha; positivo y está arriba.

- MM_TEXT Cada unidad lógica se convierte en 1 píxel del dispositivo. X positivo está a la derecha; positivo y está abajo.

- MM_TWIPS Cada unidad lógica se convierte en 1/20 de un punto. (Debido a que un punto es de 1/72 pulgadas, un twip es 1/1440 pulgadas.) X positivo está a la derecha; positivo y está arriba.

### <a name="return-value"></a>Valor devuelto

El modo de asignación anterior.

### <a name="remarks"></a>Observaciones

El modo de asignación define la unidad de medida utilizada para convertir unidades lógicas en unidades de dispositivo; también define la orientación de los ejes X e Y del dispositivo. GDI utiliza el modo de asignación para convertir coordenadas lógicas en las coordenadas de dispositivo adecuadas. El modo MM_TEXT permite que las aplicaciones funcionen en píxeles de dispositivo, donde 1 unidad es igual a 1 píxel. El tamaño físico de un píxel varía de un dispositivo a dispositivo.

Los modos MM_HIENGLISH, MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC y MM_TWIPS son útiles para aplicaciones que deben dibujar en unidades físicamente significativas (como pulgadas o milímetros). El modo MM_ISOTROPIC garantiza una relación de aspecto 1:1, que es útil cuando es importante conservar la forma exacta de una imagen. El modo MM_ANISOTROPIC permite ajustar las coordenadas x e y de forma independiente.

> [!NOTE]
> Si llama a [SetLayout](#setlayout) para cambiar el controlador de dominio `SetLayout` (contexto del dispositivo) a diseño de derecha a izquierda, cambia automáticamente el modo de asignación a MM_ISOTROPIC.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetmapperflags"></a><a name="setmapperflags"></a>CDC::SetMapperFlags

Cambia el método utilizado por el asignador de fuentes cuando convierte una fuente lógica en una fuente física.

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>Parámetros

*dwFlag*<br/>
Especifica si el asignador de fuentes intenta hacer coincidir el alto y el ancho de aspecto de una fuente con el dispositivo. Cuando se ASPECT_FILTERING este valor, el asignador selecciona solo las fuentes cuyo aspecto x y y coinciden exactamente con las del dispositivo especificado.

### <a name="return-value"></a>Valor devuelto

El valor anterior de la marca font-mapper.

### <a name="remarks"></a>Observaciones

Una aplicación `SetMapperFlags` puede utilizar para hacer que el asignador de fuentes intente elegir solo una fuente física que coincida exactamente con la relación de aspecto del dispositivo especificado.

Una aplicación que solo utiliza `SetMapperFlags` fuentes ráster puede utilizar la función para asegurarse de que la fuente seleccionada por el asignador de fuentes es atractiva y legible en el dispositivo especificado. Las aplicaciones que usan fuentes escalables (TrueType) normalmente no usan `SetMapperFlags`.

Si ninguna fuente física tiene una relación de aspecto que coincida con la especificación de la fuente lógica, GDI elige una nueva relación de aspecto y selecciona una fuente que coincida con esta nueva relación de aspecto.

## <a name="cdcsetmiterlimit"></a><a name="setmiterlimit"></a>CDC::SetMiterLimit

Establece el límite para la longitud de las uniones de inglete para el contexto del dispositivo.

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>Parámetros

*fMiterLimit*<br/>
Especifica el nuevo límite de inglete para el contexto del dispositivo.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La longitud de inglete se define como la distancia desde la intersección de los muros de línea en el interior de la unión hasta la intersección de los muros de línea en el exterior de la unión. El límite de inglete es la relación máxima permitida de la longitud de inglete con el ancho de línea. El límite de inglete predeterminado es 10.0.

## <a name="cdcsetoutputdc"></a><a name="setoutputdc"></a>CDC::SetOutputDC

Llame a esta función miembro `m_hDC`para establecer el contexto del dispositivo de salida, .

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>Parámetros

*Hdc*<br/>
Un contexto de dispositivo Windows.

### <a name="remarks"></a>Observaciones

Esta función miembro solo se puede llamar cuando `CDC` no se ha asociado un contexto de dispositivo al objeto. Esta función `m_hDC` miembro establece pero no `CDC` adjunta el contexto del dispositivo al objeto.

## <a name="cdcsetpixel"></a><a name="setpixel"></a>CDC::SetPixel

Establece el píxel en el punto especificado en la aproximación más cercana del color especificado por *crColor*.

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x lógica del punto que se va a establecer.

*y y*<br/>
Especifica la coordenada y lógica del punto que se va a establecer.

*crColor*<br/>
Un valor RGB COLORREF que especifica el color utilizado para pintar el punto. Consulte [COLORREF](/windows/win32/gdi/colorref) en el Windows SDK para obtener una descripción de este valor.

*Punto*<br/>
Especifica las coordenadas x e y lógicas del punto que se va a establecer. Puede pasar una `POINT` estructura `CPoint` o un objeto para este parámetro.

### <a name="return-value"></a>Valor devuelto

Un valor RGB para el color en el que se pinta realmente el punto. Este valor puede ser diferente del especificado por *crColor* si se utiliza una aproximación de ese color. Si se produce un error en la función (si el punto está fuera de la región de recorte), el valor devuelto es -1.

### <a name="remarks"></a>Observaciones

El punto debe estar en la región de recorte. Si el punto no está en la región de recorte, la función no hace nada.

No todos los dispositivos admiten la función `SetPixel`. Para determinar si `SetPixel`un dispositivo `GetDeviceCaps` admite , llame a la función miembro con el índice RASTERCAPS y compruebe el valor devuelto para el RC_BITBLT marca.

## <a name="cdcsetpixelv"></a><a name="setpixelv"></a>CDC::SetPixelV

Establece el píxel en las coordenadas especificadas en la aproximación más cercana del color especificado.

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x, en unidades lógicas, del punto que se va a establecer.

*y y*<br/>
Especifica la coordenada y, en unidades lógicas, del punto que se va a establecer.

*crColor*<br/>
Especifica el color que se utilizará para pintar el punto.

*Punto*<br/>
Especifica las coordenadas x e y lógicas del punto que se va a establecer. Puede pasar una estructura de datos [POINT](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El punto debe estar tanto en la región de recorte como en la parte visible de la superficie del dispositivo. No todos los dispositivos admiten la función miembro. Para obtener más información, vea `CDC::GetDeviceCaps` la capacidad de RC_BITBLT en la función miembro. `SetPixelV`es más `SetPixel` rápido que porque no necesita devolver el valor de color del punto realmente pintado.

## <a name="cdcsetpolyfillmode"></a><a name="setpolyfillmode"></a>CDC::SetPolyFillMode

Establece el modo de relleno de polígonos.

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>Parámetros

*nPolyFillMode*<br/>
Especifica el nuevo modo de llenado. Este valor puede ser ALTERNATE o WINDING. El modo predeterminado establecido en Windows es ALTERNATE.

### <a name="return-value"></a>Valor devuelto

El modo de llenado anterior, si se realiza correctamente; de lo contrario 0.

### <a name="remarks"></a>Observaciones

Cuando el modo de relleno de polígonos es ALTERNATE, el sistema rellena el área entre los lados de polígono sin números impares e pares en cada línea de exploración. Es decir, el sistema llena el área entre el primer y el segundo lado, entre el tercer y el cuarto lado, y así sucesivamente. Este modo es el predeterminado.

Cuando el modo de relleno de polígonos es WINDING, el sistema utiliza la dirección en la que se dibujó una figura para determinar si se debe rellenar un área. Cada segmento de línea de un polígono se dibuja en el sentido de las agujas del reloj o en el sentido contrario a las agujas del reloj. Cada vez que una línea imaginaria dibujada desde un área cerrada hasta el exterior de una figura pasa a través de un segmento de línea en el sentido de las agujas del reloj, se incrementa un recuento. Cuando la línea pasa a través de un segmento de línea en sentido contrario a las agujas del reloj, el recuento se reduce. El área se rellena si el recuento es distinto de cero cuando la línea alcanza el exterior de la figura.

## <a name="cdcsetrop2"></a><a name="setrop2"></a>CDC::SetROP2

Establece el modo de dibujo actual.

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>Parámetros

*nDrawMode*<br/>
Especifica el nuevo modo de dibujo. Puede ser cualquiera de los siguientes valores:

- R2_BLACK Pixel siempre es negro.

- R2_WHITE Pixel siempre es blanco.

- R2_NOP Píxel permanece inalterado.

- R2_NOT Pixel es el inverso del color de la pantalla.

- R2_COPYPEN Pixel es el color del lápiz.

- R2_NOTCOPYPEN Pixel es el inverso del color del lápiz.

- R2_MERGEPENNOT Píxel es una combinación del color del lápiz y la inversa del color de la pantalla (píxel final (no píxel de pantalla) o lápiz).

- R2_MASKPENNOT Pixel es una combinación de los colores comunes tanto al lápiz como a la inversa de la pantalla (píxel final (no píxel de pantalla) Y lápiz).

- R2_MERGENOTPEN Pixel es una combinación del color de la pantalla y la inversa del color del lápiz (píxel final (NO pluma) O píxel de la pantalla).

- R2_MASKNOTPEN Pixel es una combinación de los colores comunes tanto a la pantalla como a la inversa del lápiz (píxel final (NO pen) Y píxel de pantalla).

- R2_MERGEPEN Píxel es una combinación del color del lápiz y el color de la pantalla (píxel final , lápiz o píxel de pantalla).

- R2_NOTMERGEPEN Píxel es el inverso del color R2_MERGEPEN (píxel final : NOT (lápiz o píxel de pantalla)).

- R2_MASKPEN Pixel es una combinación de los colores comunes tanto al lápiz como a la pantalla (píxel final , lápiz y píxel de pantalla).

- R2_NOTMASKPEN Pixel es el color inverso del R2_MASKPEN (píxel final : NOT (pen y píxel de pantalla)).

- R2_XORPEN Píxel es una combinación de los colores que están en el lápiz o en la pantalla, pero no en ambos (píxel final , pen XOR píxel de pantalla).

- R2_NOTXORPEN Pixel es el color inverso del R2_XORPEN (píxel final no (píxel de pantalla XOR de lápiz)).

### <a name="return-value"></a>Valor devuelto

El modo de dibujo anterior.

Puede ser cualquiera de los valores especificados en el Windows SDK.

### <a name="remarks"></a>Observaciones

El modo de dibujo especifica cómo se combinan los colores del lápiz y el interior de los objetos rellenos con el color que ya está en la superficie de visualización.

El modo de dibujo es solo para dispositivos ráster; no se aplica a los dispositivos vectoriales. Los modos de dibujo son códigos de operación ráster binarios que representan todas las combinaciones booleanas posibles de dos variables, utilizando los operadores binarios AND, OR y XOR (OR exclusivo) y la operación unaria NOT.

## <a name="cdcsetstretchbltmode"></a><a name="setstretchbltmode"></a>CDC::SetStretchBltMode

Establece el modo de estiramiento `StretchBlt` de mapa de bits para la función miembro.

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>Parámetros

*nStretchMode*<br/>
Especifica el modo de estiramiento. Puede ser cualquiera de los siguientes valores:

|Value|Descripción|
|-----------|-----------------|
|BLACKONWHITE|Realiza una operación AND booleana utilizando los valores de color para los píxeles eliminados y existentes. Si el mapa de bits es un mapa de bits monocromo, este modo conserva los píxeles negros a expensas de los píxeles blancos.|
|COLORONCOLOR|Elimina los píxeles. Este modo elimina todas las líneas eliminadas de píxeles sin intentar conservar su información.|
|Semitonos|Asigna píxeles del rectángulo de origen a bloques de píxeles en el rectángulo de destino. El color medio sobre el bloque de destino de píxeles se aproxima al color de los píxeles de origen.|
||Después de establecer el modo de estiramiento HALFTONE, una aplicación debe llamar a la función de Win32 [SetBrushOrgEx](/windows/win32/api/wingdi/nf-wingdi-setbrushorgex) para establecer el origen del pincel. Si no lo hace, se produce una desalineación del pincel.|
|STRETCH_ANDSCANS|**Windows 95/98**: Igual que BLACKONWHITE|
|STRETCH_DELETESCANS|**Windows 95/98**: Igual que COLORONCOLOR|
|STRETCH_HALFTONE|**Windows 95/98**: Igual que HALFTONE.|
|STRETCH_ORSCANS|**Windows 95/98**: Igual que WHITEONBLACK|
|WHITEONBLACK|Realiza una operación OR booleana utilizando los valores de color para los píxeles eliminados y existentes. Si el mapa de bits es un mapa de bits monocromo, este modo conserva los píxeles blancos a expensas de los píxeles negros.|

### <a name="return-value"></a>Valor devuelto

El modo de estiramiento anterior. Puede ser STRETCH_ANDSCANS, STRETCH_DELETESCANS o STRETCH_ORSCANS.

### <a name="remarks"></a>Observaciones

El modo de estiramiento de mapa de bits define cómo se quita la información de los mapas de bits que se comprimen mediante la función.

Los modos BLACKONWHITE ( STRETCH_ANDSCANS) y WHITEONBLACK (STRETCH_ORSCANS) se utilizan normalmente para conservar los píxeles en primer plano en mapas de bits monocromos. El modo COLORONCOLOR ( STRETCH_DELETESCANS) se utiliza normalmente para conservar el color en los mapas de bits de color.

El modo HALFTONE requiere más procesamiento de la imagen de origen que los otros tres modos; es más lento que los demás, pero produce imágenes de mayor calidad. Tenga en `SetBrushOrgEx` cuenta también que debe llamarse después de configurar el modo HALFTONE para evitar la desalineación del pincel.

Es posible que también haya modos de estiramiento adicionales disponibles en función de las capacidades del controlador del dispositivo.

## <a name="cdcsettextalign"></a><a name="settextalign"></a>CDC::SetTextAlign

Establece los indicadores de alineación de texto.

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>Parámetros

*nFlags*<br/>
Especifica los indicadores de alineación de texto. Las marcas especifican la relación entre un punto y un rectángulo que limita el texto. El punto puede ser la posición actual o las coordenadas especificadas por una función de salida de texto. El rectángulo que limita el texto se define mediante las celdas de caracteres adyacentes en la cadena de texto. El *nFlags* parámetro puede ser uno o más indicadores de las tres categorías siguientes. Elija solo una marca de cada categoría. La primera categoría afecta a la alineación del texto en la dirección x:

- TA_CENTER Alinea el punto con el centro horizontal del rectángulo delimitador.

- TA_LEFT Alinea el punto con el lado izquierdo del rectángulo delimitador. Esta es la configuración predeterminada.

- TA_RIGHT Alinea el punto con el lado derecho del rectángulo delimitador.

La segunda categoría afecta a la alineación del texto en la dirección Y:

- TA_BASELINE Alinea el punto con la línea base de la fuente elegida.

- TA_BOTTOM Alinea el punto con la parte inferior del rectángulo delimitador.

- TA_TOP Alinea el punto con la parte superior del rectángulo delimitador. Esta es la configuración predeterminada.

La tercera categoría determina si la posición actual se actualiza cuando se escribe el texto:

- TA_NOUPDATECP No actualiza la posición actual después de cada llamada a una función de salida de texto. Esta es la configuración predeterminada.

- TA_UPDATECP Actualiza la posición x actual después de cada llamada a una función de salida de texto. La nueva posición está en el lado derecho del rectángulo delimitador para el texto. Cuando se establece esta marca, se omiten `TextOut` las coordenadas especificadas en las llamadas a la función miembro.

### <a name="return-value"></a>Valor devuelto

La configuración de alineación de texto anterior, si se realiza correctamente. El byte de orden inferior contiene la configuración horizontal y el byte de orden superior contiene la configuración vertical; de lo contrario 0.

### <a name="remarks"></a>Observaciones

Las `TextOut` `ExtTextOut` funciones miembro y usan estas marcas al colocar una cadena de texto en una pantalla o dispositivo. Las marcas especifican la relación entre un punto específico y un rectángulo que limita el texto. Las coordenadas de este punto se `TextOut` pasan como parámetros a la función miembro. El rectángulo que limita el texto está formado por las celdas de caracteres adyacentes en la cadena de texto.

## <a name="cdcsettextcharacterextra"></a><a name="settextcharacterextra"></a>CDC::SetTextCharacterExtra

Establece la cantidad de espaciado entre caracteres.

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>Parámetros

*nCharExtra*<br/>
Especifica la cantidad de espacio adicional (en unidades lógicas) que se agregará a cada carácter. Si el modo de `MM_TEXT`asignación actual no es , *nCharExtra* se transforma y se redondea al píxel más cercano.

### <a name="return-value"></a>Valor devuelto

La cantidad del espaciado entre caracteres anterior.

### <a name="remarks"></a>Observaciones

GDI agrega este espaciado a cada carácter, incluidos los caracteres de interrupción, cuando escribe una línea de texto en el contexto del dispositivo. El valor predeterminado para la cantidad de espaciado entre caracteres es 0.

## <a name="cdcsettextcolor"></a><a name="settextcolor"></a>CDC::SetTextColor

Establece el color del texto en el color especificado.

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>Parámetros

*crColor*<br/>
Especifica el color del texto como un valor de color RGB.

### <a name="return-value"></a>Valor devuelto

Un valor RGB para el color de texto anterior.

### <a name="remarks"></a>Observaciones

El sistema utilizará este color de texto al escribir texto en este contexto de dispositivo y también al convertir mapas de bits entre contextos de dispositivo sin color y monocromo.

Si el dispositivo no puede representar el color especificado, el sistema establece el color del texto en el color físico más cercano. El color de fondo de un `SetBkColor` `SetBkMode` carácter se especifica mediante las funciones miembro y.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsettextjustification"></a><a name="settextjustification"></a>CDC::SetTextJustification

Agrega espacio a los caracteres de interrupción de una cadena.

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>Parámetros

*nBreakExtra*<br/>
Especifica el espacio adicional total que se agregará a la línea de texto (en unidades lógicas). Si el modo de `MM_TEXT`asignación actual no es , el valor dado por este parámetro se convierte al modo de asignación actual y se redondea a la unidad de dispositivo más cercana.

*nBreakCount*<br/>
Especifica el número de caracteres de interrupción en la línea.

### <a name="return-value"></a>Valor devuelto

Uno si la función es correcta; de lo contrario 0.

### <a name="remarks"></a>Observaciones

Una aplicación puede `GetTextMetrics` utilizar las funciones miembro para recuperar el carácter de interrupción de una fuente.

Después `SetTextJustification` de llamar a la función miembro, una `TextOut`llamada a una función de salida de texto (como ) distribuye el espacio adicional especificado uniformemente entre el número especificado de caracteres de interrupción. El carácter de rotura suele ser el carácter de espacio (ASCII 32), pero puede definirse mediante una fuente como algún otro carácter.

La función `GetTextExtent` miembro se `SetTextJustification`utiliza normalmente con . `GetTextExtent`calcula el ancho de una línea determinada antes de la alineación. Una aplicación puede determinar cuánto espacio especificar en el *nBreakExtra* `GetTextExtent` parámetro restando el valor devuelto por el ancho de la cadena después de la alineación.

La `SetTextJustification` función se puede utilizar para alinear una línea que contiene varias corridas en diferentes fuentes. En este caso, la línea debe crearse por etapas alineando y escribiendo cada ejecución por separado.

Dado que pueden producirse errores de redondeo durante la alineación, el sistema mantiene un término de error en ejecución que define el error actual. Al alinear una línea que `GetTextExtent` contiene varias ejecuciones, utiliza automáticamente este término de error cuando calcula la extensión de la siguiente ejecución. Esto permite que la función de salida de texto mezcle el error en la nueva ejecución.

Después de que cada línea se haya alineado, este término de error debe borrarse para evitar que se incorpore a la siguiente línea. El término se puede `SetTextJustification` borrar llamando a *nBreakExtra* establecido en 0.

## <a name="cdcsetviewportext"></a><a name="setviewportext"></a>CDC::SetViewportExt

Establece las extensiones x e y de la ventana gráfica del contexto del dispositivo.

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>Parámetros

*Cx*<br/>
Especifica la extensión x de la ventana gráfica (en unidades de dispositivo).

*Cy*<br/>
Especifica la extensión y de la ventana gráfica (en unidades de dispositivo).

*Tamaño*<br/>
Especifica las extensiones x e y de la ventana gráfica (en unidades de dispositivo).

### <a name="return-value"></a>Valor devuelto

Las extensiones anteriores de la ventana gráfica como un [CSize](../../atl-mfc-shared/reference/csize-class.md) objeto. Cuando se produce un error, las coordenadas `CSize` x e y del objeto devuelto se establecen en 0.

### <a name="remarks"></a>Observaciones

La ventana gráfica, junto con la ventana de contexto de dispositivo, define cómo GDI asigna puntos en el sistema de coordenadas lógicas a puntos en el sistema de coordenadas del dispositivo real. En otras palabras, definen cómo GDI convierte las coordenadas lógicas en coordenadas de dispositivo.

Cuando se establecen los siguientes `SetWindowExt` `SetViewportExt` modos de asignación, se realizan llamadas y se omiten:

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

Cuando se establece MM_ISOTROPIC modo, `SetWindowExt` una aplicación debe `SetViewportExt`llamar a la función miembro antes de llamar a .

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetviewportorg"></a><a name="setviewportorg"></a>CDC::SetViewportOrg

Establece el origen de la ventana gráfica del contexto del dispositivo.

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x (en unidades de dispositivo) del origen de la ventana gráfica. El valor debe estar dentro del rango del sistema de coordenadas del dispositivo.

*y y*<br/>
Especifica la coordenada y (en unidades de dispositivo) del origen de la ventana gráfica. El valor debe estar dentro del rango del sistema de coordenadas del dispositivo.

*Punto*<br/>
Especifica el origen de la ventana gráfica. Los valores deben estar dentro del rango del sistema de coordenadas del dispositivo. Puede pasar una `POINT` estructura `CPoint` o un objeto para este parámetro.

### <a name="return-value"></a>Valor devuelto

El origen anterior de la ventana gráfica `CPoint` (en coordenadas de dispositivo) como un objeto.

### <a name="remarks"></a>Observaciones

La ventana gráfica, junto con la ventana de contexto de dispositivo, define cómo GDI asigna puntos en el sistema de coordenadas lógicas a puntos en el sistema de coordenadas del dispositivo real. En otras palabras, definen cómo GDI convierte las coordenadas lógicas en coordenadas de dispositivo.

El origen de la ventana gráfica marca el punto del sistema de coordenadas del dispositivo `SetWindowOrg` al que GDI asigna el origen de la ventana, un punto en el sistema de coordenadas lógicas especificado por la función miembro. GDI asigna todos los demás puntos siguiendo el mismo proceso necesario para asignar el origen de la ventana al origen de la ventana gráfica. Por ejemplo, todos los puntos de un círculo alrededor del punto en el origen de la ventana estarán en un círculo alrededor del punto en el origen de la ventana gráfica. Del mismo modo, todos los puntos de una línea que pasa a través del origen de la ventana estarán en una línea que pasa a través del origen de la ventana gráfica.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindowext"></a><a name="setwindowext"></a>CDC::SetWindowExt

Establece las extensiones x e y de la ventana asociada al contexto del dispositivo.

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>Parámetros

*Cx*<br/>
Especifica la extensión x (en unidades lógicas) de la ventana.

*Cy*<br/>
Especifica la extensión y (en unidades lógicas) de la ventana.

*Tamaño*<br/>
Especifica las extensiones x e y (en unidades lógicas) de la ventana.

### <a name="return-value"></a>Valor devuelto

Las extensiones anteriores de la ventana `CSize` (en unidades lógicas) como un objeto. Si se produce un error, las coordenadas `CSize` x e y del objeto devuelto se establecen en 0.

### <a name="remarks"></a>Observaciones

La ventana, junto con la ventana gráfica de contexto de dispositivo, define cómo GDI asigna puntos en el sistema de coordenadas lógicas a los puntos del sistema de coordenadas del dispositivo.

Cuando se establecen los siguientes `SetWindowExt` `SetViewportExt` modos de asignación, se omiten las llamadas y las funciones:

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

Cuando se establece MM_ISOTROPIC modo, `SetWindowExt` una aplicación `SetViewportExt`debe llamar a la función miembro antes de llamar a .

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindoworg"></a><a name="setwindoworg"></a>CDC::SetWindowOrg

Establece el origen de la ventana del contexto del dispositivo.

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x lógica del nuevo origen de la ventana.

*y y*<br/>
Especifica la coordenada y lógica del nuevo origen de la ventana.

*Punto*<br/>
Especifica las coordenadas lógicas del nuevo origen de la ventana. Puede pasar una `POINT` estructura `CPoint` o un objeto para este parámetro.

### <a name="return-value"></a>Valor devuelto

El origen anterior de `CPoint` la ventana como un objeto.

### <a name="remarks"></a>Observaciones

La ventana, junto con la ventana gráfica de contexto de dispositivo, define cómo GDI asigna puntos en el sistema de coordenadas lógicas a los puntos del sistema de coordenadas del dispositivo.

El origen de la ventana marca el punto en el sistema de coordenadas lógicas desde `SetWindowOrg` el que GDI asigna el origen de la ventana gráfica, un punto en el sistema de coordenadas del dispositivo especificado por la función. GDI asigna todos los demás puntos siguiendo el mismo proceso necesario para asignar el origen de la ventana al origen de la ventana gráfica. Por ejemplo, todos los puntos de un círculo alrededor del punto en el origen de la ventana estarán en un círculo alrededor del punto en el origen de la ventana gráfica. Del mismo modo, todos los puntos de una línea que pasa a través del origen de la ventana estarán en una línea que pasa a través del origen de la ventana gráfica.

## <a name="cdcsetworldtransform"></a><a name="setworldtransform"></a>CDC::SetWorldTransform

Establece una transformación lineal bidimensional entre el espacio mundial y el espacio de página para el contexto de dispositivo especificado. Esta transformación se puede utilizar para escalar, rotar, cortar o traducir la salida de gráficos.

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>Parámetros

*rXform*<br/>
Referencia a una estructura [XFORM](/windows/win32/api/wingdi/ns-wingdi-xform) que contiene los datos de transformación.

### <a name="return-value"></a>Valor devuelto

Devuelve un valor distinto de cero en caso de éxito.

Devuelve 0 en caso de error.

Para obtener información de error extendida, llame a [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Observaciones

Este método ajusta la función GDI de Windows [SetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-setworldtransform).

## <a name="cdcstartdoc"></a><a name="startdoc"></a>CDC::StartDoc

Informa al controlador de dispositivo de que se `StartPage` está `EndPage` iniciando un nuevo trabajo de `EndDoc` impresión y que todas las llamadas y llamadas posteriores deben ponerse en cola en el mismo trabajo hasta que se produzca una llamada.

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>Parámetros

*lpDocInfo*<br/>
Apunta a una estructura [DOCINFO](/windows/win32/api/wingdi/ns-wingdi-docinfow) que contiene el nombre del archivo de documento y el nombre del archivo de salida.

*lpszDocName*<br/>
Puntero a una cadena que contiene el nombre del archivo de documento.

### <a name="return-value"></a>Valor devuelto

Si la función se realiza correctamente, el valor devuelto es mayor que cero. Este valor es el identificador de trabajo de impresión para el documento.

Si se produce un error en la función, el valor devuelto es menor o igual que cero.

### <a name="remarks"></a>Observaciones

Esto garantiza que los documentos de más de una página no se intercalarán con otros trabajos.

Para las versiones 3.1 y posteriores de Windows, esta función reemplaza el escape de la impresora STARTDOC. El uso de esta función garantiza que los documentos que contienen más de una página no se intercalan con otros trabajos de impresión.

`StartDoc`no debe utilizarse dentro de los metarchivos.

### <a name="example"></a>Ejemplo

Este fragmento de código obtiene la impresora predeterminada, abre un trabajo de impresión y pone en cola una página con "¡Hola, mundo!" en él. Dado que el texto impreso por este código no se escala a las unidades lógicas de la impresora, el texto de salida puede estar en letras tan pequeñas que el resultado es ilegible. Las funciones de `SetMapMode`escalado `SetViewportOrg`CDC, como , , y `SetWindowExt`, se pueden utilizar para corregir el escalado.

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

## <a name="cdcstartpage"></a><a name="startpage"></a>CDC::StartPage

Llame a esta función miembro para preparar el controlador de impresora para recibir datos.

```
int StartPage();
```

### <a name="return-value"></a>Valor devuelto

Mayor o igual que 0 si la función es correcta, o un valor negativo si se produjo un error.

### <a name="remarks"></a>Observaciones

`StartPage`sustituye a los escapes NEWFRAME y BANDINFO.

Para obtener información general sobre la secuencia de llamadas de impresión, consulte la función miembro [StartDoc.](#startdoc)

El sistema deshabilita `ResetDC` la función `StartPage` `EndPage`miembro entre las llamadas a y .

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC::StartDoc](#startdoc).

## <a name="cdcstretchblt"></a><a name="stretchblt"></a>CDC::StretchBlt

Copia un mapa de bits de un rectángulo de origen en un rectángulo de destino, estirando o comprimiendo el mapa de bits si es necesario para ajustarse a las dimensiones del rectángulo de destino.

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada X (en unidades lógicas) de la esquina superior izquierda del rectángulo de destino.

*y y*<br/>
Especifica la coordenada Y (en unidades lógicas) de la esquina superior izquierda del rectángulo de destino.

*nAncho*<br/>
Especifica el ancho (en unidades lógicas) del rectángulo de destino.

*nAltura*<br/>
Especifica el alto (en unidades lógicas) del rectángulo de destino.

*pSrcDC*<br/>
Especifica el contexto de dispositivo de origen.

*xSrc*<br/>
Especifica la coordenada X (en unidades lógicas) de la esquina superior izquierda del rectángulo de origen.

*ySrc*<br/>
Especifica la coordenada Y (en unidades lógicas) de la esquina superior izquierda del rectángulo de origen.

*nSrcWidth*<br/>
Especifica el ancho (en unidades lógicas) del rectángulo de origen.

*nSrcHeight*<br/>
Especifica el alto (en unidades lógicas) del rectángulo de origen.

*dwRop*<br/>
Especifica la operación de trama que se va a realizar. Los códigos de operación de trama definen cómo combina GDI los colores en las operaciones de salida que implican un pincel actual, un posible mapa de bits de origen y un mapa de bits de destino. Este parámetro puede tener uno de los valores siguientes:

- BLACKNESS Convierte toda la salida en negro.

- DSTINVERT invierte el mapa de bits de destino.

- MERGECOPY Combina el patrón y el mapa de bits de origen mediante el operador BOOLEAN AND.

- MERGEPAINT Combina el mapa de bits de origen invertido con el mapa de bits de destino mediante el operador OR booleano.

- NOTSRCCOPY Copia el mapa de bits de origen invertido en el destino.

- NOTSRCERASE Invierte el resultado de combinar los mapas de bits de destino y origen mediante el operador OR booleano.

- PATCOPY Copia el patrón en el mapa de bits de destino.

- PATINVERT Combina el mapa de bits de destino con el patrón mediante el operador XOR booleano.

- PATPAINT Combina el mapa de bits de origen invertido con el patrón mediante el operador OR booleano. Combina el resultado de esta operación con el mapa de bits de destino mediante el operador booleano OR.

- SRCAND Combina los píxeles de los mapas de bits de destino y origen mediante el operador AND booleano.

- SRCCOPY Copia el mapa de bits de origen en el mapa de bits de destino.

- SRCERASE Invierte el mapa de bits de destino y combina el resultado con el mapa de bits de origen mediante el operador AND booleano.

- SRCINVERT Combina los píxeles de los mapas de bits de destino y de origen mediante el operador XOR booleano.

- SRCPAINT Combina los píxeles de los mapas de bits de destino y origen mediante el operador OR booleano.

- WHITENESS Convierte toda la salida en blanco.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si se dibuja el mapa de bits; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La función emplea el modo de ajuste del contexto de dispositivo de destino (establecido por `SetStretchBltMode`) para determinar cómo estirar o comprimir el mapa de bits.

La `StretchBlt` función mueve el mapa de bits desde el dispositivo de origen dado por *pSrcDC* al dispositivo de destino representado por el objeto de contexto de dispositivo cuya función miembro se llama. Los parámetros *xSrc*, *ySrc*, *nSrcWidth*y *nSrcHeight* definen la esquina superior izquierda y las dimensiones del rectángulo de origen. Los parámetros *x*, *y*, *nWidth*y *nHeight* proporcionan la esquina superior izquierda y las dimensiones del rectángulo de destino. La operación ráster especificada por *dwRop* define cómo se combinan el mapa de bits de origen y los bits que ya están en el dispositivo de destino.

La `StretchBlt` función crea una imagen reflejada de un mapa de bits si los signos de los parámetros *nSrcWidth* y *nWidth* o *nSrcHeight* y *nHeight* difieren. Si *nSrcWidth* y *nWidth* tienen signos diferentes, la función crea una imagen reflejada del mapa de bits a lo largo del eje X. Si *nSrcHeight* y *nHeight* tienen signos diferentes, la función crea una imagen reflejada del mapa de bits a lo largo del eje Y.

La función `StretchBlt` estira o comprime el mapa de bits de origen en memoria y después copia el resultado al destino. Si se va a combinar un patrón con el resultado, no se combina hasta que el mapa de bits de origen estirado no se copia al destino. Si se usa un pincel, es el pincel seleccionado en el contexto de dispositivo de destino. Las coordenadas de destino se transforman según el contexto de dispositivo de destino; las coordenadas de origen se transforman según el contexto de dispositivo de origen.

Si los mapas de bits de destino, origen y patrón no tienen el mismo formato de color, `StretchBlt` convierte los mapas de bits de origen y de patrón para que coincidan con los mapas de bits de destino. En la conversión se usan los colores de primer plano y de fondo del contexto de dispositivo de destino.

Si `StretchBlt` debe convertir un mapa de bits monocromo a color, establece los bits blancos (1) al color de fondo y los bits negros (0) al color de primer plano. Para convertir de color a monocromo, establece en blanco (1) los píxeles que coinciden con el color de fondo y establece en negro (0) todos los demás píxeles. Se usan los colores de primer plano y de fondo del contexto de dispositivo con color.

No todos los dispositivos admiten la función `StretchBlt`. Para determinar si `StretchBlt`un dispositivo `GetDeviceCaps` admite , llame a la función miembro con el índice RASTERCAPS y compruebe el valor devuelto para el RC_STRETCHBLT marca.

## <a name="cdcstrokeandfillpath"></a><a name="strokeandfillpath"></a>CDC::StrokeAndFillPath

Cierra las figuras abiertas de un trazado, traza el contorno del trazado utilizando el lápiz actual y rellena su interior con el pincel actual.

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El contexto del dispositivo debe contener una ruta de acceso cerrada. La `StrokeAndFillPath` función miembro tiene el mismo efecto que cerrar todas las figuras abiertas en la ruta de acceso y acariciar y rellenar la ruta por separado, excepto que la región rellena no se superpondrá a la región trazada, incluso si el lápiz es ancho.

## <a name="cdcstrokepath"></a><a name="strokepath"></a>CDC::StrokePath

Representa la ruta especificada mediante el lápiz actual.

```
BOOL StrokePath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El contexto del dispositivo debe contener una ruta de acceso cerrada.

## <a name="cdctabbedtextout"></a><a name="tabbedtextout"></a>CDC::TabbedTextOut

Llame a esta función miembro para escribir una cadena de caracteres en la ubicación especificada, expandiendo las fichas a los valores especificados en la matriz de posiciones de tabulación.

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada x lógica del punto inicial de la cadena.

*y y*<br/>
Especifica la coordenada y lógica del punto inicial de la cadena.

*lpszString*<br/>
Apunta a la cadena de caracteres que se va a dibujar. Puede pasar un puntero a una matriz de caracteres o un [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto para este parámetro.

*nCount*<br/>
Especifica la [longitud de la cadena](/windows/win32/gdi/specifying-length-of-text-output-string) señalada por *lpszString*.

*nTabPositions*<br/>
Especifica el número de valores en la matriz de posiciones de tabulación.

*lpnTabStopPositions*<br/>
Apunta a una matriz que contiene las posiciones de tabulación (en unidades lógicas). Las tabulaciones deben ordenarse en orden creciente; el valor x más pequeño debe ser el primer elemento de la matriz.

*nTabOrigin*<br/>
Especifica la coordenada x de la posición inicial desde la que se expanden las fichas (en unidades lógicas).

*Str*<br/>
Objeto `CString` que contiene los caracteres especificados.

### <a name="return-value"></a>Valor devuelto

Las dimensiones de la cadena (en unidades lógicas) como un `CSize` objeto.

### <a name="remarks"></a>Observaciones

El texto se escribe en la fuente seleccionada actualmente. Si *nTabPositions* es 0 y *lpnTabStopPositions* es NULL, las fichas se expanden a ocho veces el ancho medio de caracteres.

Si *nTabPositions* es 1, las tabulaciones se separan por la distancia especificada por el primer valor de la matriz *lpnTabStopPositions.* Si la matriz *lpnTabStopPositions* contiene más de un valor, se establece una tabulación para cada valor de la matriz, hasta el número especificado por *nTabPositions*. El parámetro *nTabOrigin* permite a `TabbedTextOut` una aplicación llamar a la función varias veces para una sola línea. Si la aplicación llama a la función más de una vez con *nTabOrigin* establecido en el mismo valor cada vez, la función expande todas las pestañas relativas a la posición especificada por *nTabOrigin*.

De forma predeterminada, la función no usa ni actualiza la posición actual. Si una aplicación necesita actualizar la posición actual cuando llama a la función, la aplicación puede llamar a la [SetTextAlign](#settextalign) función miembro con *nFlags* establecido en TA_UPDATECP. Cuando se establece esta marca, Windows omite los parámetros *x* e *y* en las llamadas posteriores a `TabbedTextOut`, utilizando la posición actual en su lugar.

## <a name="cdctextout"></a><a name="textout"></a>CDC::TextOut

Escribe una cadena de caracteres en la ubicación especificada usando la fuente seleccionada actualmente.

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>Parámetros

*X*<br/>
Especifica la coordenada X lógica del punto inicial del texto.

*y y*<br/>
Especifica la coordenada Y lógica del punto inicial del texto.

*lpszString*<br/>
Apunta a la cadena de caracteres que se va a dibujar.

*nCount*<br/>
Especifica el número de caracteres de la cadena.

*Str*<br/>
Objeto `CString` que contiene los caracteres que se van a dibujar.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Los orígenes de los caracteres están en la esquina superior izquierda de la celda de caracteres. De forma predeterminada, la función no usa ni actualiza la posición actual.

Si una aplicación necesita actualizar la `TextOut`posición actual cuando `SetTextAlign` llama a , la aplicación puede llamar a la función miembro con *nFlags* establecido en TA_UPDATECP. Cuando se establece esta marca, Windows omite los parámetros *x* e *y* en las llamadas posteriores a `TextOut`, utilizando la posición actual en su lugar.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC::BeginPath](#beginpath).

## <a name="cdctransparentblt"></a><a name="transparentblt"></a>CDC::TransparentBlt

Llame a esta función miembro para transferir un bloque de bits de los datos de color, que corresponde a un rectángulo de píxeles desde el contexto de dispositivo de origen especificado, en un contexto de dispositivo de destino.

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>Parámetros

*xDest*<br/>
Especifica la coordenada x, en unidades lógicas, de la esquina superior izquierda del rectángulo de destino.

*yDest*<br/>
Especifica la coordenada y, en unidades lógicas, de la esquina superior izquierda del rectángulo de destino.

*nDestWidth*<br/>
Especifica el ancho, en unidades lógicas, del rectángulo de destino.

*nDestHeight*<br/>
Especifica el alto, en unidades lógicas, del rectángulo de destino.

*pSrcDC*<br/>
Puntero al contexto del dispositivo de origen.

*xSrc*<br/>
Especifica la coordenada x, en unidades lógicas, del rectángulo de origen.

*ySrc*<br/>
Especifica la coordenada y, en unidades lógicas, del rectángulo de origen.

*nSrcWidth*<br/>
Especifica el ancho, en unidades lógicas, del rectángulo de origen.

*nSrcHeight*<br/>
Especifica el alto, en unidades lógicas, del rectángulo de origen.

*clrTransparent*<br/>
El color RGB en el mapa de bits de origen para tratar como transparente.

### <a name="return-value"></a>Valor devuelto

TRUE si es correcto; en caso contrario, FALSE.

### <a name="remarks"></a>Observaciones

`TransparentBlt`permite la transparencia; es decir, el color RGB indicado por *clrTransparent* se hace transparente para la transferencia.

Para obtener más información, consulte [TransparentBlt](/windows/win32/api/wingdi/nf-wingdi-transparentblt) en el Windows SDK.

## <a name="cdcupdatecolors"></a><a name="updatecolors"></a>CDC::UpdateColors

Actualiza el área de cliente del contexto del dispositivo haciendo coincidir los colores actuales del área de cliente con la paleta del sistema píxel por píxel.

```
void UpdateColors();
```

### <a name="remarks"></a>Observaciones

Una ventana inactiva con una `UpdateColors` paleta lógica realizada puede llamar como alternativa a volver a dibujar su área de cliente cuando cambia la paleta del sistema.

Para obtener más información sobre el uso de paletas de colores, vea [UpdateColors](/windows/win32/api/wingdi/nf-wingdi-updatecolors) en el Windows SDK.

La `UpdateColors` función miembro normalmente actualiza un área de cliente más rápido que volver a dibujar el área. Sin embargo, dado que la función realiza la traducción de color basada en el color de cada píxel antes de que cambie la paleta del sistema, cada llamada a esta función da como resultado la pérdida de cierta precisión de color.

## <a name="cdcwidenpath"></a><a name="widenpath"></a>CDC::WidenPath

Redefine el trazado actual como el área que se pintaría si el trazado se trazara utilizando el lápiz seleccionado actualmente en el contexto del dispositivo.

```
BOOL WidenPath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función sólo tiene éxito si el lápiz actual `CreatePen` es un lápiz geométrico creado por `CreatePen` la segunda versión de la función miembro, o si el lápiz se crea con la primera versión de y tiene un ancho, en unidades de dispositivo, mayor que 1. El contexto del dispositivo debe contener una ruta de acceso cerrada. Las curvas Bzier del trazado se convierten en secuencias de líneas rectas que aproximan las curvas ensanchadas. Como tal, no quedan curvas de `WidenPath` Bzier en el trazado después de que se llama.

## <a name="see-also"></a>Consulte también

[Clase CObject](../../mfc/reference/cobject-class.md)<br/>
[Gráfico de jerarquías](../../mfc/hierarchy-chart.md)<br/>
[Clase CPaintDC](../../mfc/reference/cpaintdc-class.md)<br/>
[CWindowDC (clase)](../../mfc/reference/cwindowdc-class.md)<br/>
[CClientDC (clase)](../../mfc/reference/cclientdc-class.md)<br/>
[Clase CMetaFileDC](../../mfc/reference/cmetafiledc-class.md)
