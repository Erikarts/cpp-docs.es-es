---
title: CDC (clase)
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: bae2f9a5a4f39c4eeffe68cc33e744e44c6800c8
ms.sourcegitcommit: 3e8fa01f323bc5043a48a0c18b855d38af3648d4
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/06/2020
ms.locfileid: "78855578"
---
# <a name="cdc-class"></a>CDC (clase)

Define una clase de objetos en el contexto del dispositivo.

## <a name="syntax"></a>Sintaxis

```
class CDC : public CObject
```

## <a name="members"></a>Members

### <a name="public-constructors"></a>Constructores públicos

|Nombre|Descripción|
|----------|-----------------|
|[CDC:: CDC](#cdc)|Construye un objeto `CDC`.|

### <a name="public-methods"></a>Métodos públicos

|Nombre|Descripción|
|----------|-----------------|
|[CDC:: AbortDoc](#abortdoc)|Finaliza el trabajo de impresión actual y borra todo lo que la aplicación ha escrito en el dispositivo desde la última llamada de la función miembro `StartDoc`.|
|[CDC:: AbortPath](#abortpath)|Cierra y descarta cualquier ruta de acceso en el contexto del dispositivo.|
|[CDC:: AddMetaFileComment](#addmetafilecomment)|Copia el comentario de un búfer en un metarchivo de formato mejorado especificado.|
|[CDC:: AlphaBlend](#alphablend)|Muestra los mapas de bits que tienen píxeles transparentes o semitransparentes.|
|[CDC:: AngleArc](#anglearc)|Dibuja un segmento de línea y un arco, y mueve la posición actual al punto final del arco.|
|[CDC:: arco](#arc)|Dibuja un arco elíptico.|
|[CDC:: ArcTo](#arcto)|Dibuja un arco elíptico. Esta función es similar a `Arc`, excepto en que se actualiza la posición actual.|
|[CDC:: Attach](#attach)|Asocia un contexto de dispositivo de Windows a este objeto `CDC`.|
|[CDC:: BeginPath](#beginpath)|Abre un corchete de ruta de acceso en el contexto del dispositivo.|
|[CDC:: BitBlt](#bitblt)|Copia un mapa de bits desde un contexto de dispositivo especificado.|
|[CDC:: cuerda](#chord)|Dibuja una cuerda (una figura cerrada enlazada por la intersección de una elipse y un segmento de línea).|
|[CDC:: CloseFigure](#closefigure)|Cierra una figura abierta en una ruta de acceso.|
|[CDC:: CreateCompatibleDC](#createcompatibledc)|Crea un contexto de dispositivo de memoria que es compatible con otro contexto de dispositivo. Puede usarlo para preparar imágenes en la memoria.|
|[CDC:: CreateDC](#createdc)|Crea un contexto de dispositivo para un dispositivo específico.|
|[CDC:: creat](#createic)|Crea un contexto de información para un dispositivo específico. Esto proporciona una manera rápida de obtener información sobre el dispositivo sin crear un contexto de dispositivo.|
|[CDC::D eleteDC](#deletedc)|Elimina el contexto de dispositivo de Windows asociado a este objeto `CDC`.|
|[CDC::D eleteTempMap](#deletetempmap)|Lo llama el controlador de tiempo de inactividad de `CWinApp` para eliminar cualquier objeto de `CDC` temporal creado por `FromHandle`. También separa el contexto del dispositivo.|
|[CDC::D Etach](#detach)|Desasocia el contexto de dispositivo de Windows de este objeto `CDC`.|
|[CDC::D PtoHIMETRIC](#dptohimetric)|Convierte unidades de dispositivo en unidades de HIMETRIC.|
|[CDC::D PtoLP](#dptolp)|Convierte unidades de dispositivo en unidades lógicas.|
|[CDC::D raw3dRect](#draw3drect)|Dibuja un rectángulo tridimensional.|
|[CDC::D rawDragRect](#drawdragrect)|Borra y vuelve a dibujar un rectángulo a medida que se arrastra.|
|[CDC::D rawEdge](#drawedge)|Dibuja los bordes de un rectángulo.|
|[CDC::D rawEscape](#drawescape)|Obtiene acceso a las funciones de dibujo de una pantalla de vídeo que no están directamente disponibles a través de la interfaz de dispositivo gráfico (GDI).|
|[CDC::D rawFocusRect](#drawfocusrect)|Dibuja un rectángulo en el estilo utilizado para indicar el foco.|
|[CDC::D rawFrameControl](#drawframecontrol)|Dibuja un control de marco.|
|[CDC::D rawIcon](#drawicon)|Dibuja un icono.|
|[CDC::D rawState](#drawstate)|Muestra una imagen y aplica un efecto visual para indicar un estado.|
|[CDC::D rawText](#drawtext)|Dibuja texto con formato en el rectángulo especificado.|
|[CDC::D rawTextEx](#drawtextex)|Dibuja texto con formato en el rectángulo especificado mediante formatos adicionales.|
|[CDC:: Ellipse](#ellipse)|Dibuja una elipse.|
|[CDC:: EndDoc](#enddoc)|Finaliza un trabajo de impresión Iniciado por la función miembro `StartDoc`.|
|[CDC:: EndPage](#endpage)|Informa al controlador de dispositivo de que una página está finalizando.|
|[CDC:: EndPath](#endpath)|Cierra un corchete de ruta de acceso y selecciona la ruta de acceso definida por el corchete en el contexto del dispositivo.|
|[CDC:: EnumObjects](#enumobjects)|Enumera los lápices y los pinceles disponibles en un contexto de dispositivo.|
|[CDC:: escape](#escape)|Permite a las aplicaciones tener acceso a recursos que no están directamente disponibles desde un dispositivo determinado a través de GDI. También permite el acceso a las funciones de escape de Windows. Las llamadas de escape realizadas por una aplicación se traducen y se envían al controlador de dispositivo.|
|[CDC:: ExcludeClipRect](#excludecliprect)|Crea una nueva región de recorte que consta de la región de recorte existente menos el rectángulo especificado.|
|[CDC:: ExcludeUpdateRgn](#excludeupdatergn)|Impide que se dibuje en áreas no válidas de una ventana excluyendo una región actualizada en la ventana de una región de recorte.|
|[CDC:: ExtFloodFill](#extfloodfill)|Rellena un área con el pincel actual. Proporciona más flexibilidad que la función miembro [CDC:: FloodFill](#floodfill) .|
|[CDC:: ExtTextOut](#exttextout)|Escribe una cadena de caracteres dentro de una región rectangular usando la fuente seleccionada actualmente.|
|[CDC:: FillPath](#fillpath)|Cierra las figuras abiertas en la ruta de acceso actual y rellena el interior del trazado mediante el pincel actual y el modo de relleno de polígonos.|
|[CDC:: FillRect](#fillrect)|Rellena un rectángulo determinado mediante un pincel específico.|
|[CDC:: FillRgn](#fillrgn)|Rellena una región específica con el pincel especificado.|
|[CDC:: FillSolidRect](#fillsolidrect)|Rellena un rectángulo con un color sólido.|
|[CDC:: FlattenPath](#flattenpath)|Transforma las curvas del trazado seleccionado en el contexto del dispositivo actual y convierte cada curva en una secuencia de líneas.|
|[CDC:: FloodFill](#floodfill)|Rellena un área con el pincel actual.|
|[CDC:: FrameRect](#framerect)|Dibuja un borde alrededor de un rectángulo.|
|[CDC:: FrameRgn](#framergn)|Dibuja un borde alrededor de una región específica mediante un pincel.|
|[CDC:: FromHandle](#fromhandle)|Devuelve un puntero a un objeto `CDC` cuando se proporciona un identificador a un contexto de dispositivo. Si no hay un objeto `CDC` asociado al identificador, se crea y asocia un objeto `CDC` temporal.|
|[CDC:: GetArcDirection](#getarcdirection)|Devuelve la dirección de arco actual del contexto del dispositivo.|
|[CDC:: GetAspectRatioFilter](#getaspectratiofilter)|Recupera el valor para el filtro de la relación de aspecto actual.|
|[CDC:: GetBkColor](#getbkcolor)|Recupera el color de fondo actual.|
|[CDC:: GetBkMode](#getbkmode)|Recupera el modo en segundo plano.|
|[CDC:: GetBoundsRect](#getboundsrect)|Devuelve el rectángulo delimitador acumulado actual para el contexto de dispositivo especificado.|
|[CDC:: GetBrushOrg](#getbrushorg)|Recupera el origen del pincel actual.|
|[CDC:: GetCharABCWidths](#getcharabcwidths)|Recupera los anchos, en unidades lógicas, de caracteres consecutivos de un intervalo determinado de la fuente actual.|
|[CDC:: GetCharABCWidthsI](#getcharabcwidthsi)|Recupera los anchos, en unidades lógicas, de los índices de glifos consecutivos en un intervalo especificado de la fuente TrueType actual.|
|[CDC:: GetCharacterPlacement](#getcharacterplacement)|Recupera varios tipos de información sobre una cadena de caracteres.|
|[CDC:: GetCharWidth](#getcharwidth)|Recupera el ancho fraccionario de caracteres consecutivos de un intervalo determinado a partir de la fuente actual.|
|[CDC:: GetCharWidthI](#getcharwidthi)|Recupera los anchos, en coordenadas lógicas, de los índices de glifos consecutivos en un intervalo especificado de la fuente actual.|
|[CDC:: GetClipBox](#getclipbox)|Recupera las dimensiones del rectángulo delimitador más estrecho alrededor del límite de recorte actual.|
|[CDC:: GetColorAdjustment](#getcoloradjustment)|Recupera los valores de ajuste de color para el contexto del dispositivo.|
|[CDC:: GetCurrentBitmap](#getcurrentbitmap)|Devuelve un puntero al objeto `CBitmap` actualmente seleccionado.|
|[CDC:: GetCurrentBrush](#getcurrentbrush)|Devuelve un puntero al objeto `CBrush` actualmente seleccionado.|
|[CDC:: GetCurrentFont](#getcurrentfont)|Devuelve un puntero al objeto `CFont` actualmente seleccionado.|
|[CDC:: GetCurrentPalette](#getcurrentpalette)|Devuelve un puntero al objeto `CPalette` actualmente seleccionado.|
|[CDC:: GetCurrentPen](#getcurrentpen)|Devuelve un puntero al objeto `CPen` actualmente seleccionado.|
|[CDC:: GetCurrentPosition](#getcurrentposition)|Recupera la posición actual del lápiz (en coordenadas lógicas).|
|[CDC:: GetDCBrushColor](#getdcbrushcolor)|Recupera el color de pincel actual.|
|[CDC:: GetDCPenColor](#getdcpencolor)|Recupera el color del lápiz actual.|
|[CDC:: GetDeviceCaps](#getdevicecaps)|Recupera un tipo especificado de información específica del dispositivo sobre las capacidades de un dispositivo de presentación determinado.|
|[CDC:: GetFontData](#getfontdata)|Recupera información de métricas de fuente de un archivo de fuente escalable. La información que se va a recuperar se identifica especificando un desplazamiento en el archivo de fuente y la longitud de la información que se va a devolver.|
|[CDC:: GetFontLanguageInfo](#getfontlanguageinfo)|Devuelve información sobre la fuente seleccionada actualmente para el contexto de presentación especificado.|
|[CDC:: GetGlyphOutline](#getglyphoutline)|Recupera la curva o el mapa de bits del contorno de un carácter de contorno en la fuente actual.|
|[CDC:: GetGraphicsMode](#getgraphicsmode)|Recupera el modo de gráficos actual para el contexto de dispositivo especificado.|
|[CDC:: GetHalftoneBrush](#gethalftonebrush)|Recupera un pincel de semitonos.|
|[CDC:: GetKerningPairs](#getkerningpairs)|Recupera los pares de interletraje de caracteres de la fuente seleccionada actualmente en el contexto de dispositivo especificado.|
|[CDC:: GetLayout](#getlayout)|Recupera el diseño de un contexto de dispositivo (DC). El diseño puede ser de izquierda a derecha (predeterminado) o de derecha a izquierda (reflejado).|
|[CDC:: GetMapMode](#getmapmode)|Recupera el modo de asignación actual.|
|[CDC:: GetMiterLimit](#getmiterlimit)|Devuelve el límite angular del contexto del dispositivo.|
|[CDC:: GetNearestColor](#getnearestcolor)|Recupera el color lógico más cercano a un color lógico especificado que puede representar el dispositivo especificado.|
|[CDC:: GetOutlineTextMetrics](#getoutlinetextmetrics)|Recupera información sobre las métricas de fuente para las fuentes TrueType.|
|[CDC:: GetOutputCharWidth](#getoutputcharwidth)|Recupera el ancho de caracteres individuales de un grupo de caracteres consecutivos de la fuente actual mediante el contexto de dispositivo de salida.|
|[CDC:: GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|Calcula el ancho y el alto de una cadena de caracteres en el contexto del dispositivo de salida.|
|[CDC:: GetOutputTextExtent](#getoutputtextextent)|Calcula el ancho y el alto de una línea de texto en el contexto del dispositivo de salida utilizando la fuente actual para determinar las dimensiones.|
|[CDC:: GetOutputTextMetrics](#getoutputtextmetrics)|Recupera las métricas de la fuente actual del contexto del dispositivo de salida.|
|[CDC:: GetPath](#getpath)|Recupera las coordenadas que definen los extremos de las líneas y los puntos de control de las curvas que se encuentran en la ruta de acceso que está seleccionada en el contexto del dispositivo.|
|[CDC:: GetPixel](#getpixel)|Recupera el valor de color RGB del píxel en el punto especificado.|
|[CDC:: GetPolyFillMode](#getpolyfillmode)|Recupera el modo de relleno de polígonos actual.|
|[CDC:: GetROP2](#getrop2)|Recupera el modo de dibujo actual.|
|[CDC:: GetSafeHdc](#getsafehdc)|Devuelve [CDC:: m_hDC](#m_hdc), el contexto de dispositivo de salida.|
|[CDC:: GetStretchBltMode](#getstretchbltmode)|Recupera el modo de ajuste de mapa de bits actual.|
|[CDC:: GetTabbedTextExtent](#gettabbedtextextent)|Calcula el ancho y el alto de una cadena de caracteres en el contexto del dispositivo de atributo.|
|[CDC:: GetTextAlign](#gettextalign)|Recupera las marcas de alineación de texto.|
|[CDC:: GetTextCharacterExtra](#gettextcharacterextra)|Recupera el valor actual para la cantidad de espaciado entre caracteres.|
|[CDC:: GetTextColor](#gettextcolor)|Recupera el color del texto actual.|
|[CDC:: GetTextExtent](#gettextextent)|Calcula el ancho y el alto de una línea de texto en el contexto del dispositivo de atributo utilizando la fuente actual para determinar las dimensiones.|
|[CDC:: GetTextExtentExPointI](#gettextextentexpointi)|Recupera el número de caracteres de una cadena especificada que caben dentro de un espacio especificado y rellena una matriz con la extensión de texto de cada uno de esos caracteres.|
|[CDC:: GetTextExtentPointI](#gettextextentpointi)|Recupera el ancho y el alto de la matriz especificada de índices de glifo.|
|[CDC:: GetTextFace](#gettextface)|Copia el nombre del tipo de letra de la fuente actual en un búfer como una cadena terminada en NULL.|
|[CDC:: GetTextMetrics](#gettextmetrics)|Recupera las métricas de la fuente actual del contexto de dispositivo de atributo.|
|[CDC:: GetViewportExt](#getviewportext)|Recupera las extensiones x e y de la ventanilla.|
|[CDC:: GetViewportOrg](#getviewportorg)|Recupera las coordenadas x e y del origen de la ventanilla.|
|[CDC:: GetWindow](#getwindow)|Devuelve la ventana asociada con el contexto de dispositivo de pantalla.|
|[CDC:: GetWindowExt](#getwindowext)|Recupera las extensiones x e y de la ventana asociada.|
|[CDC:: GetWindowOrg](#getwindoworg)|Recupera las coordenadas x e y del origen de la ventana asociada.|
|[CDC:: GetWorldTransform](#getworldtransform)|Recupera el espacio global actual en la transformación de espacio en la página.|
|[CDC:: GradientFill](#gradientfill)|Rellena las estructuras de rectángulos y triángulos con un color gradating.|
|[CDC:: GrayString](#graystring)|Dibuja texto atenuado (atenuado) en la ubicación especificada.|
|[CDC:: HIMETRICtoDP](#himetrictodp)|Convierte unidades HIMETRIC en unidades de dispositivo.|
|[CDC:: HIMETRICtoLP](#himetrictolp)|Convierte unidades de HIMETRIC en unidades lógicas.|
|[CDC:: IntersectClipRect](#intersectcliprect)|Crea una nueva región de recorte formando la intersección de la región actual y un rectángulo.|
|[CDC:: InvertRect](#invertrect)|Invierte el contenido de un rectángulo.|
|[CDC:: InvertRgn](#invertrgn)|Invierte los colores de una región.|
|[CDC:: IsPrinting](#isprinting)|Determina si el contexto de dispositivo se usa para imprimir.|
|[CDC:: lineTo](#lineto)|Dibuja una línea desde la posición actual hasta un punto, pero sin incluirlo.|
|[CDC:: LPtoDP](#lptodp)|Convierte unidades lógicas en unidades de dispositivo.|
|[CDC:: LPtoHIMETRIC](#lptohimetric)|Convierte unidades lógicas en unidades de HIMETRIC.|
|[CDC:: MaskBlt](#maskblt)|Combina los datos de color de los mapas de bits de origen y de destino usando la máscara y la operación de trama dadas.|
|[CDC:: ModifyWorldTransform](#modifyworldtransform)|Cambia la transformación universal para un contexto de dispositivo mediante el modo especificado.|
|[CDC:: moveTo](#moveto)|Mueve la posición actual.|
|[CDC:: OffsetClipRgn](#offsetcliprgn)|Mueve la región de recorte del dispositivo especificado.|
|[CDC:: OffsetViewportOrg](#offsetviewportorg)|Modifica el origen de la ventanilla en relación con las coordenadas del origen de la ventanilla actual.|
|[CDC:: OffsetWindowOrg](#offsetwindoworg)|Modifica el origen de la ventana con respecto a las coordenadas del origen de la ventana actual.|
|[CDC::P aintRgn](#paintrgn)|Rellena una región con el pincel seleccionado.|
|[CDC::P atBlt](#patblt)|Crea un patrón de bits.|
|[CDC::P IE](#pie)|Dibuja una cuña en forma de círculo.|
|[CDC::P layMetaFile](#playmetafile)|Reproduce el contenido del metarchivo especificado en el dispositivo especificado. La versión mejorada de `PlayMetaFile` muestra la imagen almacenada en el metarchivo de formato mejorado proporcionado. El metarchivo se puede reproducir varias veces.|
|[CDC::P lgBlt](#plgblt)|Realiza una transferencia de bloque de bits de los bits de los datos de color desde el rectángulo especificado en el contexto del dispositivo de origen al paralelogramo especificado en el contexto de dispositivo determinado.|
|[CDC::P olyBezier](#polybezier)|Dibuja una o varias curvas spline de Bzier. La posición actual no se usa ni se actualiza.|
|[CDC::P olyBezierTo](#polybezierto)|Dibuja una o varias curvas spline de Bzier y mueve la posición actual al punto final de la última spline Bzier.|
|[CDC::P olyDraw](#polydraw)|Dibuja un conjunto de segmentos de línea y curvas spline Bzier. Esta función actualiza la posición actual.|
|[CDC::P olygon](#polygon)|Dibuja un polígono que consta de dos o más puntos (vértices) conectados mediante líneas.|
|[CDC::P olyline](#polyline)|Dibuja un conjunto de segmentos de línea que conectan los puntos especificados.|
|[CDC::P olylineTo](#polylineto)|Dibuja una o varias líneas rectas y mueve la posición actual al punto final de la última línea.|
|[CDC::P olyPolygon](#polypolygon)|Crea dos o más polígonos que se rellenan con el modo de relleno de polígonos actual. Los polígonos pueden estar separados o pueden superponerse.|
|[CDC::P olyPolyline](#polypolyline)|Dibuja varias series de segmentos de línea conectados. Esta función no usa ni actualiza la posición actual.|
|[CDC::P tVisible](#ptvisible)|Especifica si el punto especificado está dentro de la región de recorte.|
|[CDC:: RealizePalette](#realizepalette)|Asigna las entradas de la paleta en la paleta lógica actual a la paleta del sistema.|
|[CDC:: Rectangle](#rectangle)|Dibuja un rectángulo utilizando el lápiz actual y lo rellena con el pincel actual.|
|[CDC:: RectVisible](#rectvisible)|Determina si alguna parte del rectángulo especificado está dentro de la región de recorte.|
|[CDC:: ReleaseAttribDC](#releaseattribdc)|Libera `m_hAttribDC`, el contexto de dispositivo de atributo.|
|[CDC:: ReleaseOutputDC](#releaseoutputdc)|Libera `m_hDC`, el contexto de dispositivo de salida.|
|[CDC:: ResetDC](#resetdc)|Actualiza el contexto de dispositivo `m_hAttribDC`.|
|[CDC:: RestoreDC](#restoredc)|Restaura el contexto de dispositivo a un estado anterior guardado con `SaveDC`.|
|[CDC:: RoundRect](#roundrect)|Dibuja un rectángulo con esquinas redondeadas usando el lápiz actual y rellenado con el pincel actual.|
|[CDC:: SaveDC](#savedc)|Guarda el estado actual del contexto del dispositivo.|
|[CDC:: ScaleViewportExt](#scaleviewportext)|Modifica la extensión de la ventanilla relativa a los valores actuales.|
|[CDC:: ScaleWindowExt](#scalewindowext)|Modifica las extensiones de la ventana con respecto a los valores actuales.|
|[CDC:: ScrollDC](#scrolldc)|Desplaza un rectángulo de bits horizontal y verticalmente.|
|[CDC:: SelectClipPath](#selectclippath)|Selecciona la ruta de acceso actual como una región de recorte para el contexto de dispositivo, combinando la nueva región con cualquier región de recorte existente mediante el modo especificado.|
|[CDC:: SelectClipRgn](#selectcliprgn)|Combina la región determinada con la región de recorte actual mediante el modo especificado.|
|[CDC:: SelectObject](#selectobject)|Selecciona un objeto de dibujo GDI, como un lápiz.|
|[CDC:: SelectPalette](#selectpalette)|Selecciona la paleta lógica.|
|[CDC:: SelectStockObject](#selectstockobject)|Selecciona uno de los lápices de stock predefinidos, los pinceles o las fuentes proporcionadas por Windows.|
|[CDC:: SetAbortProc](#setabortproc)|Establece una función de devolución de llamada proporcionada por el programador que llama a Windows si se debe anular un trabajo de impresión.|
|[CDC:: SetArcDirection](#setarcdirection)|Establece la dirección de dibujo que se va a utilizar para las funciones de arco y rectángulo.|
|[CDC:: SetAttribDC](#setattribdc)|Establece `m_hAttribDC`, el contexto de dispositivo de atributo.|
|[CDC:: SetBkColor](#setbkcolor)|Establece el color de fondo actual.|
|[CDC:: SetBkMode](#setbkmode)|Establece el modo en segundo plano.|
|[CDC:: SetBoundsRect](#setboundsrect)|Controla la acumulación de información del rectángulo delimitador para el contexto de dispositivo especificado.|
|[CDC:: SetBrushOrg](#setbrushorg)|Especifica el origen del siguiente pincel seleccionado en un contexto de dispositivo.|
|[CDC:: SetColorAdjustment](#setcoloradjustment)|Establece los valores de ajuste de color para el contexto de dispositivo usando los valores especificados.|
|[CDC:: SetDCBrushColor](#setdcbrushcolor)|Establece el color del pincel actual.|
|[CDC:: SetDCPenColor](#setdcpencolor)|Establece el color del lápiz actual.|
|[CDC:: SetGraphicsMode](#setgraphicsmode)|Establece el modo de gráficos actual para el contexto de dispositivo especificado.|
|[CDC:: SetLayout](#setlayout)|Cambia el diseño de un contexto de dispositivo (DC).|
|[CDC:: SetMapMode](#setmapmode)|Establece el modo de asignación actual.|
|[CDC:: SetMapperFlags](#setmapperflags)|Modifica el algoritmo que utiliza el asignador de fuentes cuando asigna fuentes lógicas a fuentes físicas.|
|[CDC:: SetMiterLimit](#setmiterlimit)|Establece el límite para la longitud de las combinaciones en ángulo para el contexto del dispositivo.|
|[CDC:: SetOutputDC](#setoutputdc)|Establece `m_hDC`, el contexto de dispositivo de salida.|
|[CDC:: SetPixel](#setpixel)|Establece el píxel en el punto especificado en la aproximación más cercana del color especificado.|
|[CDC:: SetPixelV](#setpixelv)|Establece el píxel en las coordenadas especificadas en la aproximación más cercana del color especificado. `SetPixelV` es más rápido que `SetPixel` porque no necesita devolver el valor de color del punto pintado realmente.|
|[CDC:: SetPolyFillMode](#setpolyfillmode)|Establece el modo de relleno de polígonos.|
|[CDC:: SetROP2](#setrop2)|Establece el modo de dibujo actual.|
|[CDC:: SetStretchBltMode](#setstretchbltmode)|Establece el modo de ajuste de mapa de bits.|
|[CDC:: SetTextAlign](#settextalign)|Establece las marcas de alineación de texto.|
|[CDC:: SetTextCharacterExtra](#settextcharacterextra)|Establece la cantidad de espaciado entre caracteres.|
|[CDC:: SetTextColor](#settextcolor)|Establece el color de texto.|
|[CDC:: SetTextJustification](#settextjustification)|Agrega espacio a los caracteres de salto de una cadena.|
|[CDC:: SetViewportExt](#setviewportext)|Establece las extensiones x e y de la ventanilla.|
|[CDC:: SetViewportOrg](#setviewportorg)|Establece el origen de la ventanilla.|
|[CDC:: SetWindowExt](#setwindowext)|Establece las extensiones x e y de la ventana asociada.|
|[CDC:: SetWindowOrg](#setwindoworg)|Establece el origen de la ventana del contexto del dispositivo.|
|[CDC:: SetWorldTransform](#setworldtransform)|Establece la transformación espacio global actual en el espacio de la página.|
|[CDC:: StartDoc](#startdoc)|Informa al controlador de dispositivo de que se está iniciando un nuevo trabajo de impresión.|
|[CDC:: StartPage](#startpage)|Informa al controlador de dispositivo de que se está iniciando una nueva página.|
|[CDC:: StretchBlt](#stretchblt)|Mueve un mapa de bits de un rectángulo y un dispositivo de origen a un rectángulo de destino, estirando o comprimiendo el mapa de bits si es necesario para ajustarse a las dimensiones del rectángulo de destino.|
|[CDC:: StrokeAndFillPath](#strokeandfillpath)|Cierra todas las figuras abiertas en un trazado, hace que el contorno de la ruta de acceso se contenga con el lápiz actual y rellena su interior mediante el pincel actual.|
|[CDC:: StrokePath](#strokepath)|Representa la ruta de acceso especificada utilizando el lápiz actual.|
|[CDC:: TabbedTextOut](#tabbedtextout)|Escribe una cadena de caracteres en una ubicación especificada, expandiendo las pestañas hasta los valores especificados en una matriz de posiciones de tabulación.|
|[CDC:: TextOut](#textout)|Escribe una cadena de caracteres en una ubicación especificada utilizando la fuente seleccionada actualmente.|
|[CDC:: TransparentBlt](#transparentblt)|Transfiere un bloque de bits de datos de color desde el contexto de dispositivo de origen especificado a un contexto de dispositivo de destino, lo que representa un color especificado transparente en la transferencia.|
|[CDC:: UpdateColors](#updatecolors)|Actualiza el área cliente del contexto del dispositivo al hacer coincidir los colores actuales del área cliente con la paleta del sistema píxel a píxel.|
|[CDC:: WidenPath](#widenpath)|Vuelve a definir la ruta de acceso actual como área que se va a pintar si la ruta de acceso se traza con el lápiz seleccionado actualmente en el contexto del dispositivo.|

### <a name="public-operators"></a>Operadores públicos

|Nombre|Descripción|
|----------|-----------------|
|[CDC:: Operator HDC](#operator_hdc)|Recupera el identificador del contexto del dispositivo.|

### <a name="public-data-members"></a>Miembros de datos públicos

|Nombre|Descripción|
|----------|-----------------|
|[CDC:: m_hAttribDC](#m_hattribdc)|Contexto de dispositivo de atributo utilizado por este objeto `CDC`.|
|[CDC:: m_hDC](#m_hdc)|Contexto de dispositivo de salida utilizado por este objeto `CDC`.|

## <a name="remarks"></a>Observaciones

El objeto `CDC` proporciona funciones miembro para trabajar con un contexto de dispositivo, como una pantalla o una impresora, así como miembros para trabajar con un contexto de presentación asociado al área de cliente de una ventana.

Realiza todo el dibujo a través de las funciones miembro de un objeto `CDC`. La clase proporciona funciones miembro para operaciones de contexto de dispositivo, trabajo con herramientas de dibujo, selección de objetos de la interfaz de dispositivo gráfico (GDI) con seguridad de tipos y trabajo con colores y paletas. También proporciona funciones miembro para obtener y establecer atributos de dibujo, asignar, trabajar con la ventanilla, trabajar con la extensión de ventana, convertir coordenadas, trabajar con regiones, recortar, dibujar líneas y dibujar formas simples, elipses y polígonos. También se proporcionan funciones miembro para dibujar texto, trabajar con fuentes, usar secuencias de escape de impresora, desplazarse y reproducir metaarchivos.

Para usar un objeto `CDC`, construya y, a continuación, llame a sus funciones miembro que utilicen funciones de Windows paralelas que usan contextos de dispositivo.

> [!NOTE]
>  En Windows 95/98, todas las coordenadas de pantalla están limitadas a 16 bits. Por lo tanto, un **int** pasado a una función miembro de `CDC` debe estar en el intervalo de-32768 a 32767.

Para usos específicos, el biblioteca MFC proporciona varias clases derivadas de `CDC`. `CPaintDC` encapsula llamadas a `BeginPaint` y `EndPaint`. `CClientDC` administra un contexto de presentación asociado al área de cliente de una ventana. `CWindowDC` administra un contexto de presentación asociado a una ventana completa, incluidos el marco y los controles. `CMetaFileDC` asocia un contexto de dispositivo a un metarchivo.

`CDC` proporciona dos funciones miembro, [GetLayout](#getlayout) y [SetLayout](#setlayout), para invertir el diseño de un contexto de dispositivo, que no hereda su diseño de una ventana. Esta orientación de derecha a izquierda es necesaria para las aplicaciones escritas para las referencias culturales, como el árabe o el hebreo, donde el diseño de los caracteres no es el estándar europeo.

`CDC` contiene dos contextos de dispositivo, [m_hDC](#m_hdc) y [m_hAttribDC](#m_hattribdc), que, al crear un objeto `CDC`, hacen referencia al mismo dispositivo. `CDC` dirige todas las llamadas GDI de salida a `m_hDC` y la mayoría de las llamadas GDI de atributo a `m_hAttribDC`. (Un ejemplo de una llamada de atributo es `GetTextColor`, mientras que `SetTextColor` es una llamada de salida).

Por ejemplo, el marco de trabajo utiliza estos dos contextos de dispositivo para implementar un `CMetaFileDC` objeto que enviará la salida a un metarchivo mientras lee los atributos de un dispositivo físico. La vista previa de impresión se implementa en el marco de manera similar. También puede usar los dos contextos de dispositivo de una manera similar en el código específico de la aplicación.

Hay ocasiones en las que puede necesitar información de métricas de texto de los contextos de dispositivo `m_hDC` y `m_hAttribDC`. Los siguientes pares de funciones proporcionan esta capacidad:

|Usa m_hAttribDC|Usa m_hDC|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

Para obtener más información sobre `CDC`, consulte [contextos de dispositivos](../../mfc/device-contexts.md).

## <a name="inheritance-hierarchy"></a>Jerarquía de herencia

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>Requisitos

**Encabezado:** afxwin.h

##  <a name="abortdoc"></a>CDC:: AbortDoc

Finaliza el trabajo de impresión actual y borra todo lo que la aplicación ha escrito en el dispositivo desde la última llamada a la función miembro [StartDoc](#startdoc) .

```
int AbortDoc();
```

### <a name="return-value"></a>Valor devuelto

Un valor mayor o igual que 0 si se realiza correctamente, o un valor negativo si se ha producido un error. En la lista siguiente se muestran los valores de error comunes y su significado:

- SP_ERROR error general.

- SP_OUTOFDISK espacio en disco insuficiente actualmente está disponible para la puesta en cola y no habrá más espacio disponible.

- SP_OUTOFMEMORY no hay suficiente memoria disponible para la puesta en cola.

- SP_USERABORT usuario terminó el trabajo a través del administrador de impresión.

### <a name="remarks"></a>Observaciones

Esta función miembro reemplaza el escape de la impresora ABORTDOC.

`AbortDoc` debe usarse para finalizar lo siguiente:

- Operaciones de impresión que no especifican una función Abort mediante [SetAbortProc](#setabortproc).

- Operaciones de impresión que aún no han alcanzado su primera llamada de escape NEWFRAME o NEXTBAND.

Si una aplicación encuentra un error de impresión o una operación de impresión cancelada, no debe intentar finalizar la operación mediante las funciones miembro [EndDoc](#enddoc) o `AbortDoc` de la clase `CDC`. GDI finaliza automáticamente la operación antes de devolver el valor de error.

Si la aplicación muestra un cuadro de diálogo que permite al usuario cancelar la operación de impresión, debe llamar a `AbortDoc` antes de destruir el cuadro de diálogo.

Si se utilizó el administrador de impresión para iniciar el trabajo de impresión, al llamar a `AbortDoc` se borra todo el trabajo de cola; la impresora no recibe nada. Si el administrador de impresión no se ha usado para iniciar el trabajo de impresión, es posible que los datos se hayan enviado a la impresora antes de que se llamara a `AbortDoc`. En este caso, el controlador de impresora habría restablecido la impresora (cuando sea posible) y cerrado el trabajo de impresión.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC:: StartDoc](#startdoc).

##  <a name="abortpath"></a>CDC:: AbortPath

Cierra y descarta cualquier ruta de acceso en el contexto del dispositivo.

```
BOOL AbortPath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Si hay un corchete de ruta de acceso abierto en el contexto del dispositivo, el corchete de la ruta de acceso está cerrado y la ruta de acceso se descarta. Si hay una ruta de acceso cerrada en el contexto del dispositivo, la ruta de acceso se descarta.

##  <a name="addmetafilecomment"></a>CDC:: AddMetaFileComment

Copia el comentario de un búfer en un metarchivo de formato mejorado especificado.

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>Parámetros

*nDataSize*<br/>
Especifica la longitud del búfer de comentario, en bytes.

*pCommentData*<br/>
Apunta al búfer que contiene el comentario.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Un comentario puede incluir cualquier información privada, por ejemplo, el origen de la imagen y la fecha en que se creó. Un comentario debe comenzar con una firma de aplicación, seguido de los datos. Los comentarios no deben contener datos específicos de la posición. Los datos específicos de la posición especifican la ubicación de un registro y no se deben incluir porque se puede incrustar un metarchivo en otro metarchivo. Esta función solo se puede usar con metaarchivos mejorados.

##  <a name="alphablend"></a>CDC:: AlphaBlend

Llame a esta función miembro para mostrar los mapas de bits que tienen píxeles transparentes o semitransparentes.

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>Parámetros

*xDest*<br/>
Especifica la coordenada x, en unidades lógicas, de la esquina superior izquierda del rectángulo de destino.

*yDest*<br/>
Especifica la coordenada y, en unidades lógicas, de la esquina superior izquierda del rectángulo de destino.

*nDestWidth*<br/>
Especifica el ancho, en unidades lógicas, del rectángulo de destino.

*nDestHeight*<br/>
Especifica el alto, en unidades lógicas, del rectángulo de destino.

*pSrcDC*<br/>
Un puntero al contexto de dispositivo de origen.

*xSrc*<br/>
Especifica la coordenada x, en unidades lógicas, de la esquina superior izquierda del rectángulo de origen.

*ySrc*<br/>
Especifica la coordenada y, en unidades lógicas, de la esquina superior izquierda del rectángulo de origen.

*nSrcWidth*<br/>
Especifica el ancho, en unidades lógicas, del rectángulo de origen.

*nSrcHeight*<br/>
Especifica el alto, en unidades lógicas, del rectángulo de origen.

*formas*<br/>
Especifica una estructura [BLENDFUNCTION](/windows/win32/api/wingdi/ns-wingdi-blendfunction) .

### <a name="return-value"></a>Valor devuelto

TRUE si es correcto; en caso contrario, FALSE.

### <a name="remarks"></a>Observaciones

Vea [AlphaBlend](/windows/win32/api/wingdi/nf-wingdi-alphablend) en el Windows SDK para obtener más información.

##  <a name="anglearc"></a>CDC:: AngleArc

Dibuja un segmento de línea y un arco.

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x lógica del centro del círculo.

*y*<br/>
Especifica la coordenada y lógica del centro del círculo.

*nRadius*<br/>
Especifica el radio del círculo en unidades lógicas. Este valor debe ser positivo.

*fStartAngle*<br/>
Especifica el ángulo inicial en grados en relación con el eje x.

*fSweepAngle*<br/>
Especifica el ángulo de barrido en grados en relación con el ángulo inicial.

### <a name="return-value"></a>Valor devuelto

Si es correcta, su valor es distinto de cero. En caso contrario, es cero.

### <a name="remarks"></a>Observaciones

El segmento de línea se dibuja desde la posición actual hasta el principio del arco. El arco se dibuja a lo largo del perímetro de un círculo con el radio y el centro determinados. La longitud del arco se define mediante los ángulos de inicio y barrido especificados.

`AngleArc` mueve la posición actual al punto final del arco. El arco dibujado por esta función puede parecer elíptico, en función del modo de asignación y transformación actual. Antes de dibujar el arco, esta función dibuja el segmento de línea desde la posición actual hasta el principio del arco. El arco se dibuja mediante la construcción de un círculo imaginario con el radio especificado alrededor del punto central especificado. El punto inicial del arco se determina midiendo en sentido contrario a las agujas del reloj desde el eje x del círculo el número de grados del ángulo inicial. El punto final se encuentra de forma similar al medir en sentido contrario a las agujas del reloj desde el punto inicial el número de grados en el ángulo de barrido.

Si el ángulo de barrido es mayor que 360 grados, el arco se barre varias veces. Esta función dibuja líneas utilizando el lápiz actual. La figura no se rellena.

##  <a name="arc"></a>CDC:: arco

Dibuja un arco elíptico.

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parámetros

*1*<br/>
Especifica la coordenada x de la esquina superior izquierda del rectángulo delimitador (en unidades lógicas).

*y1*<br/>
Especifica la coordenada y de la esquina superior izquierda del rectángulo delimitador (en unidades lógicas).

*RCA*<br/>
Especifica la coordenada x de la esquina inferior derecha del rectángulo delimitador (en unidades lógicas).

*a2*<br/>
Especifica la coordenada y de la esquina inferior derecha del rectángulo delimitador (en unidades lógicas).

*X3*<br/>
Especifica la coordenada x del punto que define el punto inicial del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco.

*Single*<br/>
Especifica la coordenada y del punto que define el punto inicial del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco.

*x4*<br/>
Especifica la coordenada x del punto que define el punto de conexión del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco.

*Y4*<br/>
Especifica la coordenada y del punto que define el punto de conexión del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco.

*lpRect*<br/>
Especifica el rectángulo delimitador (en unidades lógicas). Puede pasar un objeto LPRECT o [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parámetro.

*ptStart*<br/>
Especifica las coordenadas x e y del punto que define el punto inicial del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco. Puede pasar una estructura de [punto](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parámetro.

*ptEnd*<br/>
Especifica las coordenadas x e y del punto que define el punto final del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco. Puede pasar una estructura `POINT` o un objeto `CPoint` para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El arco dibujado mediante la función es un segmento de la elipse definida por el rectángulo delimitador especificado.

El punto inicial real del arco es el punto en el que un rayo dibujado desde el centro del rectángulo delimitador a través del punto inicial especificado forma una intersección con la elipse. El punto final real del arco es el punto en el que un rayo dibujado desde el centro del rectángulo delimitador a través del punto final especificado forma una intersección con la elipse. El arco se dibuja en sentido contrario a las agujas del reloj. Puesto que un arco no es una figura cerrada, no se rellena. El ancho y el alto del rectángulo deben ser mayores de 2 unidades y menos de 32.767 unidades.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

##  <a name="arcto"></a>CDC:: ArcTo

Dibuja un arco elíptico.

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parámetros

*1*<br/>
Especifica la coordenada x de la esquina superior izquierda del rectángulo delimitador (en unidades lógicas).

*y1*<br/>
Especifica la coordenada y de la esquina superior izquierda del rectángulo delimitador (en unidades lógicas).

*RCA*<br/>
Especifica la coordenada x de la esquina inferior derecha del rectángulo delimitador (en unidades lógicas).

*a2*<br/>
Especifica la coordenada y de la esquina inferior derecha del rectángulo delimitador (en unidades lógicas).

*X3*<br/>
Especifica la coordenada x del punto que define el punto inicial del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco.

*Single*<br/>
Especifica la coordenada y del punto que define el punto inicial del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco.

*x4*<br/>
Especifica la coordenada x del punto que define el punto de conexión del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco.

*Y4*<br/>
Especifica la coordenada y del punto que define el punto de conexión del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco.

*lpRect*<br/>
Especifica el rectángulo delimitador (en unidades lógicas). Puede pasar un puntero a una estructura de datos [Rect](/windows/win32/api/windef/ns-windef-rect) o un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parámetro.

*ptStart*<br/>
Especifica las coordenadas x e y del punto que define el punto inicial del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco. Puede pasar una estructura de datos de [punto](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parámetro.

*ptEnd*<br/>
Especifica las coordenadas x e y del punto que define el punto final del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco. Puede pasar una estructura de datos `POINT` o un objeto `CPoint` para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función es similar a `CDC::Arc`, excepto en que se actualiza la posición actual. Los puntos ( *x1*, *Y1*) y ( *x2*, *Y2*) especifican el rectángulo delimitador. Una elipse formada por el rectángulo delimitador especificado define la curva del arco. El arco se extiende en sentido contrario a las agujas del reloj (la dirección del arco predeterminado) desde el punto en el que forma una intersección con la línea radial desde el centro del rectángulo delimitador hasta ( *x3*, *Y3*). El arco termina donde forma una intersección con la línea radial desde el centro del rectángulo delimitador hasta ( *x4*, *Y4*). Si el punto inicial y el punto final son los mismos, se dibuja una elipse completa.

Una línea se dibuja desde la posición actual hasta el punto inicial del arco. Si no se produce ningún error, la posición actual se establece en el punto final del arco. El arco se dibuja utilizando el lápiz actual; no se rellena.

##  <a name="attach"></a>CDC:: Attach

Utilice esta función miembro para adjuntar una *HDC* al objeto de `CDC`.

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>Parámetros

*Cámaras*<br/>
Un contexto de dispositivo de Windows.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

*HDC* se almacena en `m_hDC`, el contexto de dispositivo de salida y, en `m_hAttribDC`, el contexto de dispositivo de atributo.

##  <a name="beginpath"></a>CDC:: BeginPath

Abre un corchete de ruta de acceso en el contexto del dispositivo.

```
BOOL BeginPath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Después de abrir un corchete de ruta de acceso, una aplicación puede empezar a llamar a funciones de dibujo de GDI para definir los puntos que se encuentran en la ruta de acceso. Una aplicación puede cerrar un corchete de ruta de acceso de apertura llamando a la función miembro `EndPath`. Cuando una aplicación llama a `BeginPath`, se descartan las rutas de acceso anteriores.

Vea [BeginPath](/windows/win32/api/wingdi/nf-wingdi-beginpath) en el Windows SDK para obtener una lista de las funciones de dibujo que definen los puntos de un trazado.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

##  <a name="bitblt"></a>CDC:: BitBlt

Copia un mapa de bits desde el contexto de dispositivo de origen a este contexto de dispositivo actual.

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo de destino.

*y*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo de destino.

*nWidth*<br/>
Especifica el ancho (en unidades lógicas) del rectángulo de destino y el mapa de bits de origen.

*nHeight*<br/>
Especifica el alto (en unidades lógicas) del rectángulo de destino y el mapa de bits de origen.

*pSrcDC*<br/>
Puntero a un objeto `CDC` que identifica el contexto de dispositivo desde el que se copiará el mapa de bits. Debe ser NULL si *dwRop* especifica una operación de trama que no incluye un origen.

*xSrc*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del mapa de bits de origen.

*ySrc*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del mapa de bits de origen.

*dwRop*<br/>
Especifica la operación de trama que se va a realizar. Los códigos de operación de trama definen cómo combina la GDI los colores de las operaciones de salida que implican un pincel actual, un mapa de bits de origen posible y un mapa de bits de destino. Consulte [bitblt](/windows/win32/api/wingdi/nf-wingdi-bitblt) en el Windows SDK para obtener una lista de los códigos de operación de trama para *dwRop* y sus descripciones.

Para obtener una lista completa de los códigos de operación de trama, consulte Acerca de los [códigos de operación de trama](/windows/win32/gdi/raster-operation-codes) en el Windows SDK.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La aplicación puede alinear las áreas de Windows o cliente en los límites de bytes para asegurarse de que las operaciones de `BitBlt` se producen en rectángulos alineados con bytes. (Establezca las marcas CS_BYTEALIGNWINDOW o CS_BYTEALIGNCLIENT al registrar las clases de ventana).

`BitBlt` operaciones en rectángulos alineados en bytes son mucho más rápidas que `BitBlt` operaciones en rectángulos que no están alineados en bytes. Si desea especificar estilos de clase como la alineación de bytes para su propio contexto de dispositivo, tendrá que registrar una clase de ventana en lugar de basarse en Microsoft Foundation Classes para hacerlo. Use la función global [AfxRegisterWndClass (](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).

GDI transforma *nWidth* y *nHeight*, una vez mediante el contexto de dispositivo de destino y una vez mediante el contexto de dispositivo de origen. Si las extensiones resultantes no coinciden, GDI usa la función `StretchBlt` de Windows para comprimir o expandir el mapa de bits de origen según sea necesario.

Si los mapas de bits de destino, origen y patrón no tienen el mismo formato de color, la función `BitBlt` convierte los mapas de bits de origen y de patrón para que coincidan con el destino. Los colores de primer plano y de fondo del mapa de bits de destino se utilizan en la conversión.

Cuando la función `BitBlt` convierte un mapa de bits monocromo en color, establece los bits blancos (1) en el color de fondo y los bits negros (0) en el color de primer plano. Se usan los colores de primer plano y de fondo del contexto de dispositivo de destino. Para convertir el color en monocromo, `BitBlt` establece en blanco los píxeles que coinciden con el color de fondo y establece todos los demás píxeles en negro. `BitBlt` usa los colores de primer plano y de fondo del contexto de dispositivo de color para convertir de color a monocromo.

Tenga en cuenta que no todos los contextos de dispositivo admiten `BitBlt`. Para comprobar si un determinado contexto de dispositivo admite `BitBlt`, utilice la función miembro `GetDeviceCaps` y especifique el índice RASTERCAPS.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC:: CreateCompatibleDC](#createcompatibledc).

##  <a name="cdc"></a>CDC:: CDC

Construye un objeto `CDC`.

```
CDC();
```

##  <a name="chord"></a>CDC:: cuerda

Dibuja una cuerda (una figura cerrada enlazada por la intersección de una elipse y un segmento de línea).

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parámetros

*1*<br/>
Especifica la coordenada x de la esquina superior izquierda del rectángulo delimitador de cuerda (en unidades lógicas).

*y1*<br/>
Especifica la coordenada y de la esquina superior izquierda del rectángulo delimitador de cuerda (en unidades lógicas).

*RCA*<br/>
Especifica la coordenada x de la esquina inferior derecha del rectángulo delimitador de cuerda (en unidades lógicas).

*a2*<br/>
Especifica la coordenada y de la esquina inferior derecha del rectángulo delimitador de cuerda (en unidades lógicas).

*X3*<br/>
Especifica la coordenada x del punto que define el punto inicial de la cuerda (en unidades lógicas).

*Single*<br/>
Especifica la coordenada y del punto que define el punto inicial de la cuerda (en unidades lógicas).

*x4*<br/>
Especifica la coordenada x del punto que define el punto de conexión de la cuerda (en unidades lógicas).

*Y4*<br/>
Especifica la coordenada y del punto que define el punto de conexión de la cuerda (en unidades lógicas).

*lpRect*<br/>
Especifica el rectángulo delimitador (en unidades lógicas). Puede pasar un objeto LPRECT o [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parámetro.

*ptStart*<br/>
Especifica las coordenadas x e y del punto que define el punto inicial de la cuerda (en unidades lógicas). Este punto no tiene que estar en la misma presión. Puede pasar una estructura `POINT` o un objeto `CPoint` para este parámetro.

*ptEnd*<br/>
Especifica las coordenadas x e y del punto que define el punto final de la cuerda (en unidades lógicas). Este punto no tiene que estar en la misma presión. Puede pasar una estructura de [punto](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Los parámetros ( *x1*, *Y1*) y ( *x2*, *Y2*) especifican las esquinas superior izquierda e inferior derecha, respectivamente, de un rectángulo que delimita la elipse que forma parte de la cuerda. Los parámetros ( *x3*, *Y3*) y ( *x4*, *Y4*) especifican los extremos de una línea que forma una intersección con la elipse. La cuerda se dibuja con el lápiz seleccionado y se rellena con el pincel seleccionado.

La ilustración dibujada por la función `Chord` extiende hasta, pero no incluye las coordenadas derecha e inferior. Esto significa que el alto de la figura es *y2* - *Y1* y el ancho de la ilustración es *x2* - *x1*.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

##  <a name="closefigure"></a>CDC:: CloseFigure

Cierra una figura abierta en una ruta de acceso.

```
BOOL CloseFigure();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La función cierra la figura dibujando una línea desde la posición actual hasta el primer punto de la ilustración (normalmente, el punto especificado por la llamada más reciente a la función miembro `MoveTo`) y conecta las líneas mediante el estilo de combinación de línea. Si se cierra una figura mediante el `LineTo` función miembro en lugar de `CloseFigure`, se usan extremos finales para crear la esquina en lugar de una combinación. solo se debe llamar a `CloseFigure` si hay un corchete de ruta de acceso abierto en el contexto del dispositivo.

Una figura de un trazado está abierta a menos que se cierre explícitamente mediante esta función. (Una figura puede abrirse incluso si el punto actual y el punto inicial de la figura son los mismos). Cualquier línea o curva agregada a la ruta de acceso después de `CloseFigure` inicia una nueva figura.

##  <a name="createcompatibledc"></a>CDC:: CreateCompatibleDC

Crea un contexto de dispositivo de memoria que es compatible con el dispositivo especificado por *pDC*.

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>Parámetros

*pDC*<br/>
Puntero a un contexto de dispositivo. Si *pDC* es null, la función crea un contexto de dispositivo de memoria que es compatible con la pantalla del sistema.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Un contexto de dispositivo de memoria es un bloque de memoria que representa una superficie de presentación. Se puede usar para preparar imágenes en la memoria antes de copiarlas en la superficie real del dispositivo del dispositivo compatible.

Cuando se crea un contexto de dispositivo de memoria, GDI selecciona automáticamente un mapa de bits de existencias monocromáticas 1 por 1 para él. Las funciones de salida de GDI se pueden usar con un contexto de dispositivo de memoria solo si se ha creado un mapa de bits y se ha seleccionado en ese contexto.

Esta función solo se puede usar para crear contextos de dispositivo compatibles para dispositivos que admiten operaciones de tramas. Vea la función miembro [CDC:: bitblt](#bitblt) para obtener información sobre las transferencias de bloque de bits entre los contextos de dispositivo. Para determinar si un contexto de dispositivo admite operaciones de tramas, consulte la funcionalidad RC_BITBLT raster en la función miembro `CDC::GetDeviceCaps`.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

##  <a name="createdc"></a>CDC:: CreateDC

Crea un contexto de dispositivo para el dispositivo especificado.

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parámetros

*lpszDriverName*<br/>
Apunta a una cadena terminada en null que especifica el nombre de archivo (sin extensión) del controlador de dispositivo (por ejemplo, "EPSON"). También puede pasar un objeto `CString` para este parámetro.

*lpszDeviceName*<br/>
Apunta a una cadena terminada en null que especifica el nombre del dispositivo específico que se va a admitir (por ejemplo, "EPSON FX-80"). El parámetro *lpszDeviceName* se usa si el módulo admite más de un dispositivo. También puede pasar un objeto `CString` para este parámetro.

*lpszOutput*<br/>
Apunta a una cadena terminada en null que especifica el nombre de archivo o dispositivo para el medio de salida físico (puerto de archivo o de salida). También puede pasar un objeto `CString` para este parámetro.

*lpInitData*<br/>
Apunta a una estructura de `DEVMODE` que contiene los datos de inicialización específicos del dispositivo para el controlador de dispositivo. La función `DocumentProperties` de Windows recupera esta estructura rellenada para un dispositivo determinado. El parámetro *lpInitData* debe ser null si el controlador de dispositivo va a usar la inicialización predeterminada (si existe) especificada por el usuario a través del panel de control.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La impresión. El archivo de encabezado H es obligatorio si se usa la estructura [DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea) .

Los nombres de dispositivo siguen estas convenciones: un signo de dos puntos (:) se recomienda, pero opcional. Windows quita los dos puntos de terminación para que el nombre de un dispositivo que termina con un signo de dos puntos esté asignado al mismo puerto que el nombre sin dos puntos. Los nombres de controlador y puerto no deben contener espacios iniciales ni finales. Las funciones de salida de GDI no se pueden usar con contextos de información.

##  <a name="createic"></a>CDC:: creat

Crea un contexto de información para el dispositivo especificado.

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parámetros

*lpszDriverName*<br/>
Apunta a una cadena terminada en null que especifica el nombre de archivo (sin extensión) del controlador de dispositivo (por ejemplo, "EPSON"). Puede pasar un objeto `CString` para este parámetro.

*lpszDeviceName*<br/>
Apunta a una cadena terminada en null que especifica el nombre del dispositivo específico que se va a admitir (por ejemplo, "EPSON FX-80"). El parámetro *lpszDeviceName* se usa si el módulo admite más de un dispositivo. Puede pasar un objeto `CString` para este parámetro.

*lpszOutput*<br/>
Apunta a una cadena terminada en null que especifica el nombre de archivo o dispositivo para el medio de salida físico (archivo o puerto). Puede pasar un objeto `CString` para este parámetro.

*lpInitData*<br/>
Apunta a los datos de inicialización específicos del dispositivo para el controlador de dispositivo. El parámetro *lpInitData* debe ser null si el controlador de dispositivo va a usar la inicialización predeterminada (si existe) especificada por el usuario a través del panel de control. Consulte `CreateDC` para el formato de datos para la inicialización específica del dispositivo.

### <a name="return-value"></a>Valor devuelto

Si es correcta, su valor es distinto de cero. En caso contrario, es cero.

### <a name="remarks"></a>Observaciones

El contexto de información proporciona una forma rápida de obtener información sobre el dispositivo sin crear un contexto de dispositivo.

Los nombres de dispositivo siguen estas convenciones: un signo de dos puntos (:) se recomienda, pero opcional. Windows quita los dos puntos de terminación para que el nombre de un dispositivo que termina con un signo de dos puntos esté asignado al mismo puerto que el nombre sin dos puntos. Los nombres de controlador y puerto no deben contener espacios iniciales ni finales. Las funciones de salida de GDI no se pueden usar con contextos de información.

##  <a name="deletedc"></a>CDC::D eleteDC

En general, no llame a esta función; el destructor lo hará automáticamente.

```
BOOL DeleteDC();
```

### <a name="return-value"></a>Valor devuelto

Distinto de cero si la función se completó correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La función miembro `DeleteDC` elimina los contextos de dispositivo de Windows asociados a `m_hDC` en el objeto de `CDC` actual. Si este `CDC` objeto es el último contexto de dispositivo activo para un dispositivo determinado, se notifica al dispositivo y se liberan todos los recursos de almacenamiento y del sistema utilizados por el dispositivo.

Una aplicación no debe llamar a `DeleteDC` si se han seleccionado objetos en el contexto del dispositivo. Los objetos deben seleccionarse primero fuera del contexto del dispositivo antes de que se eliminen.

Una aplicación no debe eliminar un contexto de dispositivo cuyo identificador se haya obtenido mediante una llamada a [CWnd:: GetDC](../../mfc/reference/cwnd-class.md#getdc). En su lugar, debe llamar a [CWnd:: ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) para liberar el contexto del dispositivo. Se proporcionan las clases [CClientDC (](../../mfc/reference/cclientdc-class.md) y [CWindowDC](../../mfc/reference/cwindowdc-class.md) para encapsular esta funcionalidad.

La función `DeleteDC` se usa generalmente para eliminar contextos de dispositivo creados con [CreateDC](#createdc), [Create](#createic)o [CreateCompatibleDC](#createcompatibledc).

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CPrintDialog:: GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

##  <a name="deletetempmap"></a>CDC::D eleteTempMap

Llamado automáticamente por el controlador de tiempo de inactividad de `CWinApp`, `DeleteTempMap` elimina los objetos `CDC` temporales creados por `FromHandle`, pero no destruye los identificadores de contexto del dispositivo (`hDC`s) temporalmente asociados a los objetos `CDC`.

```
static void PASCAL DeleteTempMap();
```

##  <a name="detach"></a>CDC::D Etach

Llame a esta función para desasociar `m_hDC` (el contexto del dispositivo de salida) del objeto `CDC` y establecer `m_hDC` y `m_hAttribDC` en NULL.

```
HDC Detach();
```

### <a name="return-value"></a>Valor devuelto

Un contexto de dispositivo de Windows.

##  <a name="dptohimetric"></a>CDC::D PtoHIMETRIC

Use esta función cuando asigne tamaños de HIMETRIC a OLE, convierta píxeles en HIMETRIC.

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*lpSize*<br/>
Apunta a una estructura de [tamaño](/windows/win32/api/windef/ns-windef-size) o a un objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Observaciones

Si el modo de asignación del objeto de contexto del dispositivo es MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC o MM_HIMETRIC, la conversión se basa en el número de píxeles de la pulgada física. Si el modo de asignación es uno de los otros modos no restringidos (por ejemplo, MM_TEXT), la conversión se basa en el número de píxeles de la pulgada lógica.

##  <a name="dptolp"></a>CDC::D PtoLP

Convierte unidades de dispositivo en unidades lógicas.

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de estructuras de [punto](/windows/win32/api/windef/ns-windef-point) o objetos [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

*nCount*<br/>
Número de puntos de la matriz.

*lpRect*<br/>
Apunta a una estructura [Rect](/windows/win32/api/windef/ns-windef-rect) o a un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) . Este parámetro se usa para el caso simple de conversión de un rectángulo de puntos de dispositivo a puntos lógicos.

*lpSize*<br/>
Apunta a una estructura de [tamaño](/windows/win32/api/windef/ns-windef-size) o a un objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Observaciones

La función asigna las coordenadas de cada punto, o dimensión de un tamaño, del sistema de coordenadas del dispositivo al sistema de coordenadas lógico de GDI. La conversión depende del modo de asignación actual y de la configuración de los orígenes y las extensiones para la ventana y la ventanilla del dispositivo.

##  <a name="draw3drect"></a>CDC::D raw3dRect

Llame a esta función miembro para dibujar un rectángulo tridimensional.

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Especifica el rectángulo delimitador (en unidades lógicas). Puede pasar un puntero a una estructura [Rect](/windows/win32/api/windef/ns-windef-rect) o un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parámetro.

*clrTopLeft*<br/>
Especifica el color de los lados superior e izquierdo del rectángulo tridimensional.

*clrBottomRight*<br/>
Especifica el color de los lados inferior y derecho del rectángulo tridimensional.

*x*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo tridimensional.

*y*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo tridimensional.

*serie*<br/>
Especifica el ancho del rectángulo tridimensional.

*CY*<br/>
Especifica el alto del rectángulo tridimensional.

### <a name="remarks"></a>Observaciones

El rectángulo se dibujará con los lados superior e izquierdo en el color especificado por *clrTopLeft* y los lados inferior y derecho en el color especificado por *clrBottomRight*.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

##  <a name="drawdragrect"></a>CDC::D rawDragRect

Llame a esta función miembro repetidamente para volver a dibujar un rectángulo de arrastre.

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Apunta a una estructura [Rect](/windows/win32/api/windef/ns-windef-rect) o a un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que especifica las coordenadas lógicas de un rectángulo; en este caso, se vuelve a dibujar la posición final del rectángulo.

*size*<br/>
Especifica el desplazamiento de la esquina superior izquierda del borde exterior a la esquina superior izquierda del borde interior (es decir, el grosor del borde) de un rectángulo.

*lpRectLast*<br/>
Apunta a una estructura [Rect](/windows/win32/api/windef/ns-windef-rect) o a un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que especifica las coordenadas lógicas de la posición de un rectángulo; en este caso, se vuelve a dibujar la posición original del rectángulo.

*sizeLast*<br/>
Especifica el desplazamiento desde la esquina superior izquierda del borde exterior hasta la esquina superior izquierda del borde interior (es decir, el grosor del borde) del rectángulo original que se vuelve a dibujar.

*pBrush*<br/>
Puntero a un objeto Brush. Establezca en NULL para usar el pincel de semitono predeterminado.

*pBrushLast*<br/>
Puntero al último objeto Brush usado. Establezca en NULL para usar el pincel de semitono predeterminado.

### <a name="remarks"></a>Observaciones

Llámelo en un bucle mientras muestrea la posición del mouse para proporcionar comentarios visuales. Cuando se llama a `DrawDragRect`, se borra el rectángulo anterior y se dibuja uno nuevo. Por ejemplo, a medida que el usuario arrastra un rectángulo por la pantalla, `DrawDragRect` borrará el rectángulo original y volverá a dibujar uno nuevo en su nueva posición. De forma predeterminada, `DrawDragRect` dibuja el rectángulo mediante un pincel de semitono para eliminar el parpadeo y crear la apariencia de un rectángulo que se mueve suavemente.

La primera vez que llame a `DrawDragRect`, el parámetro *lpRectLast* debe ser null.

##  <a name="drawedge"></a>CDC::D rawEdge

Llame a esta función miembro para dibujar los bordes de un rectángulo del tipo y estilo especificados.

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Puntero a una estructura de `RECT` que contiene las coordenadas lógicas del rectángulo.

*nEdge*<br/>
Especifica el tipo de borde interno y externo que se va a dibujar. Este parámetro debe ser una combinación de una marca de borde interno y una marca de borde exterior. Vea [DrawEdge](/windows/win32/api/winuser/nf-winuser-drawedge) en el Windows SDK para obtener una tabla de los tipos del parámetro.

*nFlags*<br/>
Marcas que especifican el tipo de borde que se va a dibujar. Vea `DrawEdge` en el Windows SDK para obtener una tabla de los valores del parámetro. En el caso de las líneas diagonales, las marcas de BF_RECT especifican el punto final del vector delimitado por el parámetro de rectángulo.

### <a name="return-value"></a>Valor devuelto

Si es correcta, su valor es distinto de cero. En caso contrario, es cero.

##  <a name="drawescape"></a>CDC::D rawEscape

Obtiene acceso a las funciones de dibujo de una pantalla de vídeo que no están directamente disponibles a través de la interfaz de dispositivo gráfico (GDI).

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>Parámetros

*nEscape*<br/>
Especifica la función de escape que se va a realizar.

*nInputSize*<br/>
Especifica el número de bytes de datos a los que apunta el parámetro *lpszInputData* .

*lpszInputData*<br/>
Apunta a la estructura de entrada necesaria para el escape especificado.

### <a name="return-value"></a>Valor devuelto

Especifica el resultado de la función. Mayor que cero si se realiza correctamente, excepto para el escape QUERYESCSUPPORT Draw, que solo comprueba la implementación; o cero si no se ha implementado el escape; o menor que cero si se ha producido un error.

### <a name="remarks"></a>Observaciones

Cuando una aplicación llama a `DrawEscape`, los datos identificados por *nInputSize* y *lpszInputData* se pasan directamente al controlador de pantalla especificado.

##  <a name="drawfocusrect"></a>CDC::D rawFocusRect

Dibuja un rectángulo en el estilo utilizado para indicar que el rectángulo tiene el foco.

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Apunta a una estructura [Rect](/windows/win32/api/windef/ns-windef-rect) o a un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que especifica las coordenadas lógicas del rectángulo que se va a dibujar.

### <a name="remarks"></a>Observaciones

Dado que se trata de una función XOR booleana, al llamar a esta función una segunda vez con el mismo rectángulo se quita el rectángulo de la pantalla. No se puede desplazar el rectángulo dibujado por esta función. Para desplazar un área que contiene un rectángulo dibujado por esta función, primero llame a `DrawFocusRect` para quitar el rectángulo de la pantalla y, a continuación, desplácese por el área y, a continuación, vuelva a llamar a `DrawFocusRect` para dibujar el rectángulo en la nueva posición.

> [!CAUTION]
> `DrawFocusRect` solo funciona en el modo de MM_TEXT. En otros modos, esta función no dibuja correctamente el rectángulo de foco, pero no devuelve valores de error.

##  <a name="drawframecontrol"></a>CDC::D rawFrameControl

Llame a esta función miembro para dibujar un control de marco del tipo y estilo especificados.

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Puntero a una estructura de `RECT` que contiene las coordenadas lógicas del rectángulo.

*nType*<br/>
Especifica el tipo de control de marco que se va a dibujar. Vea el parámetro *uType* en [DrawFrameControl](/windows/win32/api/winuser/nf-winuser-drawframecontrol) en el Windows SDK para obtener una lista de los valores posibles de este parámetro.

*nState*<br/>
Especifica el estado inicial del control de marco. Puede ser uno o varios de los valores descritos para el parámetro *uState* en `DrawFrameControl` en el Windows SDK. Use el valor *nState* DFCS_ADJUSTRECT para ajustar el rectángulo delimitador para excluir el borde circundante del botón de la tecla de reentrada.

### <a name="return-value"></a>Valor devuelto

Si es correcta, su valor es distinto de cero. En caso contrario, es cero.

### <a name="remarks"></a>Observaciones

En varios casos, *nState* depende del parámetro *ndeclaraciones* . La lista siguiente muestra la relación entre los cuatro valores de *ndeclaraciones* y *nState*:

- DFC_BUTTON

    - DFCS_BUTTON3STATE botón de tres Estados

    - Casilla de DFCS_BUTTONCHECK

    - DFCS_BUTTONPUSH botón de reenvío

    - DFCS_BUTTONRADIO botón de radio

    - Imagen de DFCS_BUTTONRADIOIMAGE para el botón de radio (imagen de necesidades no cuadradas)

    - DFCS_BUTTONRADIOMASK máscara para el botón de radio (no se necesita máscara)

- DFC_CAPTION

    - Botón Cerrar DFCS_CAPTIONCLOSE

    - DFCS_CAPTIONHELP botón ayuda

    - DFCS_CAPTIONMAX botón maximizar

    - DFCS_CAPTIONMIN botón minimizar

    - Botón restaurar DFCS_CAPTIONRESTORE

- DFC_MENU

    - DFCS_MENUARROW flecha de submenú

    - DFCS_MENUBULLET viñeta

    - DFCS_MENUCHECK marca de verificación

- DFC_SCROLL

    - Barra de desplazamiento de DFCS_SCROLLCOMBOBOX cuadro combinado

    - DFCS_SCROLLDOWN flecha abajo de la barra de desplazamiento

    - DFCS_SCROLLLEFT flecha izquierda de la barra de desplazamiento

    - DFCS_SCROLLRIGHT flecha derecha de la barra de desplazamiento

    - DFCS_SCROLLSIZEGRIP control de tamaño en la esquina inferior derecha de la ventana

    - DFCS_SCROLLUP flecha arriba de la barra de desplazamiento

### <a name="example"></a>Ejemplo

Este código dibuja el agarrador de tamaño en la esquina inferior derecha de la ventana. Es adecuado para el controlador de `OnPaint` de un cuadro de diálogo, que no tiene estilos y normalmente no contiene otros controles (por ejemplo, una barra de estado) que pueda darle un agarrador de tamaño.

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

##  <a name="drawicon"></a>CDC::D rawIcon

Dibuja un icono en el dispositivo representado por el objeto `CDC` actual.

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del icono.

*y*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del icono.

*hIcon*<br/>
Identifica el identificador del icono que se va a dibujar.

*Elija*<br/>
Especifica las coordenadas lógicas x e y de la esquina superior izquierda del icono. Puede pasar una estructura de [punto](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parámetro.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si la función se completó correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La función coloca la esquina superior izquierda del icono en la ubicación especificada por *x* *e y*. La ubicación está sujeta al modo de asignación actual del contexto del dispositivo.

El recurso de icono se debe haber cargado previamente mediante las funciones `CWinApp::LoadIcon`, `CWinApp::LoadStandardIcon`o `CWinApp::LoadOEMIcon`. El modo de asignación de `MM_TEXT` debe estar seleccionado antes de usar esta función.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CWnd:: IsIconic](../../mfc/reference/cwnd-class.md#isiconic).

##  <a name="drawstate"></a>CDC::D rawState

Llame a esta función miembro para mostrar una imagen y aplicar un efecto visual para indicar un estado, como un Estado deshabilitado o predeterminado.

> [!NOTE]
>  Para todos los Estados de *nFlag* excepto DSS_NORMAL, la imagen se convierte en monocromo antes de aplicar el efecto visual.

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>Parámetros

*pt*<br/>
Especifica la ubicación de la imagen.

*size*<br/>
Especifica el tamaño de la imagen.

*hBitmap*<br/>
Identificador de un mapa de bits.

*nFlags*<br/>
Marcas que especifican el tipo y el estado de la imagen. Consulte [DrawState](/windows/win32/api/winuser/nf-winuser-drawstatew) en el Windows SDK para ver los tipos y Estados de *nFlags* posibles.

*hBrush*<br/>
Identificador de un pincel.

*pBitmap*<br/>
Un puntero a un objeto CBitmap.

*pBrush*<br/>
Un puntero a un objeto CBrush (.

*hIcon*<br/>
Identificador de un icono.

*lpszText*<br/>
Puntero a texto.

*bPrefixText*<br/>
Texto que puede contener una tecla de método abreviado. El parámetro *lData* especifica la dirección de la cadena y el parámetro *nTextLen* especifica la longitud. Si *nTextLen* es 0, se supone que la cadena termina en NULL.

*nTextLen*<br/>
Longitud de la cadena de texto a la que apunta *lpszText*. Si *nTextLen* es 0, se supone que la cadena termina en NULL.

*lpDrawProc*<br/>
Puntero a una función de devolución de llamada que se usa para representar una imagen. Este parámetro es necesario si el tipo de imagen en *nFlags* es DST_COMPLEX. Es opcional y puede ser NULL si el tipo de imagen es DST_TEXT. Para el resto de tipos de imagen, este parámetro se omite. Para obtener más información sobre la función de devolución de llamada, vea la función [DrawStateProc](/windows/win32/api/winuser/nc-winuser-drawstateproc) en el Windows SDK.

*lData*<br/>
Especifica información sobre la imagen. El significado de este parámetro depende del tipo de imagen.

### <a name="return-value"></a>Valor devuelto

Si es correcta, su valor es distinto de cero. En caso contrario, es cero.

##  <a name="drawtext"></a>CDC::D rawText

Llame a esta función miembro para dar formato al texto del rectángulo especificado. Para especificar opciones de formato adicionales, use [CDC::D rawtextex](#drawtextex).

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>Parámetros

*lpszString*<br/>
Apunta a la cadena que se va a dibujar. Si *nCount* es-1, la cadena debe terminar en NULL.

*nCount*<br/>
Especifica el número de caracteres de la cadena. Si *nCount* es-1, se supone que *lpszString* es un puntero largo a una cadena terminada en NULL y `DrawText` calcula el recuento de caracteres automáticamente.

*lpRect*<br/>
Apunta a una estructura [Rect](/windows/win32/api/windef/ns-windef-rect) o a un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que contiene el rectángulo (en coordenadas lógicas) en el que se va a dar formato al texto.

*str*<br/>
Objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) que contiene los caracteres especificados que se van a dibujar.

*nFormat*<br/>
Especifica el método para dar formato al texto. Puede ser cualquier combinación de los valores descritos para el parámetro *uFormat* en [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) en el Windows SDK. (combinar mediante el operador bit a bit or):

> [!NOTE]
>  Algunas combinaciones de marcas de *uFormat* pueden hacer que se modifique la cadena pasada. El uso de DT_MODIFYSTRING con DT_END_ELLIPSIS o DT_PATH_ELLIPSIS puede hacer que se modifique la cadena, lo que provoca una aserción en la invalidación de `CString`. Los valores DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP y DT_NOPREFIX no se pueden usar con el valor DT_TABSTOP.

### <a name="return-value"></a>Valor devuelto

Alto del texto si la función se realiza correctamente.

### <a name="remarks"></a>Observaciones

Da formato al texto expandiendo las pestañas en los espacios adecuados, alineando el texto a la izquierda, a la derecha o en el centro del rectángulo determinado y dividiendo el texto en líneas que caben dentro del rectángulo especificado. El tipo de formato se especifica mediante *nFormat*.

Esta función miembro usa la fuente, el color de texto y el color de fondo seleccionados del contexto de dispositivo para dibujar el texto. A menos que se use el formato de DT_NOCLIP, `DrawText` recorta el texto para que el texto no aparezca fuera del rectángulo especificado. Se supone que todo el formato tiene varias líneas a menos que se proporcione el formato de DT_SINGLELINE.

Si la fuente seleccionada es demasiado grande para el rectángulo especificado, la función miembro `DrawText` no intenta sustituir una fuente menor.

Si se especifica la marca DT_CALCRECT, el rectángulo especificado por *lpRect* se actualizará para reflejar el ancho y el alto necesarios para dibujar el texto.

Si se ha establecido la marca de alineación de texto TA_UPDATECP (vea [CDC:: SetTextAlign](#settextalign)), `DrawText` mostrará el texto a partir de la posición actual, en lugar de a la izquierda del rectángulo especificado. `DrawText` no ajustará el texto cuando se haya establecido la marca de TA_UPDATECP (es decir, la marca DT_WORDBREAK no tendrá ningún efecto).

[CDC:: SetTextColor](#settextcolor)puede establecer el color del texto.

##  <a name="drawtextex"></a>CDC::D rawTextEx

Da formato al texto del rectángulo especificado.

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>Parámetros

*lpszString*<br/>
Apunta a la cadena que se va a dibujar. Si *nCount* es-1, la cadena debe terminar en NULL.

*nCount*<br/>
Especifica el número de caracteres de la cadena. Si *nCount* es-1, se supone que *lpszString* es un puntero largo a una cadena terminada en NULL y `DrawText` calcula el recuento de caracteres automáticamente.

*lpRect*<br/>
Apunta a una estructura [Rect](/windows/win32/api/windef/ns-windef-rect) o a un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que contiene el rectángulo (en coordenadas lógicas) en el que se va a dar formato al texto.

*str*<br/>
Objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) que contiene los caracteres especificados que se van a dibujar.

*nFormat*<br/>
Especifica el método para dar formato al texto. Puede ser cualquier combinación de los valores descritos para el parámetro *uFormat* en [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) en el Windows SDK. (Combinar mediante **el operador bit a bit or)** :

> [!NOTE]
>  Algunas combinaciones de marcas de *uFormat* pueden hacer que se modifique la cadena pasada. El uso de DT_MODIFYSTRING con DT_END_ELLIPSIS o DT_PATH_ELLIPSIS puede hacer que se modifique la cadena, lo que provoca una aserción en la invalidación de `CString`. Los valores DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP y DT_NOPREFIX no se pueden usar con el valor DT_TABSTOP.

*lpDTParams*<br/>
Puntero a una estructura [DRAWTEXTPARAMS](/windows/win32/api/winuser/ns-winuser-drawtextparams) que especifica opciones de formato adicionales. Este parámetro puede ser NULL.

### <a name="remarks"></a>Observaciones

Da formato al texto expandiendo las pestañas en los espacios adecuados, alineando el texto a la izquierda, a la derecha o en el centro del rectángulo determinado y dividiendo el texto en líneas que caben dentro del rectángulo especificado. El tipo de formato se especifica mediante *nFormat* y *lpDTParams*. Para obtener más información, vea [CDC::D rawtext](#drawtext) y [DrawTextEx](/windows/win32/api/winuser/nf-winuser-drawtextexw) en el Windows SDK.

[CDC:: SetTextColor](#settextcolor)puede establecer el color del texto.

##  <a name="ellipse"></a>CDC:: Ellipse

Dibuja una elipse.

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>Parámetros

*1*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo delimitador de la elipse.

*y1*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo delimitador de la elipse.

*RCA*<br/>
Especifica la coordenada x lógica de la esquina inferior derecha del rectángulo delimitador de la elipse.

*a2*<br/>
Especifica la coordenada y lógica de la esquina inferior derecha del rectángulo delimitador de la elipse.

*lpRect*<br/>
Especifica el rectángulo delimitador de la elipse. También puede pasar un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El centro de la elipse es el centro del rectángulo delimitador especificado por *x1*, *Y1*, *x2*e *Y2*, o *lpRect*. La elipse se dibuja con el lápiz actual y su interior se rellena con el pincel actual.

La ilustración dibujada por esta función extiende hasta, pero no incluye, las coordenadas derecha e inferior. Esto significa que el alto de la figura es *y2* - *Y1* y el ancho de la ilustración es *x2* - *x1*.

Si el ancho o el alto del rectángulo delimitador es 0, no se dibuja ninguna elipse.

##  <a name="enddoc"></a>CDC:: EndDoc

Finaliza un trabajo de impresión Iniciado por una llamada a la función miembro [StartDoc](#startdoc) .

```
int EndDoc();
```

### <a name="return-value"></a>Valor devuelto

Mayor o igual que 0 si la función es correcta, o un valor negativo si se produce un error.

### <a name="remarks"></a>Observaciones

Esta función miembro reemplaza el escape de la impresora ENDDOC y se debe llamar inmediatamente después de finalizar un trabajo de impresión correcto.

Si una aplicación encuentra un error de impresión o una operación de impresión cancelada, no debe intentar finalizar la operación mediante `EndDoc` o [AbortDoc](#abortdoc). GDI finaliza automáticamente la operación antes de devolver el valor de error.

Esta función no se debe usar dentro de los metaarchivos.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC:: StartDoc](#startdoc).

##  <a name="endpage"></a>CDC:: EndPage

Informa al dispositivo de que la aplicación ha terminado de escribir en una página.

```
int EndPage();
```

### <a name="return-value"></a>Valor devuelto

Mayor o igual que 0 si la función es correcta, o un valor negativo si se produce un error.

### <a name="remarks"></a>Observaciones

Esta función miembro se usa normalmente para indicar al controlador de dispositivo que avance a una nueva página.

Esta función miembro reemplaza el escape de la impresora NEWFRAME. A diferencia de NEWFRAME, siempre se llama a esta función después de imprimir una página.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC:: StartDoc](#startdoc).

##  <a name="endpath"></a>CDC:: EndPath

Cierra un corchete de ruta de acceso y selecciona la ruta de acceso definida por el corchete en el contexto del dispositivo.

```
BOOL EndPath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC:: BeginPath](#beginpath).

##  <a name="enumobjects"></a>CDC:: EnumObjects

Enumera los lápices y los pinceles disponibles en un contexto de dispositivo.

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>Parámetros

*nObjectType*<br/>
Especifica el tipo de objeto. Puede tener los valores OBJ_BRUSH o OBJ_PEN.

*lpfn*<br/>
Es la dirección de instancia de procedimiento de la función de devolución de llamada proporcionada por la aplicación. Vea la sección "Comentarios" a continuación.

*lpData*<br/>
Apunta a los datos proporcionados por la aplicación. Los datos se pasan a la función de devolución de llamada junto con la información del objeto.

### <a name="return-value"></a>Valor devuelto

Especifica el último valor devuelto por la [función de devolución de llamada](callback-functions-used-by-mfc.md#enum_objects). Su significado está definido por el usuario.

### <a name="remarks"></a>Observaciones

Para cada objeto de un tipo determinado, se llama a la función de devolución de llamada que se pasa con la información de ese objeto. El sistema llama a la función de devolución de llamada hasta que no hay más objetos o la función de devolución de llamada devuelve 0.

Tenga en cuenta que las nuevas características C++ de Microsoft Visual permiten usar una función ordinaria como la función que se pasa a `EnumObjects`. La dirección pasada a `EnumObjects` es un puntero a una función exportada con **Export** y con la Convención de llamada Pascal. En las aplicaciones en modo protegido, no es necesario crear esta función con la función MakeProcInstance de Windows o liberar la función después de usarla con la función de Windows FreeProcInstance.

Tampoco tiene que exportar el nombre de la función en una instrucción **Exports** en el archivo de definición de módulo de la aplicación. En su lugar, puede usar el modificador de función **Export** , como en

**exportación de devolución de llamada int** AFunction **(LPSTR**, **LPSTR);**

para hacer que el compilador emita el registro de exportación adecuado para exportar por nombre sin alias. Esto funciona con la mayoría de las necesidades. En algunos casos especiales, como la exportación de una función por ordinal o el suavizado de la exportación, todavía es necesario usar una instrucción **Exports** en un archivo de definición de módulo.

Para compilar programas de Microsoft Foundation, normalmente usará las opciones del compilador/GA y/GEs. La opción del compilador/GW no se usa con Microsoft Foundation Classes. (Si usa la función de Windows `MakeProcInstance`, deberá convertir explícitamente el puntero de función devuelto de FARPROC al tipo necesario en esta API). Las interfaces de registro de devolución de llamada ahora tienen seguridad de tipos (debe pasar un puntero de función que apunte al tipo correcto de función para la devolución de llamada específica).

Tenga en cuenta también que todas las funciones de devolución de llamada deben interceptar las excepciones de Microsoft Foundation antes de volver a Windows, ya que no se pueden iniciar excepciones en los límites de devolución de llamada. Para obtener más información sobre las excepciones, vea el artículo [excepciones](../../mfc/exception-handling-in-mfc.md).

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

##  <a name="escape"></a>CDC:: escape

Esta función miembro está prácticamente obsoleta para la programación de Win32.

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>Parámetros

*nEscape*<br/>
Especifica la función de escape que se va a realizar.

Para obtener una lista completa de las funciones de escape, vea [escape](/windows/win32/api/wingdi/nf-wingdi-escape) en el Windows SDK.

*nCount*<br/>
Especifica el número de bytes de datos a los que apunta *lpszInData*.

*lpszInData*<br/>
Apunta a la estructura de datos de entrada necesaria para este escape.

*lpOutData*<br/>
Apunta a la estructura que va a recibir la salida de este escape. El parámetro *lpOutData* es NULL si no se devuelve ningún dato.

*nInputSize*<br/>
Especifica el número de bytes de datos a los que apunta el parámetro *lpszInputData* .

*lpszInputData*<br/>
Apunta a la estructura de entrada necesaria para el escape especificado.

*nOutputSize*<br/>
Especifica el número de bytes de datos a los que apunta el parámetro *lpszOutputData* .

*lpszOutputData*<br/>
Apunta a la estructura que recibe la salida de este escape. Este parámetro debe ser NULL si no se devuelve ningún dato.

### <a name="return-value"></a>Valor devuelto

Se devuelve un valor positivo si la función es correcta, excepto para el escape QUERYESCSUPPORT, que solo comprueba la implementación. Se devuelve cero si no se implementa el escape. Se devuelve un valor negativo si se produce un error. Estos son los valores de error comunes:

- SP_ERROR error general.

- SP_OUTOFDISK espacio en disco insuficiente actualmente está disponible para la puesta en cola y no habrá más espacio disponible.

- SP_OUTOFMEMORY no hay suficiente memoria disponible para la puesta en cola.

- SP_USERABORT usuario finalizó el trabajo a través del administrador de impresión.

### <a name="remarks"></a>Observaciones

De los escapes de impresora originales, solo se admite QUERYESCSUPPORT para las aplicaciones Win32. El resto de las secuencias de escape de la impresora están obsoletas y solo se admiten para la compatibilidad con las aplicaciones de 16 bits.

En la programación de Win32, `CDC` ahora proporciona seis funciones miembro que sustituyen a sus secuencias de escape de impresora correspondientes:

- [CDC:: AbortDoc](#abortdoc)

- [CDC:: EndDoc](#enddoc)

- [CDC:: EndPage](#endpage)

- [CDC:: SetAbortProc](#setabortproc)

- [CDC:: StartDoc](#startdoc)

- [CDC:: StartPage](#startpage)

Además, [CDC:: GetDeviceCaps](#getdevicecaps) admite índices de Win32 que sustituyen a otros escapes de impresora. Vea [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) en el Windows SDK para obtener más información.

Esta función miembro permite a las aplicaciones tener acceso a los recursos de un dispositivo determinado que no están directamente disponibles a través de GDI.

Use la primera versión si la aplicación usa valores de escape predefinidos. Use la segunda versión si la aplicación define valores de escape privados. Vea [ExtEscape](/windows/win32/api/wingdi/nf-wingdi-extescape) en el Windows SDK para obtener más información sobre la segunda versión.

##  <a name="excludecliprect"></a>CDC:: ExcludeClipRect

Crea una nueva región de recorte que consta de la región de recorte existente menos el rectángulo especificado.

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parámetros

*1*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo.

*y1*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo.

*RCA*<br/>
Especifica la coordenada x lógica de la esquina inferior derecha del rectángulo.

*a2*<br/>
Especifica la coordenada y lógica de la esquina inferior derecha del rectángulo.

*lpRect*<br/>
Especifica el rectángulo. También puede ser un objeto `CRect`.

### <a name="return-value"></a>Valor devuelto

Especifica el tipo de la nueva región de recorte. Puede ser cualquiera de los siguientes valores:

- COMPLEXREGION la región tiene bordes superpuestos.

- ERROR: no se ha creado ninguna región.

- NULLREGION la región está vacía.

- SIMPLEREGION la región no tiene bordes superpuestos.

### <a name="remarks"></a>Observaciones

El ancho del rectángulo, especificado por el valor absoluto de *x2* - *x1*, no debe superar las 32.767 unidades. Este límite se aplica también al alto del rectángulo.

##  <a name="excludeupdatergn"></a>CDC:: ExcludeUpdateRgn

Impide que se dibuje en áreas no válidas de una ventana excluyendo una región actualizada en la ventana de la región de recorte asociada al objeto de `CDC`.

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>Parámetros

*pWnd*<br/>
Apunta al objeto de ventana cuya ventana se está actualizando.

### <a name="return-value"></a>Valor devuelto

El tipo de región excluida. Puede ser cualquiera de los siguientes valores:

- COMPLEXREGION la región tiene bordes superpuestos.

- ERROR: no se ha creado ninguna región.

- NULLREGION la región está vacía.

- SIMPLEREGION la región no tiene bordes superpuestos.

##  <a name="extfloodfill"></a>CDC:: ExtFloodFill

Rellena un área de la superficie de presentación con el pincel actual.

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x lógica del punto en el que comienza el relleno.

*y*<br/>
Especifica la coordenada y lógica del punto en el que comienza el relleno.

*crColor*<br/>
Especifica el color del límite o del área que se va a rellenar. La interpretación de *crColor* depende del valor de *nFillType*.

*nFillType*<br/>
Especifica el tipo de relleno de inundaciones que se va a realizar. Debe ser uno de los siguientes valores:

- FLOODFILLBORDER el área de relleno está limitada por el color especificado por *crColor*. Este estilo es idéntico al llenado realizado por `FloodFill`.

- FLOODFILLSURFACE el área de relleno se define con el color especificado por *crColor*. El relleno continúa hacia afuera en todas las direcciones siempre que se encuentre el color. Este estilo es útil para rellenar áreas con límites multicolor.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si la función se realiza correctamente; de lo contrario, es 0 si no se pudo completar el rellenado, si el punto especificado tiene el color de límite especificado por *crColor* (si se solicitó FLOODFILLBORDER), si el punto especificado no tiene el color especificado por *crColor* (si se solicitó FLOODFILLSURFACE) o si el punto está fuera de la región de recorte.

### <a name="remarks"></a>Observaciones

Esta función miembro ofrece más flexibilidad que `FloodFill` porque puede especificar un tipo de relleno en *nFillType*.

Si *nFillType* se establece en FLOODFILLBORDER, se supone que el área está completamente enlazada por el color especificado por *crColor*. La función comienza en el punto especificado por *x* e *y y rellena* todas las direcciones hasta el límite de color.

Si *nFillType* se establece en FLOODFILLSURFACE, la función comienza en el punto especificado por *x* e *y y continúa* en todas las direcciones, rellenando todas las áreas adyacentes que contengan el color especificado por *crColor*.

Solo los contextos de dispositivo de memoria y los dispositivos que admiten la tecnología de visualización de tramas `ExtFloodFill`. Para obtener más información, vea la función miembro [GetDeviceCaps](#getdevicecaps) .

##  <a name="exttextout"></a>CDC:: ExtTextOut

Llame a esta función miembro para escribir una cadena de caracteres dentro de una región rectangular usando la fuente seleccionada actualmente.

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x lógica de la celda de carácter para el primer carácter de la cadena especificada.

*y*<br/>
Especifica la coordenada y lógica de la parte superior de la celda de carácter para el primer carácter de la cadena especificada.

*nOptions*<br/>
Especifica el tipo de rectángulo. Este parámetro puede ser uno, ambos o ninguno de los siguientes valores:

- ETO_CLIPPED especifica que el texto se recorta en el rectángulo.

- ETO_OPAQUE especifica que el color de fondo actual rellena el rectángulo. (Puede establecer y consultar el color de fondo actual con las funciones miembro [SetBkColor](#setbkcolor) y [GetBkColor](#getbkcolor) ).

*lpRect*<br/>
Apunta a una estructura [Rect](/windows/win32/api/windef/ns-windef-rect) que determina las dimensiones del rectángulo. Este parámetro puede ser NULL. También puede pasar un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parámetro.

*lpszString*<br/>
Apunta a la cadena de caracteres especificada que se va a dibujar. También puede pasar un objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para este parámetro.

*nCount*<br/>
Especifica el número de caracteres de la cadena.

*lpDxWidths*<br/>
Apunta a una matriz de valores que indican la distancia entre los orígenes de las celdas de caracteres adyacentes. Por ejemplo, las unidades lógicas *lpDxWidths*[ *i*] separan los orígenes de la celda de carácter *i* y la celda de carácter *i* + 1. Si *lpDxWidths* es NULL, `ExtTextOut` utiliza el espaciado predeterminado entre los caracteres.

*str*<br/>
`CString` objeto que contiene los caracteres especificados que se van a dibujar.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La región rectangular puede ser opaca (rellena con el color de fondo actual) y puede ser una región de recorte.

Si *nOptions* es 0 y *lpRect* es null, la función escribe texto en el contexto del dispositivo sin usar una región rectangular. De forma predeterminada, la función no usa ni actualiza la posición actual. Si una aplicación necesita actualizar la posición actual cuando llama a `ExtTextOut`, la aplicación puede llamar a la función miembro `CDC` [SetTextAlign](#settextalign) con *nFlags* establecida en TA_UPDATECP. Cuando se establece esta marca, Windows omite *x* e y en las llamadas subsiguientes a `ExtTextOut` y usa la posición *actual en su* lugar. Cuando una aplicación usa TA_UPDATECP para actualizar la posición actual, `ExtTextOut` establece la posición actual al final de la línea anterior de texto o a la posición especificada por el último elemento de la matriz a la que apunta *lpDxWidths*, lo que sea mayor.

##  <a name="fillpath"></a>CDC:: FillPath

Cierra las figuras abiertas en la ruta de acceso actual y rellena el interior del trazado mediante el pincel actual y el modo de relleno de polígonos.

```
BOOL FillPath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Una vez rellenado el interior, la ruta de acceso se descarta del contexto del dispositivo.

##  <a name="fillrect"></a>CDC:: FillRect

Llame a esta función miembro para rellenar un rectángulo determinado mediante el pincel especificado.

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Apunta a una estructura [Rect](/windows/win32/api/windef/ns-windef-rect) que contiene las coordenadas lógicas del rectángulo que se va a rellenar. También puede pasar un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) para este parámetro.

*pBrush*<br/>
Identifica el pincel utilizado para rellenar el rectángulo.

### <a name="remarks"></a>Observaciones

La función rellena el rectángulo completo, incluidos los bordes izquierdo y superior, pero no rellena los bordes derecho e inferior.

El pincel debe crearse con las funciones miembro [CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)y [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush)de [CBrush (](../../mfc/reference/cbrush-class.md) , o bien se puede recuperar mediante la función de Windows `GetStockObject`.

Al rellenar el rectángulo especificado, `FillRect` no incluye los lados derecho e inferior del rectángulo. GDI rellena un rectángulo hasta, pero no incluye, la columna derecha y la fila inferior, independientemente del modo de asignación actual. `FillRect` compara los valores de los miembros `top`, `bottom`, `left`y `right` del rectángulo especificado. Si `bottom` es menor o igual que `top`, o si `right` es menor o igual que `left`, no se dibuja el rectángulo.

`FillRect` es similar a [CDC:: FillSolidRect](#fillsolidrect); sin embargo, `FillRect` toma un pincel y, por tanto, se puede usar para rellenar un rectángulo con un color sólido, un color de trama, pinceles tramados o un patrón. `FillSolidRect` solo usa colores sólidos (indicados por un parámetro COLORREF). normalmente `FillRect` es más lento que `FillSolidRect`.

##  <a name="fillrgn"></a>CDC:: FillRgn

Rellena la región especificada por *pRgn* con el pincel especificado por *pBrush*.

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parámetros

*pRgn*<br/>
Puntero a la región que se va a rellenar. Las coordenadas de la región determinada se especifican en unidades lógicas.

*pBrush*<br/>
Identifica el pincel que se va a usar para rellenar la región.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El pincel se debe crear mediante las funciones miembro de `CBrush` `CreateHatchBrush`, `CreatePatternBrush`, `CreateSolidBrush`o recuperar `GetStockObject`.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [crgn (:: CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).

##  <a name="fillsolidrect"></a>CDC:: FillSolidRect

Llame a esta función miembro para rellenar el rectángulo dado con el color sólido especificado.

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Especifica el rectángulo delimitador (en unidades lógicas). Puede pasar un puntero a una estructura de datos [Rect](/windows/win32/api/windef/ns-windef-rect) o un objeto `CRect` para este parámetro.

*CLR* Especifica el color que se va a usar para rellenar el rectángulo.

*x*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo.

*y*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo de destino.

*serie*<br/>
Especifica el ancho del rectángulo.

*CY*<br/>
Especifica el alto del rectángulo.

### <a name="remarks"></a>Observaciones

`FillSolidRect` es muy similar a [CDC:: FillRect](#fillrect); sin embargo, `FillSolidRect` solo usa colores sólidos (indicados por el parámetro COLORREF), mientras que `FillRect` toma un pincel y, por lo tanto, se puede usar para rellenar un rectángulo con un color sólido, un color dimated, pinceles tramados o un patrón. normalmente `FillSolidRect` es más rápido que `FillRect`.

> [!NOTE]
>  Cuando se llama a `FillSolidRect`, el color de fondo, que se estableció previamente mediante [SetBkColor](#setbkcolor), se establece en el color indicado por *CLR*.

##  <a name="flattenpath"></a>CDC:: FlattenPath

Transforma las curvas del trazado seleccionado en el contexto del dispositivo actual y convierte cada curva en una secuencia de líneas.

```
BOOL FlattenPath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

##  <a name="floodfill"></a>CDC:: FloodFill

Rellena un área de la superficie de presentación con el pincel actual.

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x lógica del punto en el que comienza el relleno.

*y*<br/>
Especifica la coordenada y lógica del punto en el que comienza el relleno.

*crColor*<br/>
Especifica el color del límite.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si la función se realiza correctamente; de lo contrario, se devuelve 0 si no se pudo completar el rellenado, si el punto especificado tiene el color de límite especificado por *crColor*, o si el punto está fuera de la región de recorte.

### <a name="remarks"></a>Observaciones

Se supone que el área está limitada según lo especificado por *crColor*. La función `FloodFill` comienza en el punto especificado por *x* e *y y continúa* en todas las direcciones hasta el límite de color.

Solo los contextos de dispositivo de memoria y los dispositivos que admiten la tecnología de presentación de tramas admiten la función miembro `FloodFill`. Para obtener información sobre RC_BITBLT capacidad, vea la función miembro `GetDeviceCaps`.

La función `ExtFloodFill` proporciona una funcionalidad similar, pero una mayor flexibilidad.

##  <a name="framerect"></a>CDC:: FrameRect

Dibuja un borde alrededor del rectángulo especificado por *lpRect*.

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Apunta a una estructura [Rect](/windows/win32/api/windef/ns-windef-rect) o a un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que contiene las coordenadas lógicas de las esquinas superior izquierda e inferior derecha del rectángulo. También puede pasar un objeto `CRect` para este parámetro.

*pBrush*<br/>
Identifica el pincel que se va a utilizar para enmarcar el rectángulo.

### <a name="remarks"></a>Observaciones

La función usa el pincel especificado para dibujar el borde. El ancho y el alto del borde siempre es 1 unidad lógica.

Si la coordenada `bottom` del rectángulo es menor o igual que `top`, o si `right` es menor o igual que `left`, no se dibuja el rectángulo.

El borde dibujado por `FrameRect` está en la misma posición que un borde dibujado por la función miembro `Rectangle` con las mismas coordenadas (si `Rectangle` usa un lápiz que es 1 unidad lógica ancha). `FrameRect`no rellena el interior del rectángulo.

##  <a name="framergn"></a>CDC:: FrameRgn

Dibuja un borde alrededor de la región especificada por *pRgn* usando el pincel especificado por *pBrush*.

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parámetros

*pRgn*<br/>
Apunta al objeto `CRgn` que identifica la región que se va a incluir en un borde. Las coordenadas de la región determinada se especifican en unidades lógicas.

*pBrush*<br/>
Apunta al objeto `CBrush` que identifica el pincel que se va a utilizar para dibujar el borde.

*nWidth*<br/>
Especifica el ancho del borde en los trazos de pincel verticales en unidades de dispositivo.

*nHeight*<br/>
Especifica el alto del borde en los trazos de pincel horizontal en unidades de dispositivo.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [crgn (:: CombineRgn](../../mfc/reference/crgn-class.md#combinergn).

##  <a name="fromhandle"></a>CDC:: FromHandle

Devuelve un puntero a un objeto `CDC` cuando se proporciona un identificador a un contexto de dispositivo.

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>Parámetros

*Cámaras*<br/>
Contiene un identificador para un contexto de dispositivo de Windows.

### <a name="return-value"></a>Valor devuelto

El puntero puede ser temporal y no debe almacenarse más allá del uso inmediato.

### <a name="remarks"></a>Observaciones

Si no hay un objeto `CDC` asociado al identificador, se crea y asocia un objeto `CDC` temporal.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CPrintDialog:: GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

##  <a name="getarcdirection"></a>CDC:: GetArcDirection

Devuelve la dirección de arco actual del contexto del dispositivo.

```
int GetArcDirection() const;
```

### <a name="return-value"></a>Valor devuelto

Especifica la dirección del arco actual, si se realiza correctamente. A continuación se muestran los valores devueltos válidos:

- AD_COUNTERCLOCKWISE arcos y rectángulos dibujados en sentido contrario a las agujas del reloj.

- AD_CLOCKWISE arcos y rectángulos dibujados a la derecha.

Si se produce un error, el valor devuelto es cero.

### <a name="remarks"></a>Observaciones

Las funciones de arco y rectángulo usan la dirección del arco.

##  <a name="getaspectratiofilter"></a>CDC:: GetAspectRatioFilter

Recupera el valor para el filtro de la relación de aspecto actual.

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>Valor devuelto

Objeto `CSize` que representa la relación de aspecto utilizada por el filtro de relación de aspecto actual.

### <a name="remarks"></a>Observaciones

La relación de aspecto es la proporción formada por el ancho y el alto de píxel de un dispositivo. La información sobre la relación de aspecto de un dispositivo se usa en la creación, selección y visualización de las fuentes. Windows proporciona un filtro especial, el filtro de relación de aspecto, para seleccionar las fuentes diseñadas para una relación de aspecto determinada de todas las fuentes disponibles. El filtro usa la relación de aspecto especificada por la función miembro `SetMapperFlags`.

##  <a name="getbkcolor"></a>CDC:: GetBkColor

Devuelve el color de fondo actual.

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>Valor devuelto

Valor de color RGB.

### <a name="remarks"></a>Observaciones

Si el modo de fondo es opaco, el sistema utiliza el color de fondo para rellenar los huecos de las líneas con estilo, los espacios entre las líneas sombreadas de los pinceles y el fondo de las celdas de caracteres. El sistema también usa el color de fondo al convertir los mapas de bits entre los contextos de dispositivo de color y monocromo.

##  <a name="getbkmode"></a>CDC:: GetBkMode

Devuelve el modo en segundo plano.

```
int GetBkMode() const;
```

### <a name="return-value"></a>Valor devuelto

El modo en segundo plano actual, que puede ser opaco o transparente.

### <a name="remarks"></a>Observaciones

El modo en segundo plano define si el sistema quita los colores de fondo existentes en la superficie de dibujo antes de dibujar el texto, los pinceles sombreados o cualquier estilo de pluma que no sea una línea sólida.

##  <a name="getboundsrect"></a>CDC:: GetBoundsRect

Devuelve el rectángulo delimitador acumulado actual para el contexto de dispositivo especificado.

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parámetros

*lpRectBounds*<br/>
Señala a un búfer que recibirá el rectángulo delimitador actual. El rectángulo se devuelve en coordenadas lógicas.

*flags*<br/>
Especifica si el rectángulo delimitador debe borrarse después de devolverse. Este parámetro debe ser cero o establecerse en el valor siguiente:

- DCB_RESET fuerza el borrado del rectángulo delimitador después de que se devuelva.

### <a name="return-value"></a>Valor devuelto

Especifica el estado actual del rectángulo delimitador si la función se realiza correctamente. Puede ser una combinación de los siguientes valores:

- DCB_ACCUMULATE se está produciendo la acumulación del rectángulo delimitador.

- DCB_RESET rectángulo delimitador está vacío.

- DCB_SET rectángulo delimitador no está vacío.

- DCB_ENABLE acumulación de límite está activada.

- DCB_DISABLE acumulación de límite está desactivada.

##  <a name="getbrushorg"></a>CDC:: GetBrushOrg

Recupera el origen (en unidades de dispositivo) del pincel seleccionado actualmente para el contexto del dispositivo.

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>Valor devuelto

El origen actual del pincel (en unidades de dispositivo) como un objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

### <a name="remarks"></a>Observaciones

El origen del pincel inicial está en (0,0) del área cliente. El valor devuelto especifica este punto en unidades de dispositivo en relación con el origen de la ventana del escritorio.

##  <a name="getcharacterplacement"></a>CDC:: GetCharacterPlacement

Recupera varios tipos de información sobre una cadena de caracteres.

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>Parámetros

*lpString*<br/>
Puntero a la cadena de caracteres que se va a procesar.

*nCount*<br/>
Especifica la longitud de la cadena. En el caso de la versión ANSI, es un recuento de BYTEs y, para la función Unicode, es un recuento de palabras. Para obtener más información, vea [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw).

*nMaxExtent*<br/>
Especifica la extensión máxima (en unidades lógicas) en la que se procesa la cadena. Se omiten los caracteres que, si se procesan, superarían esta extensión. Los cálculos de cualquier matriz de glifo o ordenación necesaria solo se aplican a los caracteres incluidos. Este parámetro solo se usa si el valor GCP_MAXEXTENT se especifica en el parámetro *dwFlags* . A medida que la función procesa la cadena de entrada, cada carácter y su extensión se agregan a la salida, la extensión y otras matrices solo si la extensión total aún no ha superado el máximo. Una vez alcanzado el límite, se detendrá el procesamiento.

*lpResults*<br/>
Puntero a una estructura de [GCP_Results](/windows/win32/api/wingdi/ns-wingdi-gcp_resultsw) que recibe los resultados de la función.

*dwFlags*<br/>
Especifica cómo procesar la cadena en las matrices necesarias. Este parámetro puede ser uno o varios de los valores enumerados en la sección *dwFlags* del tema [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw) .

*str*<br/>
Puntero a un objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) que se va a procesar.

### <a name="return-value"></a>Valor devuelto

Si la función se ejecuta correctamente, el valor devuelto es el ancho y el alto de la cadena en unidades lógicas.

Si la función no se realiza correctamente, el valor devuelto es cero.

### <a name="remarks"></a>Observaciones

Esta función miembro emula la funcionalidad de la función [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw), tal y como se describe en el Windows SDK.

##  <a name="getcharabcwidths"></a>CDC:: GetCharABCWidths

Recupera el ancho de caracteres consecutivos de un intervalo especificado a partir de la fuente TrueType actual.

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>Parámetros

*nFirstChar*<br/>
Especifica el primer carácter del intervalo de caracteres de la fuente actual para la que se devuelven los anchos de caracteres.

*nLastChar*<br/>
Especifica el último carácter del intervalo de caracteres de la fuente actual para la que se devuelven los anchos de caracteres.

*lpabc*<br/>
Apunta a una matriz de estructuras [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) que reciben el ancho de caracteres cuando se devuelve la función. Esta matriz debe contener al menos tantas estructuras `ABC`, ya que hay caracteres en el intervalo especificado por los parámetros *nFirstChar* y *nLastChar* .

*lpABCF*<br/>
Apunta a un búfer proporcionado por la aplicación con una matriz de estructuras [abcfloat (](/windows/win32/api/wingdi/ns-wingdi-abcfloat) para recibir el ancho de caracteres cuando se devuelve la función. Los anchos devueltos por esta función se encuentran en el formato de punto flotante de IEEE.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Los anchos se devuelven en unidades lógicas. Esta función solo se realiza correctamente con fuentes TrueType.

El rasterizador de TrueType proporciona el espaciado de caracteres "ABC" después de que se haya seleccionado un tamaño de punto específico. El espaciado "A" es la distancia que se agrega a la posición actual antes de colocar el glifo. El espaciado "B" es el ancho de la parte negra del glifo. El espaciado "C" se agrega a la posición actual para tener en cuenta el espacio en blanco a la derecha del glifo. El ancho avanzado total viene determinado por A + B + C.

Cuando la función miembro `GetCharABCWidths` recupera anchos "A" o "C" negativos para un carácter, ese carácter incluye subbloqueos o sobrebloqueos.

Para convertir los anchos ABC en unidades de diseño de fuente, una aplicación debe crear una fuente cuyo alto (tal y como se especifica en el miembro `lfHeight` de la estructura [LOGFONT](/windows/win32/api/wingdi/ns-wingdi-logfontw) ) sea igual al valor almacenado en el miembro `ntmSizeEM` de la estructura [NEWTEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-newtextmetricw) . (El valor del miembro de `ntmSizeEM` se puede recuperar llamando a la función de Windows [EnumFontFamilies](/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw) ).

Los anchos ABC del carácter predeterminado se utilizan para los caracteres que están fuera del intervalo de la fuente seleccionada actualmente.

Para recuperar el ancho de caracteres de fuentes no TrueType, las aplicaciones deben usar la función de Windows [GetCharWidth](/windows/win32/api/wingdi/nf-wingdi-getcharwidthw) .

##  <a name="getcharabcwidthsi"></a>CDC:: GetCharABCWidthsI

Recupera los anchos, en unidades lógicas, de los índices de glifos consecutivos en un intervalo especificado de la fuente TrueType actual.

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>Parámetros

*giFirst*<br/>
Especifica el primer índice del glifo en el grupo de índices de glifo consecutivos de la fuente actual. Este parámetro solo se usa si el parámetro *PGI* es NULL.

*cgi*<br/>
Especifica el número de índices de glifo.

*IGP*<br/>
Puntero a una matriz que contiene los índices de glifo. Si el valor es NULL, se usa el parámetro *giFirst* en su lugar. El parámetro *cgi* especifica el número de índices de glifo de esta matriz.

*lpabc*<br/>
Puntero a una matriz de estructuras [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) que reciben el ancho de caracteres. Esta matriz debe contener al menos tantas estructuras `ABC`, ya que hay índices de glifo especificados por el parámetro *cgi* .

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función miembro emula la funcionalidad de la función [GetCharABCWidthsI](/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsi), tal y como se describe en el Windows SDK.

##  <a name="getcharwidth"></a>CDC:: GetCharWidth

Recupera el ancho de caracteres individuales de un grupo de caracteres consecutivos de la fuente actual, utilizando `m_hAttribDC`, el contexto del dispositivo de entrada.

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>Parámetros

*nFirstChar*<br/>
Especifica el primer carácter de un grupo de caracteres consecutivos en la fuente actual.

*nLastChar*<br/>
Especifica el último carácter de un grupo de caracteres consecutivos en la fuente actual.

*lpBuffer*<br/>
Señala a un búfer que recibirá los valores de ancho de un grupo de caracteres consecutivos en la fuente actual.

*lpFloatBuffer*<br/>
Apunta a un búfer para recibir el ancho de caracteres. Los anchos devueltos se encuentran en el formato de punto flotante IEEE de 32 bits. (Los anchos se miden a lo largo de la línea base de los caracteres).

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Por ejemplo, si *nFirstChar* identifica la letra ' a ' y *nLastChar* identifica la letra ' z ', la función recupera los anchos de todos los caracteres en minúsculas.

La función almacena los valores en el búfer al que apunta *lpBuffer*. Este búfer debe ser lo suficientemente grande como para contener todos los anchos. Es decir, debe haber al menos 26 entradas en el ejemplo dado.

Si no existe un carácter en el grupo de caracteres consecutivos en una fuente determinada, se le asignará el valor de ancho del carácter predeterminado.

##  <a name="getcharwidthi"></a>CDC:: GetCharWidthI

Recupera los anchos, en coordenadas lógicas, de los índices de glifos consecutivos en un intervalo especificado de la fuente actual.

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parámetros

*giFirst*<br/>
Especifica el primer índice del glifo en el grupo de índices de glifo consecutivos de la fuente actual. Este parámetro solo se usa si el parámetro *PGI* es NULL.

*cgi*<br/>
Especifica el número de índices de glifo.

*IGP*<br/>
Puntero a una matriz que contiene los índices de glifo. Si el valor es NULL, se usa el parámetro *giFirst* en su lugar. El parámetro *cgi* especifica el número de índices de glifo de esta matriz.

*lpBuffer*<br/>
Un puntero a un búfer que recibe el ancho.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función miembro emula la funcionalidad de la función [GetCharWidthI](/windows/win32/api/wingdi/nf-wingdi-getcharwidthi), tal y como se describe en el Windows SDK.

##  <a name="getclipbox"></a>CDC:: GetClipBox

Recupera las dimensiones del rectángulo delimitador más estrecho alrededor del límite de recorte actual.

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Apunta a la estructura [Rect](/windows/win32/api/windef/ns-windef-rect) o al objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) que va a recibir las dimensiones del rectángulo.

### <a name="return-value"></a>Valor devuelto

Tipo de la región de recorte. Puede ser cualquiera de los siguientes valores:

- La región de recorte de COMPLEXREGION tiene bordes superpuestos.

- El contexto de dispositivo de ERROR no es válido.

- La región de recorte de NULLREGION está vacía.

- La región de recorte SIMPLEREGION no tiene bordes superpuestos.

### <a name="remarks"></a>Observaciones

Las dimensiones se copian en el búfer al que apunta *lpRect*.

##  <a name="getcoloradjustment"></a>CDC:: GetColorAdjustment

Recupera los valores de ajuste de color para el contexto del dispositivo.

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>Parámetros

*lpColorAdjust*<br/>
Apunta a una estructura de datos [coloradjustment (](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) para recibir los valores de ajuste de color.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

##  <a name="getcurrentbitmap"></a>CDC:: GetCurrentBitmap

Devuelve un puntero al objeto `CBitmap` actualmente seleccionado.

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>Valor devuelto

Puntero a un objeto `CBitmap`, si es correcto; de lo contrario, NULL.

### <a name="remarks"></a>Observaciones

Esta función miembro puede devolver objetos temporales.

##  <a name="getcurrentbrush"></a>CDC:: GetCurrentBrush

Devuelve un puntero al objeto `CBrush` actualmente seleccionado.

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>Valor devuelto

Puntero a un objeto `CBrush`, si es correcto; de lo contrario, NULL.

### <a name="remarks"></a>Observaciones

Esta función miembro puede devolver objetos temporales.

##  <a name="getcurrentfont"></a>CDC:: GetCurrentFont

Devuelve un puntero al objeto `CFont` actualmente seleccionado.

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>Valor devuelto

Puntero a un objeto `CFont`, si es correcto; de lo contrario, NULL.

### <a name="remarks"></a>Observaciones

Esta función miembro puede devolver objetos temporales.

##  <a name="getcurrentpalette"></a>CDC:: GetCurrentPalette

Devuelve un puntero al objeto `CPalette` actualmente seleccionado.

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>Valor devuelto

Puntero a un objeto `CPalette`, si es correcto; de lo contrario, NULL.

### <a name="remarks"></a>Observaciones

Esta función miembro puede devolver objetos temporales.

##  <a name="getcurrentpen"></a>CDC:: GetCurrentPen

Devuelve un puntero al objeto `CPen` actualmente seleccionado.

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>Valor devuelto

Puntero a un objeto `CPen`, si es correcto; de lo contrario, NULL.

### <a name="remarks"></a>Observaciones

Esta función miembro puede devolver objetos temporales.

##  <a name="getcurrentposition"></a>CDC:: GetCurrentPosition

Recupera la posición actual (en coordenadas lógicas).

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>Valor devuelto

La posición actual como un objeto de `CPoint`.

### <a name="remarks"></a>Observaciones

La posición actual se puede establecer con la función miembro `MoveTo`.

##  <a name="getdcbrushcolor"></a>CDC:: GetDCBrushColor

Recupera el color de pincel actual.

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>Valor devuelto

Si la función se ejecuta correctamente, el valor devuelto es el valor de [COLORREF](/windows/win32/gdi/colorref) para el color del pincel actual.

Si la función no se realiza correctamente, el valor devuelto es CLR_INVALID.

### <a name="remarks"></a>Observaciones

Esta función miembro emula la funcionalidad de la función [GetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-getdcbrushcolor), tal y como se describe en el Windows SDK.

##  <a name="getdcpencolor"></a>CDC:: GetDCPenColor

Recupera el color del lápiz actual.

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>Valor devuelto

Si la función se ejecuta correctamente, el valor devuelto es el valor de [COLORREF](/windows/win32/gdi/colorref) para el color del lápiz actual.

Si la función no se realiza correctamente, el valor devuelto es CLR_INVALID.

### <a name="remarks"></a>Observaciones

Esta función miembro emplea la función [GetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-getdcpencolor)de Win32, tal como se describe en el Windows SDK.

##  <a name="getdevicecaps"></a>CDC:: GetDeviceCaps

Recupera una amplia gama de información específica del dispositivo sobre el dispositivo de pantalla.

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>Parámetros

*nIndex*<br/>
Especifica el tipo de información que se va a devolver. Vea [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) en el Windows SDK para obtener una lista de valores.

### <a name="return-value"></a>Valor devuelto

Valor de la funcionalidad solicitada si la función se realiza correctamente.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CPrintDialog:: GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).

##  <a name="getfontdata"></a>CDC:: GetFontData

Recupera información de la métrica de fuente de un archivo de fuente escalable.

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>Parámetros

*dwTable*<br/>
Especifica el nombre de la tabla de métricas que se va a devolver. Este parámetro puede ser una de las tablas de métricas documentadas en la especificación de archivos de fuente TrueType publicada por Microsoft Corporation. Si este parámetro es 0, la información se recupera a partir del principio del archivo de fuente.

*dwOffset*<br/>
Especifica el desplazamiento desde el principio de la tabla en el que se va a empezar a recuperar información. Si este parámetro es 0, la información se recupera empezando al principio de la tabla especificada por el parámetro *dwTable* . Si este valor es mayor o igual que el tamaño de la tabla, `GetFontData` devuelve 0.

*lpData*<br/>
Señala a un búfer que recibirá la información de la fuente. Si este valor es NULL, la función devuelve el tamaño del búfer necesario para los datos de fuente especificados en el parámetro *dwTable* .

*cbData*<br/>
Especifica la longitud, en bytes, de la información que se va a recuperar. Si este parámetro es 0, `GetFontData` devuelve el tamaño de los datos especificados en el parámetro *dwTable* .

### <a name="return-value"></a>Valor devuelto

Especifica el número de bytes devueltos en el búfer al que apunta *lpData* si la función se realiza correctamente; de lo contrario,-1.

### <a name="remarks"></a>Observaciones

La información que se va a recuperar se identifica especificando un desplazamiento en el archivo de fuente y la longitud de la información que se va a devolver.

A veces, una aplicación puede usar la función miembro `GetFontData` para guardar una fuente TrueType con un documento. Para ello, la aplicación determina si la fuente se puede incrustar y, a continuación, recupera el archivo de fuente completo, especificando 0 para los parámetros *dwTable*, *dwOffset*y *cbData* .

Las aplicaciones pueden determinar si se puede insertar una fuente comprobando el miembro de `otmfsType` de la estructura [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) . Si se establece el bit 1 de `otmfsType`, no se permite la incrustación para la fuente. Si el bit 1 está claro, la fuente se puede incrustar. Si se establece el bit 2, la incrustación es de solo lectura.

Si una aplicación intenta usar esta función para recuperar información de una fuente que no sea TrueType, la función miembro `GetFontData` devuelve-1.

##  <a name="getfontlanguageinfo"></a>CDC:: GetFontLanguageInfo

Devuelve información sobre la fuente seleccionada actualmente para el contexto de presentación especificado.

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>Valor devuelto

El valor devuelto identifica las características de la fuente seleccionada actualmente. Para obtener una lista completa de valores posibles, vea [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo).

### <a name="remarks"></a>Observaciones

Esta función miembro emula la funcionalidad de la función [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo), tal y como se describe en el Windows SDK.

##  <a name="getglyphoutline"></a>CDC:: GetGlyphOutline

Recupera la curva o el mapa de bits del contorno de un carácter de contorno en la fuente actual.

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>Parámetros

*nChar*<br/>
Especifica el carácter para el que se va a devolver información.

*nFormat*<br/>
Especifica el formato en el que la función va a devolver información. Puede ser uno de los valores siguientes o 0:

|Value|Significado|
|-----------|-------------|
|GGO_BITMAP|Devuelve el mapa de bits del glifo. Cuando la función devuelve, el búfer al que apunta *lpBuffer* contiene un mapa de bits de 1 bit por píxel cuyas filas comienzan en los límites de palabra.|
|GGO_NATIVE|Devuelve los puntos de datos de curva en el formato nativo del rasterizador mediante unidades de dispositivo. Cuando se especifica este valor, se omite cualquier transformación especificada en *lpmat2* .|

Cuando el valor de *nFormat* es 0, la función rellena una estructura [GLYPHMETRICS](/windows/win32/api/wingdi/ns-wingdi-glyphmetrics) , pero no devuelve datos del contorno del glifo.

*lpgm*<br/>
Apunta a una estructura GLYPHMETRICS que describe la posición del glifo en la celda de carácter.

*cbBuffer*<br/>
Especifica el tamaño del búfer en el que la función copia información sobre el carácter de contorno. Si este valor es 0 y el parámetro *nFormat* es el GGO_BITMAP o GGO_NATIVE valores, la función devuelve el tamaño necesario del búfer.

*lpBuffer*<br/>
Apunta a un búfer en el que la función copia información sobre el carácter de contorno. Si *nFormat* especifica el valor de GGO_NATIVE, la información se copia en forma de estructuras TTPOLYGONHEADER y TTPOLYCURVE. Si este valor es NULL y *nFormat* es el valor GGO_BITMAP o GGO_NATIVE, la función devuelve el tamaño necesario del búfer.

*lpmat2*<br/>
Apunta a una estructura [MAT2](/windows/win32/api/wingdi/ns-wingdi-mat2) que contiene una matriz de transformación para el carácter. Este parámetro no puede ser NULL, ni siquiera cuando se especifica el valor de GGO_NATIVE para *nFormat*.

### <a name="return-value"></a>Valor devuelto

Tamaño, en bytes, del búfer necesario para la información recuperada si *cbBuffer* es 0 o *lpBuffer* es NULL. De lo contrario, es un valor positivo si la función se realiza correctamente o-1 si se produce un error.

### <a name="remarks"></a>Observaciones

Una aplicación puede girar caracteres recuperados en formato de mapa de bits especificando una matriz de transformación de 2 por 2 en la estructura a la que apunta *lpmat2*.

Un contorno de glifo se devuelve como una serie de contornos. Cada contorno se define mediante una estructura [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) , seguida de tantas estructuras `TTPOLYCURVE` como se requieran para describirlo. Todos los puntos se devuelven como estructuras [POINTFX](/windows/win32/api/wingdi/ns-wingdi-pointfx) y representan posiciones absolutas, no movimientos relativos. El punto inicial proporcionado por el miembro `pfxStart` de la estructura [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) es el punto en el que comienza el contorno de un contorno. Las estructuras [TTPOLYCURVE](/windows/win32/api/wingdi/ns-wingdi-ttpolycurve) siguientes pueden ser registros Polyline o registros spline. Los registros de polilínea son una serie de puntos; las líneas dibujadas entre los puntos describen el contorno del carácter. Los registros de spline representan las curvas cuadráticas utilizadas por TrueType (es decir, las splines de b cuadrática).

##  <a name="getgraphicsmode"></a>CDC:: GetGraphicsMode

Recupera el modo de gráficos actual para el contexto de dispositivo especificado.

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>Valor devuelto

Devuelve el modo de gráficos actual en caso de éxito. Para obtener una lista de los valores que este método puede devolver, vea [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

Devuelve 0 en caso de error.

Para obtener información de error extendida, llame a [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Observaciones

Este método ajusta la función GDI de Windows [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

##  <a name="gethalftonebrush"></a>CDC:: GetHalftoneBrush

Llame a esta función miembro para recuperar un pincel de semitonos.

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>Valor devuelto

Un puntero a un objeto de `CBrush` si se realiza correctamente; de lo contrario, NULL.

### <a name="remarks"></a>Observaciones

Un pincel de semitono muestra píxeles que son los colores de primer plano y de fondo para crear un patrón de trama. A continuación se incluye un ejemplo de un patrón de trama creado por un pincel de semitonos.

![Detalle de un trazo de lápiz proexistente](../../mfc/reference/media/vc318s1.gif "Detalle de un trazo del lápiz interpolado")

##  <a name="getkerningpairs"></a>CDC:: GetKerningPairs

Recupera los pares de interletraje de caracteres de la fuente seleccionada actualmente en el contexto de dispositivo especificado.

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>Parámetros

*nPairs*<br/>
Especifica el número de estructuras [KERNINGPAIR](/windows/win32/api/wingdi/ns-wingdi-kerningpair) apuntadas por *lpkrnpair*. La función no copiará más pares de kerning que los especificados por *nPairs*.

*lpkrnpair*<br/>
Apunta a una matriz de estructuras `KERNINGPAIR` que reciben los pares de interletraje cuando la función devuelve. Esta matriz debe contener al menos tantas estructuras como especifique el *nPairs*. Si este parámetro es NULL, la función devuelve el número total de pares de interletraje para la fuente.

### <a name="return-value"></a>Valor devuelto

Especifica el número de pares de kerning recuperados o el número total de pares de interletraje de la fuente, si la función se realiza correctamente. Se devuelve cero si se produce un error en la función o no hay ningún par de interletraje para la fuente.

##  <a name="getlayout"></a>CDC:: GetLayout

Llame a esta función miembro para determinar el diseño del texto y los gráficos para un contexto de dispositivo, como una impresora o un metarchivo.

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>Valor devuelto

Si es correcto, las marcas de diseño para el contexto de dispositivo actual. De lo contrario, GDI_ERROR. Para obtener información de error extendida, llame a [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror). Para obtener una lista de las marcas de diseño, vea [CDC:: SetLayout](#setlayout).

### <a name="remarks"></a>Observaciones

El diseño predeterminado es de izquierda a derecha.

##  <a name="getmapmode"></a>CDC:: GetMapMode

Recupera el modo de asignación actual.

```
int GetMapMode() const;
```

### <a name="return-value"></a>Valor devuelto

Modo de asignación.

### <a name="remarks"></a>Observaciones

Para obtener una descripción de los modos de asignación, vea la función miembro `SetMapMode`.

> [!NOTE]
>  Si llama a [SetLayout](#setlayout) para cambiar el diseño del controlador de dominio de derecha a izquierda, `SetLayout` cambia automáticamente el modo de asignación a MM_ISOTROPIC. Por lo tanto, cualquier llamada subsiguiente a `GetMapMode` devolverá MM_ISOTROPIC.

##  <a name="getmiterlimit"></a>CDC:: GetMiterLimit

Devuelve el límite angular del contexto del dispositivo.

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El límite angular se usa al dibujar líneas geométricas que tienen combinaciones angulares.

##  <a name="getnearestcolor"></a>CDC:: GetNearestColor

Devuelve el color sólido que mejor coincida con un color lógico especificado.

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>Parámetros

*crColor*<br/>
Especifica el color con el que debe coincidir.

### <a name="return-value"></a>Valor devuelto

Un valor de color RGB (rojo, verde, azul) que define el color sólido más cercano al valor de *crColor* que el dispositivo puede representar.

### <a name="remarks"></a>Observaciones

El dispositivo determinado debe ser capaz de representar este color.

##  <a name="getoutlinetextmetrics"></a>CDC:: GetOutlineTextMetrics

Recupera información de métricas para las fuentes TrueType.

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>Parámetros

*lpotm*<br/>
Apunta a una matriz de estructuras [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) . Si este parámetro es NULL, la función devuelve el tamaño del búfer necesario para los datos de métrica recuperados.

*cbData*<br/>
Especifica el tamaño, en bytes, del búfer en el que se devuelve información.

*lpotm*<br/>
Apunta a una estructura de `OUTLINETEXTMETRIC`. Si este parámetro es NULL, la función devuelve el tamaño del búfer necesario para la información de métrica recuperada.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La estructura [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) contiene la mayoría de la información de métricas de fuente proporcionada con el formato TrueType, incluida una estructura [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) . Los últimos cuatro miembros de la estructura `OUTLINETEXTMETRIC` son punteros a cadenas. Las aplicaciones deben asignar espacio para estas cadenas además del espacio necesario para los demás miembros. Dado que no hay ningún límite impuesto por el sistema al tamaño de las cadenas, el método más sencillo para asignar memoria es recuperar el tamaño necesario especificando NULL para *lpotm* en la primera llamada a la función `GetOutlineTextMetrics`.

##  <a name="getoutputcharwidth"></a>CDC:: GetOutputCharWidth

Utiliza el contexto de dispositivo de salida, `m_hDC`, y recupera el ancho de caracteres individuales de un grupo de caracteres consecutivos de la fuente actual.

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parámetros

*nFirstChar*<br/>
Especifica el primer carácter de un grupo de caracteres consecutivos en la fuente actual.

*nLastChar*<br/>
Especifica el último carácter de un grupo de caracteres consecutivos en la fuente actual.

*lpBuffer*<br/>
Señala a un búfer que recibirá los valores de ancho de un grupo de caracteres consecutivos en la fuente actual.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Por ejemplo, si *nFirstChar* identifica la letra ' a ' y *nLastChar* identifica la letra ' z ', la función recupera los anchos de todos los caracteres en minúsculas.

La función almacena los valores en el búfer al que apunta *lpBuffer*. Este búfer debe ser lo suficientemente grande como para contener todos los anchos; es decir, debe haber al menos 26 entradas en el ejemplo dado.

Si no existe un carácter en el grupo de caracteres consecutivos en una fuente determinada, se le asignará el valor de ancho del carácter predeterminado.

##  <a name="getoutputtabbedtextextent"></a>CDC:: GetOutputTabbedTextExtent

Llame a esta función miembro para calcular el ancho y el alto de una cadena de caracteres mediante [m_hDC](#m_hdc), el contexto del dispositivo de salida.

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parámetros

*lpszString*<br/>
Apunta a una cadena de caracteres que se va a medir. También puede pasar un objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para este parámetro.

*nCount*<br/>
Especifica la [longitud de la cadena a la](/windows/win32/gdi/specifying-length-of-text-output-string) que apunta *lpszString*.

*nTabPositions*<br/>
Especifica el número de posiciones de tabulación en la matriz a la que señala *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Apunta a una matriz de enteros que contiene las posiciones de tabulación en unidades lógicas. Las tabulaciones se deben ordenar en orden ascendente; el valor x más pequeño debe ser el primer elemento de la matriz. No se permiten las pestañas atrás.

*str*<br/>
`CString` objeto que contiene los caracteres especificados que se van a medir.

### <a name="return-value"></a>Valor devuelto

Dimensiones de la cadena (en unidades lógicas) en un objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Observaciones

Si la cadena contiene uno o más caracteres de tabulación, el ancho de la cadena se basa en las paradas de tabulación especificadas por *lpnTabStopPositions*. La función usa la fuente seleccionada actualmente para calcular las dimensiones de la cadena.

La región de recorte actual no desplaza el ancho y el alto devueltos por la función `GetOutputTabbedTextExtent`.

Dado que algunos dispositivos no colocan caracteres en matrices de celdas normales (es decir, intercalan los caracteres), la suma de las extensiones de los caracteres de una cadena puede no ser igual a la extensión de la cadena.

Si *nTabPositions* es 0 y *lpnTabStopPositions* es null, las tabulaciones se expanden hasta ocho anchos de carácter medios. Si *nTabPositions* es 1, las tabulaciones se separan por la distancia especificada por el primer valor de la matriz a la que apunta *lpnTabStopPositions* . Si *lpnTabStopPositions* apunta a más de un valor único, se establece una tabulación para cada valor de la matriz, hasta el número especificado por *nTabPositions*.

##  <a name="getoutputtextextent"></a>CDC:: GetOutputTextExtent

Llame a esta función miembro para usar el contexto de dispositivo de salida, [m_hDC](#m_hdc)y calcule el ancho y el alto de una línea de texto con la fuente actual.

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parámetros

*lpszString*<br/>
Apunta a una cadena de caracteres. También puede pasar un objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para este parámetro.

*nCount*<br/>
Especifica la [longitud de la cadena a la](/windows/win32/gdi/specifying-length-of-text-output-string) que apunta *lpszString*.

*str*<br/>
`CString` objeto que contiene los caracteres especificados que se van a medir.

### <a name="return-value"></a>Valor devuelto

Las dimensiones de la cadena (en unidades lógicas) devueltas en un objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Observaciones

La región de recorte actual no afecta al ancho y al alto devueltos por `GetOutputTextExtent`.

Dado que algunos dispositivos no colocan caracteres en matrices de celdas normales (es decir, llevan a cabo el kerning), la suma de las extensiones de los caracteres de una cadena puede no ser igual a la extensión de la cadena.

##  <a name="getoutputtextmetrics"></a>CDC:: GetOutputTextMetrics

Recupera las métricas de la fuente actual mediante `m_hDC`, el contexto del dispositivo de salida.

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parámetros

*lpMetrics*<br/>
Apunta a la estructura [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) que recibe las métricas.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

##  <a name="getpath"></a>CDC:: GetPath

Recupera las coordenadas que definen los extremos de las líneas y los puntos de control de las curvas que se encuentran en la ruta de acceso que está seleccionada en el contexto del dispositivo.

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de estructuras de datos de [punto](/windows/win32/api/windef/ns-windef-point) o `CPoint` objetos en los que se colocan los extremos de línea y los puntos de control de curva.

*lpTypes*<br/>
Apunta a una matriz de bytes donde se colocan los tipos de vértices. Los valores son uno de los siguientes:

- PT_MOVETO especifica que el punto correspondiente en *lpPoints* inicia una figura separada.

- PT_LINETO especifica que el punto anterior y el punto correspondiente de *lpPoints* son los extremos de una línea.

- PT_BEZIERTO especifica que el punto correspondiente en *lpPoints* es un punto de control o punto final para una curva Bzier.

Los tipos de PT_BEZIERTO siempre se producen en conjuntos de tres. El punto de la ruta de acceso inmediatamente anterior define el punto inicial de la curva Bzier. Los dos primeros puntos PT_BEZIERTO son los puntos de control y el tercer punto de PT_BEZIERTO es el punto final (si está codificado de forma rígida).

   Un tipo PT_LINETO o PT_BEZIERTO se puede combinar con la siguiente marca (mediante el operador bit a bit **o**) para indicar que el punto correspondiente es el último punto de una figura y que la figura debe cerrarse:

- PT_CLOSEFIGURE especifica que la figura se cierra automáticamente después de que se dibuje la línea o curva correspondiente. La ilustración se cierra dibujando una línea desde el extremo de línea o curva hasta el punto correspondiente al último PT_MOVETO.

*nCount*<br/>
Especifica el número total de estructuras de datos de [punto](/windows/win32/api/windef/ns-windef-point) que se pueden colocar en la matriz *lpPoints* . Este valor debe ser el mismo que el número de bytes que se pueden colocar en la matriz *lpTypes* .

### <a name="return-value"></a>Valor devuelto

Si el parámetro *nCount* es distinto de cero, el número de puntos enumerados. Si *nCount* es 0, el número total de puntos de la ruta de acceso (y `GetPath` no escribe nada en los búferes). Si *nCount* es distinto de cero y es menor que el número de puntos de la ruta de acceso, el valor devuelto es-1.

### <a name="remarks"></a>Observaciones

El contexto de dispositivo debe contener una ruta de acceso cerrada. Los puntos de la ruta de acceso se devuelven en coordenadas lógicas. Los puntos se almacenan en la ruta de acceso en coordenadas de dispositivo, por lo que `GetPath` cambia los puntos de las coordenadas del dispositivo a las coordenadas lógicas mediante el inverso de la transformación actual. Se puede llamar a la función miembro `FlattenPath` antes de `GetPath`, para convertir todas las curvas del trazado en segmentos de línea.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC:: BeginPath](#beginpath).

##  <a name="getpixel"></a>CDC:: GetPixel

Recupera el valor de color RGB del píxel en el punto especificado por *x* *e y*.

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x lógica del punto que se va a examinar.

*y*<br/>
Especifica la coordenada y lógica del punto que se va a examinar.

*Elija*<br/>
Especifica las coordenadas lógicas x e y del punto que se va a examinar.

### <a name="return-value"></a>Valor devuelto

Para cualquier versión de la función, valor de color RGB para el color del punto determinado. Es-1 si las coordenadas no especifican un punto en la región de recorte.

### <a name="remarks"></a>Observaciones

El punto debe estar en la región de recorte. Si el punto no está en la región de recorte, la función no tiene ningún efecto y devuelve-1.

No todos los dispositivos admiten la función `GetPixel`. Para obtener más información, vea la funcionalidad RC_BITBLT raster en la función miembro [GetDeviceCaps](#getdevicecaps) .

La función miembro `GetPixel` tiene dos formas. La primera toma dos valores de coordenadas; la segunda toma una estructura [Point](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

##  <a name="getpolyfillmode"></a>CDC:: GetPolyFillMode

Recupera el modo de relleno de polígonos actual.

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>Valor devuelto

Modo rellenado de polígono actual, alternativo o de bobinado, si la función se realiza correctamente.

### <a name="remarks"></a>Observaciones

Vea la función miembro `SetPolyFillMode` para obtener una descripción de los modos de relleno de polígonos.

##  <a name="getrop2"></a>CDC:: GetROP2

Recupera el modo de dibujo actual.

```
int GetROP2() const;
```

### <a name="return-value"></a>Valor devuelto

Modo de dibujo. Para obtener una lista de los valores de modo de dibujo, vea la función miembro `SetROP2`.

### <a name="remarks"></a>Observaciones

El modo de dibujo especifica cómo se combinan los colores del lápiz y el interior de los objetos rellenos con el color que ya está en la superficie de la pantalla.

##  <a name="getsafehdc"></a>CDC:: GetSafeHdc

Llame a esta función miembro para obtener [m_hDC](#m_hdc), el contexto del dispositivo de salida.

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>Valor devuelto

Identificador de contexto del dispositivo.

### <a name="remarks"></a>Observaciones

Esta función miembro también funciona con punteros nulos.

##  <a name="getstretchbltmode"></a>CDC:: GetStretchBltMode

Recupera el modo de ajuste de mapa de bits actual.

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>Valor devuelto

El valor devuelto especifica el modo de ajuste de mapa de bits actual, STRETCH_ANDSCANS, STRETCH_DELETESCANS o STRETCH_ORSCANS, si la función se realiza correctamente.

### <a name="remarks"></a>Observaciones

El modo de ajuste de mapa de bits define cómo se quita la información de los mapas de bits que se ajustan o se comprimen mediante la función miembro `StretchBlt`.

Los modos STRETCH_ANDSCANS y STRETCH_ORSCANS se suelen usar para conservar los píxeles de primer plano en mapas de bits monocromáticos. El modo de STRETCH_DELETESCANS se usa normalmente para conservar el color en los mapas de bits de color.

##  <a name="gettabbedtextextent"></a>CDC:: GetTabbedTextExtent

Llame a esta función miembro para calcular el ancho y el alto de una cadena de caracteres mediante [m_hAttribDC](#m_hattribdc), el contexto de dispositivo de atributo.

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parámetros

*lpszString*<br/>
Apunta a una cadena de caracteres. También puede pasar un objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para este parámetro.

*nCount*<br/>
Especifica la [longitud de la cadena a la](/windows/win32/gdi/specifying-length-of-text-output-string) que apunta *lpszString*.

*nTabPositions*<br/>
Especifica el número de posiciones de tabulación en la matriz a la que señala *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Apunta a una matriz de enteros que contiene las posiciones de tabulación en unidades lógicas. Las tabulaciones se deben ordenar en orden ascendente; el valor x más pequeño debe ser el primer elemento de la matriz. No se permiten las pestañas atrás.

*str*<br/>
`CString` objeto que contiene los caracteres especificados que se van a dibujar.

### <a name="return-value"></a>Valor devuelto

Dimensiones de la cadena (en unidades lógicas) en un objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Observaciones

Si la cadena contiene uno o más caracteres de tabulación, el ancho de la cadena se basa en las paradas de tabulación especificadas por *lpnTabStopPositions*. La función usa la fuente seleccionada actualmente para calcular las dimensiones de la cadena.

La región de recorte actual no desplaza el ancho y el alto devueltos por la función `GetTabbedTextExtent`.

Dado que algunos dispositivos no colocan caracteres en matrices de celdas normales (es decir, intercalan los caracteres), la suma de las extensiones de los caracteres de una cadena puede no ser igual a la extensión de la cadena.

Si *nTabPositions* es 0 y *lpnTabStopPositions* es null, las tabulaciones se expanden hasta ocho veces el ancho promedio de caracteres. Si *nTabPositions* es 1, las tabulaciones se separan por la distancia especificada por el primer valor de la matriz a la que apunta *lpnTabStopPositions* . Si *lpnTabStopPositions* apunta a más de un valor único, se establece una tabulación para cada valor de la matriz, hasta el número especificado por *nTabPositions*.

##  <a name="gettextalign"></a>CDC:: GetTextAlign

Recupera el estado de las marcas de alineación de texto para el contexto del dispositivo.

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>Valor devuelto

El estado de las marcas de alineación de texto. El valor devuelto es uno o varios de los siguientes valores:

- TA_BASELINE especifica la alineación del eje x y la línea base de la fuente elegida en el rectángulo delimitador.

- TA_BOTTOM especifica la alineación del eje x y la parte inferior del rectángulo delimitador.

- TA_CENTER especifica la alineación del eje y y el centro del rectángulo delimitador.

- TA_LEFT especifica la alineación del eje y y del lado izquierdo del rectángulo delimitador.

- TA_NOUPDATECP especifica que la posición actual no se actualiza.

- TA_RIGHT especifica la alineación del eje y y del lado derecho del rectángulo delimitador.

- TA_TOP especifica la alineación del eje x y la parte superior del rectángulo delimitador.

- TA_UPDATECP especifica que la posición actual está actualizada.

### <a name="remarks"></a>Observaciones

Las marcas de alineación de texto determinan cómo las funciones miembro `TextOut` y `ExtTextOut` alinean una cadena de texto en relación con el punto inicial de la cadena. Las marcas de alineación de texto no son necesariamente marcas de un solo bit y pueden ser iguales a 0. Para comprobar si se ha establecido una marca, una aplicación debe seguir estos pasos:

1. Aplique el operador OR bit a bit a la marca y sus marcas relacionadas, agrupadas de la siguiente manera:

    - TA_LEFT, TA_CENTER y TA_RIGHT

    - TA_BASELINE, TA_BOTTOM y TA_TOP

    - TA_NOUPDATECP y TA_UPDATECP

1. Aplique el operador and bit a bit al resultado y el valor devuelto de `GetTextAlign`.

1. Compruebe la igualdad de este resultado y la marca.

##  <a name="gettextcharacterextra"></a>CDC:: GetTextCharacterExtra

Recupera el valor actual para la cantidad de espaciado entre caracteres.

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>Valor devuelto

La cantidad del espaciado entre caracteres.

### <a name="remarks"></a>Observaciones

GDI agrega este espaciado a cada carácter, incluidos los caracteres de salto, cuando escribe una línea de texto en el contexto del dispositivo.

El valor predeterminado para la cantidad de espaciado entre caracteres es 0.

##  <a name="gettextcolor"></a>CDC:: GetTextColor

Recupera el color del texto actual.

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>Valor devuelto

El color del texto actual como un valor de color RGB.

### <a name="remarks"></a>Observaciones

El color del texto es el color de primer plano de los caracteres dibujados mediante las funciones miembro de salida de texto GDI [TextOut](#textout), [ExtTextOut](#exttextout)y [TabbedTextOut](#tabbedtextout).

##  <a name="gettextextent"></a>CDC:: GetTextExtent

Llame a esta función miembro para calcular el ancho y el alto de una línea de texto utilizando la fuente actual para determinar las dimensiones.

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parámetros

*lpszString*<br/>
Apunta a una cadena de caracteres. También puede pasar un objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para este parámetro.

*nCount*<br/>
Especifica el número de caracteres de la cadena.

*str*<br/>
`CString` objeto que contiene los caracteres especificados.

### <a name="return-value"></a>Valor devuelto

Dimensiones de la cadena (en unidades lógicas) en un objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Observaciones

La información se recupera de [m_hAttribDC](#m_hattribdc), el contexto de dispositivo de atributo.

De forma predeterminada, `GetTextExtent` asume que el texto para el que recupera la dimensión se establece a lo largo de una línea horizontal (es decir, el escape es 0). Si crea una fuente que especifica un escape distinto de cero, debe convertir explícitamente el ángulo del texto para obtener las dimensiones de la cadena.

La región de recorte actual no afecta al ancho y al alto devueltos por `GetTextExtent`.

Dado que algunos dispositivos no colocan caracteres en matrices de celdas normales (es decir, llevan a cabo el kerning), la suma de las extensiones de los caracteres de una cadena puede no ser igual a la extensión de la cadena.

##  <a name="gettextextentexpointi"></a>CDC:: GetTextExtentExPointI

Recupera el número de caracteres de una cadena especificada que caben dentro de un espacio especificado y rellena una matriz con la extensión de texto de cada uno de esos caracteres.

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*pgiIn*<br/>
Puntero a una matriz de índices de glifo para el que se van a recuperar las extensiones.

*cgi*<br/>
Especifica el número de glifos de la matriz a la que apunta *pgiIn*.

*nMaxExtent*<br/>
Especifica el ancho máximo permitido, en unidades lógicas, de la cadena con formato.

*lpnFit*<br/>
Un puntero a un entero que recibe un recuento del número máximo de caracteres que caben en el espacio especificado por *nMaxExtent*. Cuando *lpnFit* es null, *nMaxExtent* se omite.

*alpDx*<br/>
Puntero a una matriz de enteros que recibe extensiones de glifo parcial. Cada elemento de la matriz proporciona la distancia, en unidades lógicas, entre el principio de la matriz de índices de glifo y uno de los glifos que cabe en el espacio especificado por *nMaxExtent*. Aunque esta matriz debería tener al menos el mismo número de elementos que los índices de glifo especificados por *cgi*, la función rellena la matriz con extensiones solo para tantos índices de glifo como se especifican en *lpnFit*. Si *lpnDx* es null, la función no calcula anchos de cadena parciales.

*lpSize*<br/>
Puntero a una estructura de [tamaño](/windows/win32/api/windef/ns-windef-size) que recibe las dimensiones de la matriz de índices de glifo, en unidades lógicas. Este valor no puede ser NULL.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función miembro emula la funcionalidad de la función [GetTextExtentExPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentexpointi), tal y como se describe en el Windows SDK.

##  <a name="gettextextentpointi"></a>CDC:: GetTextExtentPointI

Recupera el ancho y el alto de la matriz especificada de índices de glifo.

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*pgiIn*<br/>
Puntero a una matriz de índices de glifo para el que se van a recuperar las extensiones.

*cgi*<br/>
Especifica el número de glifos de la matriz a la que apunta *pgiIn*.

*lpSize*<br/>
Puntero a una estructura de [tamaño](/windows/win32/api/windef/ns-windef-size) que recibe las dimensiones de la matriz de índices de glifo, en unidades lógicas. Este valor no puede ser NULL.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función miembro emula la funcionalidad de la función [GetTextExtentPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentpointi), tal y como se describe en el Windows SDK.

##  <a name="gettextface"></a>CDC:: GetTextFace

Llame a esta función miembro para copiar el nombre del tipo de letra de la fuente actual en un búfer.

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>Parámetros

*nCount*<br/>
Especifica el tamaño del búfer (en bytes). Si el nombre del tipo de letra es mayor que el número de bytes especificado por este parámetro, el nombre se trunca.

*lpszFacename*<br/>
Apunta al búfer para el nombre del tipo de letra.

*rString*<br/>
Referencia a un objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) .

### <a name="return-value"></a>Valor devuelto

Número de bytes copiados en el búfer, sin incluir el carácter nulo de terminación. Es 0 si se produce un error.

### <a name="remarks"></a>Observaciones

El nombre del tipo de letra se copia como una cadena terminada en NULL.

##  <a name="gettextmetrics"></a>CDC:: GetTextMetrics

Recupera las métricas de la fuente actual utilizando el contexto de dispositivo de atributo.

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parámetros

*lpMetrics*<br/>
Apunta a la estructura [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) que recibe las métricas.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

##  <a name="getviewportext"></a>CDC:: GetViewportExt

Recupera las extensiones x e y de la ventanilla del contexto del dispositivo.

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>Valor devuelto

Las extensiones x e y (en unidades de dispositivo) como un objeto `CSize`.

##  <a name="getviewportorg"></a>CDC:: GetViewportOrg

Recupera las coordenadas x e y del origen de la ventanilla asociada al contexto del dispositivo.

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>Valor devuelto

El origen de la ventanilla (en coordenadas de dispositivo) como un objeto `CPoint`.

##  <a name="getwindow"></a>CDC:: GetWindow

Devuelve la ventana asociada con el contexto de dispositivo de pantalla.

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>Valor devuelto

Puntero a un objeto `CWnd` si es correcto; de lo contrario, NULL.

### <a name="remarks"></a>Observaciones

Se trata de una función avanzada. Por ejemplo, esta función miembro no puede devolver la ventana ver al imprimir o en la vista previa de impresión. Siempre devuelve la ventana asociada a la salida. Las funciones de salida que usan el DC dado dibujan en esta ventana.

##  <a name="getwindowext"></a>CDC:: GetWindowExt

Recupera las extensiones x e y de la ventana asociada al contexto del dispositivo.

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>Valor devuelto

Las extensiones x e y (en unidades lógicas) como un objeto `CSize`.

##  <a name="getwindoworg"></a>CDC:: GetWindowOrg

Recupera las coordenadas x e y del origen de la ventana asociada al contexto del dispositivo.

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>Valor devuelto

El origen de la ventana (en coordenadas lógicas) como un objeto `CPoint`.

##  <a name="getworldtransform"></a>CDC:: GetWorldTransform

Recupera el espacio global actual en la transformación de espacio en la página.

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>Parámetros

*rXform*<br/>
Referencia a una estructura [XForm](/windows/win32/api/wingdi/ns-wingdi-xform) que recibe el espacio global actual para la transformación de espacio en la página.

### <a name="return-value"></a>Valor devuelto

Devuelve un valor distinto de cero en caso de éxito.

Devuelve 0 en caso de error.

Para obtener información de error extendida, llame a [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Observaciones

Este método ajusta la función GDI de Windows [GetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-getworldtransform).

##  <a name="gradientfill"></a>CDC:: GradientFill

Llame a esta función miembro para rellenar las estructuras de rectángulo y triángulos con un color que se atenúe suavemente de un lado a otro.

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>Parámetros

*pVertices*<br/>
Puntero a una matriz de estructuras de [TRIvértices](/windows/win32/api/wingdi/ns-wingdi-trivertex) que definen un vértice de triángulo.

*nVertices*<br/>
El número de vértices.

*pMesh*<br/>
Matriz de estructuras de [GRADIENT_TRIANGLE](/windows/win32/api/wingdi/ns-wingdi-gradient_triangle) en modo triángulo o una matriz de estructuras de [GRADIENT_RECT](/windows/win32/api/wingdi/ns-wingdi-gradient_rect) en modo de rectángulo.

*nMeshElements*<br/>
El número de elementos (triángulos o rectángulos) en *pmesh*.

*dwMode*<br/>
Especifica el modo de relleno de degradado. Para obtener una lista de los valores posibles, vea [GradientFill](/windows/win32/api/wingdi/nf-wingdi-gradientfill) en el Windows SDK.

### <a name="return-value"></a>Valor devuelto

TRUE si es correcto; en caso contrario, FALSE.

### <a name="remarks"></a>Observaciones

Para obtener más información, vea `GradientFill` en el Windows SDK.

##  <a name="graystring"></a>CDC:: GrayString

Dibuja texto atenuado (gris) en la ubicación especificada escribiendo el texto en un mapa de bits de memoria, atenuando el mapa de bits y, a continuación, copiando el mapa de bits en la pantalla.

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parámetros

*pBrush*<br/>
Identifica el pincel que se va a usar para atenuar (atenuación).

*lpfnOutput*<br/>
Especifica la dirección de instancia de procedimiento de la función de devolución de llamada proporcionada por la aplicación que dibujará la cadena. Para obtener más información, vea la descripción de la [función de devolución de llamada](callback-functions-used-by-mfc.md#graystring)de Windows `OutputFunc`. Si este parámetro es NULL, el sistema utiliza la función de `TextOut` de Windows para dibujar la cadena y se supone que *lpData* es un puntero largo a la cadena de caracteres que se va a mostrar.

*lpData*<br/>
Especifica un puntero lejano a los datos que se van a pasar a la función de salida. Si *lpfnOutput* es null, *lpData* debe ser un puntero largo a la cadena que se va a generar.

*nCount*<br/>
Especifica el número de caracteres que se van a generar. Si este parámetro es 0, `GrayString` calcula la longitud de la cadena (suponiendo que *lpData* es un puntero a la cadena). Si *nCount* es 1 y la función a la que apunta *lpfnOutput* devuelve 0, la imagen se muestra pero no se atenúa.

*x*<br/>
Especifica la coordenada x lógica de la posición inicial del rectángulo que incluye la cadena.

*y*<br/>
Especifica la coordenada y lógica de la posición inicial del rectángulo que incluye la cadena.

*nWidth*<br/>
Especifica el ancho (en unidades lógicas) del rectángulo que incluye la cadena. Si *nWidth* es 0, `GrayString` calcula el ancho del área, suponiendo que *lpData* es un puntero a la cadena.

*nHeight*<br/>
Especifica el alto (en unidades lógicas) del rectángulo que incluye la cadena. Si *nHeight* es 0, `GrayString` calcula el alto del área, suponiendo que *lpData* es un puntero a la cadena.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si se dibuja la cadena, o 0 si la función `TextOut` o la función de salida proporcionada por la aplicación devolvieron 0, o si no había memoria suficiente para crear un mapa de bits de memoria para la atenuación.

### <a name="remarks"></a>Observaciones

La función atenúa el texto independientemente del pincel y el fondo seleccionados. La función miembro `GrayString` usa la fuente seleccionada actualmente. El modo de asignación de MM_TEXT debe estar seleccionado antes de usar esta función.

Una aplicación puede dibujar cadenas atenuadas (atenuadas) en los dispositivos que admiten un color gris sólido sin llamar a la función miembro `GrayString`. El color del sistema COLOR_GRAYTEXT es el color del sistema de color sólido que se usa para dibujar el texto deshabilitado. La aplicación puede llamar a la función de Windows `GetSysColor` para recuperar el valor de color de COLOR_GRAYTEXT. Si el color es distinto de 0 (negro), la aplicación puede llamar a la función miembro `SetTextColor` para establecer el color del texto en el valor de color y, a continuación, dibujar la cadena directamente. Si el color recuperado es negro, la aplicación debe llamar a `GrayString` para atenuar (gris) el texto.

Si *lpfnOutput* es null, GDI usa la función [TextOut](/windows/win32/api/wingdi/nf-wingdi-textoutw) de Windows y *lpData* se supone que es un puntero lejano al carácter que se va a mostrar. Si la función miembro `TextOut` no puede controlar los caracteres que se van a generar (por ejemplo, la cadena se almacena como un mapa de bits), la aplicación debe proporcionar su propia función de salida.

Tenga en cuenta también que todas las funciones de devolución de llamada deben interceptar las excepciones de Microsoft Foundation antes de volver a Windows, ya que no se pueden iniciar excepciones en los límites de devolución de llamada. Para obtener más información sobre las excepciones, vea el artículo [excepciones](../../mfc/exception-handling-in-mfc.md).

La función de devolución de llamada pasada a `GrayString` debe utilizar la Convención de llamada `__stdcall` y debe exportarse con `__declspec`.

Cuando el marco está en modo de vista previa, una llamada a la función miembro `GrayString` se convierte en una llamada `TextOut` y no se llama a la función de devolución de llamada.

##  <a name="himetrictodp"></a>CDC:: HIMETRICtoDP

Use esta función cuando convierta tamaños de HIMETRIC de OLE a píxeles.

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*lpSize*<br/>
Apunta a una estructura de [tamaño](/windows/win32/api/windef/ns-windef-size) o a un objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Observaciones

Si el modo de asignación del objeto de contexto del dispositivo es MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC o MM_HIMETRIC, la conversión se basa en el número de píxeles de la pulgada física. Si el modo de asignación es uno de los otros modos no restringidos (por ejemplo, MM_TEXT), la conversión se basa en el número de píxeles de la pulgada lógica.

##  <a name="himetrictolp"></a>CDC:: HIMETRICtoLP

Llame a esta función para convertir las unidades de HIMETRIC en unidades lógicas.

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*lpSize*<br/>
Apunta a una estructura de [tamaño](/windows/win32/api/windef/ns-windef-size) o a un objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Observaciones

Use esta función al obtener los tamaños de HIMETRIC de OLE y desea convertirlos al modo de asignación natural de la aplicación.

La conversión se realiza convirtiendo primero las unidades HIMETRIC en píxeles y, a continuación, convierte estas unidades en unidades lógicas mediante las unidades de asignación actuales del contexto del dispositivo. Tenga en cuenta que las extensiones de la ventana y la ventanilla del dispositivo afectarán al resultado.

##  <a name="intersectcliprect"></a>CDC:: IntersectClipRect

Crea una nueva región de recorte formando la intersección de la región actual y el rectángulo especificado por *x1*, *Y1*, *x2*e *Y2*.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parámetros

*1*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo.

*y1*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo.

*RCA*<br/>
Especifica la coordenada x lógica de la esquina inferior derecha del rectángulo.

*a2*<br/>
Especifica la coordenada y lógica de la esquina inferior derecha del rectángulo.

*lpRect*<br/>
Especifica el rectángulo. Puede pasar un objeto de `CRect` o un puntero a una estructura de `RECT` para este parámetro.

### <a name="return-value"></a>Valor devuelto

Tipo de la nueva región de recorte. Puede ser cualquiera de los siguientes valores:

- COMPLEXREGION nueva región de recorte tiene bordes superpuestos.

- El contexto de dispositivo de ERROR no es válido.

- NULLREGION nueva región de recorte está vacía.

- SIMPLEREGION nueva región de recorte no tiene bordes superpuestos.

### <a name="remarks"></a>Observaciones

GDI recorta todas las salidas posteriores para ajustarse al nuevo límite. El ancho y el alto no deben superar 32.767.

##  <a name="invertrect"></a>CDC:: InvertRect

Invierte el contenido del rectángulo especificado.

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Apunta a una `RECT` que contiene las coordenadas lógicas del rectángulo que se va a invertir. También puede pasar un objeto `CRect` para este parámetro.

### <a name="remarks"></a>Observaciones

La inversión es una operación NOT lógica y voltea los bits de cada píxel. En las pantallas monocromáticas, la función hace que los píxeles blancos estén en blanco y negro. En las pantallas de color, la inversión depende de cómo se generen los colores de la pantalla. La llamada a `InvertRect` dos veces con el mismo rectángulo restaura la presentación a sus colores anteriores.

Si el rectángulo está vacío, no se dibuja nada.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

##  <a name="invertrgn"></a>CDC:: InvertRgn

Invierte los colores de la región especificada por *pRgn*.

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parámetros

*pRgn*<br/>
Identifica la región que se va a invertir. Las coordenadas de la región se especifican en unidades lógicas.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

En las pantallas monocromáticas, la función hace que los píxeles blancos estén en blanco y negro. En las pantallas de color, la inversión depende de cómo se generen los colores de la pantalla.

##  <a name="isprinting"></a>CDC:: IsPrinting

Determina si el contexto de dispositivo se usa para imprimir.

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si el objeto `CDC` es un controlador de dominio de impresora; de lo contrario, es 0.

##  <a name="lineto"></a>CDC:: lineTo

Dibuja una línea desde la posición actual hasta, pero sin incluir, el punto especificado por *x* *e y* (o el *punto*).

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x lógica del extremo de la línea.

*y*<br/>
Especifica la coordenada y lógica del extremo de la línea.

*Elija*<br/>
Especifica el extremo de la línea. Puede pasar una estructura `POINT` o un objeto `CPoint` para este parámetro.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si se dibuja la línea; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La línea se dibuja con el lápiz seleccionado. La posición actual se establece en *x*, *y* o en *Point*.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CRect:: CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

##  <a name="lptodp"></a>CDC:: LPtoDP

Convierte unidades lógicas en unidades de dispositivo.

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de puntos. Cada punto de la matriz es una estructura de [punto](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

*nCount*<br/>
Número de puntos de la matriz.

*lpRect*<br/>
Apunta a una estructura [Rect](/windows/win32/api/windef/ns-windef-rect) o a un objeto [CRect](../../atl-mfc-shared/reference/crect-class.md) . Este parámetro se usa para el caso común de asignación de un rectángulo desde unidades lógicas a unidades de dispositivo.

*lpSize*<br/>
Apunta a una estructura de [tamaño](/windows/win32/api/windef/ns-windef-size) o a un objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Observaciones

La función asigna las coordenadas de cada punto, o dimensiones de un tamaño, del sistema de coordenadas lógicos de GDI a un sistema de coordenadas de dispositivo. La conversión depende del modo de asignación actual y de los valores de los orígenes y las extensiones de la ventana del dispositivo y de la ventanilla.

Las coordenadas x e y de los puntos son enteros con signo de 2 bytes en el intervalo de-32.768 a 32.767. En los casos en los que el modo de asignación daría como resultado valores mayores que estos límites, el sistema establece los valores en-32.768 y 32.767, respectivamente.

##  <a name="lptohimetric"></a>CDC:: LPtoHIMETRIC

Llame a esta función para convertir unidades lógicas en unidades de HIMETRIC.

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parámetros

*lpSize*<br/>
Apunta a una estructura de `SIZE` o un objeto `CSize`.

### <a name="remarks"></a>Observaciones

Use esta función cuando proporcione tamaños de HIMETRIC a OLE, convirtiéndolos desde el modo de asignación natural de la aplicación. Tenga en cuenta que las extensiones de la ventana y la ventanilla del dispositivo afectarán al resultado.

La conversión se realiza convirtiendo primero las unidades lógicas en píxeles usando las unidades de asignación actuales del contexto del dispositivo y, a continuación, convierte estas unidades en unidades de HIMETRIC.

##  <a name="m_hattribdc"></a>CDC:: m_hAttribDC

El contexto de dispositivo de atributo para este objeto `CDC`.

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>Observaciones

De forma predeterminada, este contexto de dispositivo es igual a `m_hDC`. En general, `CDC` GDI llama a que la información de solicitud del contexto del dispositivo se dirige a `m_hAttribDC`. Vea la descripción de la clase [CDC](../../mfc/reference/cdc-class.md) para obtener más información sobre el uso de estos dos contextos de dispositivo.

##  <a name="m_hdc"></a>CDC:: m_hDC

Contexto de dispositivo de salida para este objeto `CDC`.

```
HDC m_hDC;
```

### <a name="remarks"></a>Observaciones

De forma predeterminada, `m_hDC` es igual a `m_hAttribDC`, el otro contexto de dispositivo incluido en `CDC`. En general, las llamadas de GDI de `CDC` que crean la salida van al contexto de dispositivo `m_hDC`. Puede inicializar `m_hDC` y `m_hAttribDC` para que apunten a distintos dispositivos. Vea la descripción de la clase [CDC](../../mfc/reference/cdc-class.md) para obtener más información sobre el uso de estos dos contextos de dispositivo.

##  <a name="maskblt"></a>CDC:: MaskBlt

Combina los datos de color de los mapas de bits de origen y de destino usando la máscara y la operación de trama dadas.

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo de destino.

*y*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo de destino.

*nWidth*<br/>
Especifica el ancho, en unidades lógicas, del rectángulo de destino y el mapa de bits de origen.

*nHeight*<br/>
Especifica el alto, en unidades lógicas, del rectángulo de destino y el mapa de bits de origen.

*pSrcDC*<br/>
Identifica el contexto de dispositivo desde el que se va a copiar el mapa de bits. Debe ser cero si el parámetro *dwRop* especifica una operación de trama que no incluye un origen.

*xSrc*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del mapa de bits de origen.

*ySrc*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del mapa de bits de origen.

*maskBitmap*<br/>
Identifica el mapa de bits de máscara monocromática combinado con el mapa de bits de color en el contexto del dispositivo de origen.

*xMask*<br/>
Especifica el desplazamiento de píxeles horizontal para el mapa de bits de la máscara especificado por el parámetro *maskBitmap* .

*yMask*<br/>
Especifica el desplazamiento de píxeles vertical para el mapa de bits de la máscara especificado por el parámetro *maskBitmap* .

*dwRop*<br/>
Especifica los códigos de operación de trama ternaria de primer y segundo plano, que utiliza la función para controlar la combinación de datos de origen y de destino. El código de operación de trama de fondo se almacena en el byte alto de la palabra alta de este valor; el código de operación de trama de primer plano se almacena en el byte bajo de la palabra alta de este valor; la palabra baja de este valor se omite y debe ser cero. La macro MAKEROP4 crea dichas combinaciones de códigos de operación de trama de primer plano y de fondo. Vea la sección Comentarios para obtener una explicación sobre el primer plano y el fondo en el contexto de esta función. Vea la función miembro `BitBlt` para obtener una lista de códigos de operación de trama comunes.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Un valor de 1 en la máscara especificada por *maskBitmap* indica que el código de operación de trama de primer plano especificado por *dwRop* debe aplicarse en esa ubicación. Un valor de 0 en la máscara indica que el código de operación de trama de fondo especificado por *dwRop* debe aplicarse en esa ubicación. Si las operaciones de trama requieren un origen, el rectángulo de máscara debe cubrir el rectángulo de origen. Si no es así, se producirá un error en la función. Si las operaciones de trama no requieren un origen, el rectángulo de máscara debe cubrir el rectángulo de destino. Si no es así, se producirá un error en la función.

Si hay una transformación de giro o recorte en vigor para el contexto de dispositivo de origen cuando se llama a esta función, se produce un error. Sin embargo, se permiten otros tipos de transformaciones.

Si los formatos de color de los mapas de bits de origen, patrón y destino difieren, esta función convierte el patrón o el formato de origen, o ambos, para que coincidan con el formato de destino. Si el mapa de bits de la máscara no es un mapa de bits monocromo, se produce un error. Cuando se graba un metarchivo mejorado, se produce un error (y la función devuelve 0) si el contexto de dispositivo de origen identifica un contexto de dispositivo de metarchivo mejorado. No todos los dispositivos admiten `MaskBlt`. Una aplicación debe llamar a `GetDeviceCaps` para determinar si un dispositivo admite esta función. Si no se proporciona ningún mapa de bits de máscara, esta función se comporta exactamente igual que `BitBlt`, mediante el código de operación de trama de primer plano. Los desplazamientos de píxeles en el mapa de bits de la máscara se asignan al punto (0,0) en el mapa de bits del contexto del dispositivo de origen. Esto resulta útil para los casos en los que un mapa de bits de máscara contiene un conjunto de máscaras; una aplicación puede aplicar fácilmente cualquiera de ellas a una tarea Mask-blitting ajustando los desplazamientos de píxeles y los tamaños de rectángulo enviados a `MaskBlt`.

##  <a name="modifyworldtransform"></a>CDC:: ModifyWorldTransform

Cambia la transformación universal para un contexto de dispositivo mediante el modo especificado.

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>Parámetros

*rXform*<br/>
Referencia a una estructura [XForm](/windows/win32/api/wingdi/ns-wingdi-xform) utilizada para modificar la transformación universal para el contexto de dispositivo determinado.

*iMode*<br/>
Especifica cómo los datos de transformación modifican la transformación universal actual. Para obtener una lista de los valores que puede tomar este parámetro, vea [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

### <a name="return-value"></a>Valor devuelto

Devuelve un valor distinto de cero en caso de éxito.

Devuelve 0 en caso de error.

Para obtener información de error extendida, llame a [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Observaciones

Este método ajusta la función GDI de Windows [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

##  <a name="moveto"></a>CDC:: moveTo

Mueve la posición actual al punto especificado por *x* *e y* (o por *punto*).

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x lógica de la nueva posición.

*y*<br/>
Especifica la coordenada y lógica de la nueva posición.

*Elija*<br/>
Especifica la nueva posición. Puede pasar una estructura `POINT` o un objeto `CPoint` para este parámetro.

### <a name="return-value"></a>Valor devuelto

Las coordenadas x e y de la posición anterior como un objeto `CPoint`.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CRect:: CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

##  <a name="offsetcliprgn"></a>CDC:: OffsetClipRgn

Mueve la región de recorte del contexto del dispositivo según los desplazamientos especificados.

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica el número de unidades lógicas que se mueven a la izquierda o a la derecha.

*y*<br/>
Especifica el número de unidades lógicas que se van a subir o bajar.

*size*<br/>
Especifica la cantidad que se va a desplazar.

### <a name="return-value"></a>Valor devuelto

El tipo de la nueva región. Puede ser cualquiera de los siguientes valores:

- La región de recorte de COMPLEXREGION tiene bordes superpuestos.

- El contexto de dispositivo de ERROR no es válido.

- La región de recorte de NULLREGION está vacía.

- La región de recorte SIMPLEREGION no tiene bordes superpuestos.

### <a name="remarks"></a>Observaciones

La función mueve las unidades de la región *x* a lo largo del eje x y las unidades *y* a lo largo del eje y.

##  <a name="offsetviewportorg"></a>CDC:: OffsetViewportOrg

Modifica las coordenadas del origen de la ventanilla en relación con las coordenadas del origen de la ventanilla actual.

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parámetros

*nWidth*<br/>
Especifica el número de unidades de dispositivo que se van a agregar a la coordenada x del origen actual.

*nHeight*<br/>
Especifica el número de unidades de dispositivo que se van a agregar a la coordenada y del origen actual.

### <a name="return-value"></a>Valor devuelto

Origen de la ventanilla anterior (en coordenadas de dispositivo) como un objeto de `CPoint`.

##  <a name="offsetwindoworg"></a>CDC:: OffsetWindowOrg

Modifica las coordenadas del origen de la ventana con respecto a las coordenadas del origen de la ventana actual.

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parámetros

*nWidth*<br/>
Especifica el número de unidades lógicas que se van a agregar a la coordenada x del origen actual.

*nHeight*<br/>
Especifica el número de unidades lógicas que se van a agregar a la coordenada y del origen actual.

### <a name="return-value"></a>Valor devuelto

El origen de la ventana anterior (en coordenadas lógicas) como un objeto `CPoint`.

##  <a name="operator_hdc"></a>CDC:: Operator HDC

Utilice este operador para recuperar el identificador de contexto de dispositivo del objeto `CDC`.

```
operator HDC() const;
```

### <a name="return-value"></a>Valor devuelto

Si es correcto, el identificador del objeto de contexto del dispositivo; de lo contrario, es NULL.

### <a name="remarks"></a>Observaciones

Puede utilizar el identificador para llamar a las API de Windows directamente.

##  <a name="paintrgn"></a>CDC::P aintRgn

Rellena la región especificada por *pRgn* con el pincel actual.

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parámetros

*pRgn*<br/>
Identifica la región que se va a rellenar. Las coordenadas de la región determinada se especifican en unidades lógicas.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

##  <a name="patblt"></a>CDC::P atBlt

Crea un patrón de bits en el dispositivo.

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x lógica de la esquina superior izquierda del rectángulo que va a recibir el patrón.

*y*<br/>
Especifica la coordenada y lógica de la esquina superior izquierda del rectángulo que va a recibir el patrón.

*nWidth*<br/>
Especifica el ancho (en unidades lógicas) del rectángulo que va a recibir el patrón.

*nHeight*<br/>
Especifica el alto (en unidades lógicas) del rectángulo que va a recibir el patrón.

*dwRop*<br/>
Especifica el código de operación de trama. Los códigos de operación de trama (ROPs) definen cómo combina GDI los colores de las operaciones de salida que implican un pincel actual, un mapa de bits de origen posible y un mapa de bits de destino. Este parámetro puede ser uno de los siguientes valores:

- PATCOPY copia el patrón en el mapa de bits de destino.

- PATINVERT combina el mapa de bits de destino con el patrón mediante el operador booleano XOR.

- DSTINVERT invierte el mapa de bits de destino.

- La impresión de color negro activa todas las salidas.

- La impresión convierte todo el blanco de salida.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El patrón es una combinación del pincel seleccionado y el patrón que ya está en el dispositivo. El código de operación de trama especificado por *dwRop* define cómo se van a combinar los patrones. Las operaciones de tramas que se enumeran para esta función son un subconjunto limitado de los códigos de operación de tramas sindireccionales 256 completos; en concreto, no se puede utilizar un código de operación de trama que haga referencia a un origen.

No todos los contextos de dispositivo admiten la función `PatBlt`. Para determinar si un contexto de dispositivo admite `PatBlt`, llame a la función miembro `GetDeviceCaps` con el índice RASTERCAPS y compruebe el valor devuelto para la marca RC_BITBLT.

##  <a name="pie"></a>CDC::P IE

Dibuja una cuña en forma circular dibujando un arco elíptico cuyo centro y dos puntos de conexión se unen mediante líneas.

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parámetros

*1*<br/>
Especifica la coordenada x de la esquina superior izquierda del rectángulo delimitador (en unidades lógicas).

*y1*<br/>
Especifica la coordenada y de la esquina superior izquierda del rectángulo delimitador (en unidades lógicas).

*RCA*<br/>
Especifica la coordenada x de la esquina inferior derecha del rectángulo delimitador (en unidades lógicas).

*a2*<br/>
Especifica la coordenada y de la esquina inferior derecha del rectángulo delimitador (en unidades lógicas).

*X3*<br/>
Especifica la coordenada x del punto inicial del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco.

*Single*<br/>
Especifica la coordenada y del punto inicial del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco.

*x4*<br/>
Especifica la coordenada x del extremo del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco.

*Y4*<br/>
Especifica la coordenada y del extremo del arco (en unidades lógicas). Este punto no tiene que estar situado exactamente en el arco.

*lpRect*<br/>
Especifica el rectángulo delimitador. Puede pasar un objeto de `CRect` o un puntero a una estructura de `RECT` para este parámetro.

*ptStart*<br/>
Especifica el punto inicial del arco. Este punto no tiene que estar situado exactamente en el arco. Puede pasar una estructura de [punto](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parámetro.

*ptEnd*<br/>
Especifica el extremo del arco. Este punto no tiene que estar situado exactamente en el arco. Puede pasar una estructura `POINT` o un objeto `CPoint` para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El centro del arco es el centro del rectángulo delimitador especificado por *x1*, *Y1*, *x2*e *Y2* (o por *lpRect*). Los puntos inicial y final del arco se especifican mediante *x3*, *Y3*, *x4*y *Y4* (o por *ptStart* y *ptEnd*).

El arco se dibuja con el lápiz seleccionado, moviéndolo en sentido contrario a las agujas del reloj. Se extraen dos líneas adicionales de cada punto de conexión al centro del arco. El área de forma circular se rellena con el pincel actual. Si *x3* es igual *a x4* y *Y3* es igual a *Y4*, el resultado es una elipse con una sola línea desde el centro de la elipse hasta el punto ( *x3*, *Y3*) o ( *x4*, *Y4*).

La ilustración dibujada por esta función se extiende hasta pero no incluye las coordenadas derecha e inferior. Esto significa que el alto de la figura es *y2* - *Y1* y el ancho de la ilustración es *x2* - *x1*. Tanto el ancho como el alto del rectángulo delimitador deben ser mayores de 2 unidades y menos de 32.767 unidades.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

##  <a name="playmetafile"></a>CDC::P layMetaFile

Reproduce el contenido del metarchivo especificado en el contexto del dispositivo.

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>Parámetros

*hMF*<br/>
Identifica el metarchivo que se va a reproducir.

*hEnhMetaFile*<br/>
Identifica el metarchivo mejorado.

*lpBounds*<br/>
Apunta a una estructura de `RECT` o un objeto `CRect` que contiene las coordenadas del rectángulo delimitador que se usa para mostrar la imagen. Las coordenadas se especifican en unidades lógicas.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El metarchivo se puede reproducir varias veces.

La segunda versión de `PlayMetaFile` muestra la imagen almacenada en el metarchivo de formato mejorado especificado. Cuando una aplicación llama a la segunda versión de `PlayMetaFile`, Windows usa el marco de imagen del encabezado Enhanced-Metafile para asignar la imagen al rectángulo señalado por el parámetro *lpBounds* . (Esta imagen se puede distorsionar o girar estableciendo la transformación del mundo en el dispositivo de salida antes de llamar a `PlayMetaFile`). Los puntos a lo largo de los bordes del rectángulo se incluyen en la imagen. Se puede recortar una imagen de metarchivo mejorado definiendo la región de recorte en el dispositivo de salida antes de reproducir el metarchivo mejorado.

Si un metarchivo mejorado contiene una paleta opcional, una aplicación puede lograr colores coherentes mediante la configuración de una paleta de colores en el dispositivo de salida antes de llamar a la segunda versión de `PlayMetaFile`. Para recuperar la paleta opcional, utilice la función de Windows `GetEnhMetaFilePaletteEntries`. Un metarchivo mejorado se puede incrustar en un metarchivo mejorado recién creado llamando a la segunda versión de `PlayMetaFile` y reproduciendo el metarchivo mejorado de origen en el contexto del dispositivo para el nuevo metarchivo mejorado.

Esta función conserva los Estados del contexto del dispositivo de salida. Esta función elimina cualquier objeto creado pero no eliminado en el metarchivo mejorado. Para detener esta función, una aplicación puede llamar a la función de Windows `CancelDC` desde otro subproceso para finalizar la operación. En este caso, la función devuelve cero.

##  <a name="plgblt"></a>CDC::P lgBlt

Realiza una transferencia de bloque de bits de los bits de los datos de color desde el rectángulo especificado en el contexto del dispositivo de origen al paralelogramo especificado en el contexto de dispositivo determinado.

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>Parámetros

*lpPoint*<br/>
Apunta a una matriz de tres puntos en el espacio lógico que identifica tres esquinas del paralelogramo de destino. La esquina superior izquierda del rectángulo de origen se asigna al primer punto de esta matriz, la esquina superior derecha al segundo punto de esta matriz y la esquina inferior izquierda al tercer punto. La esquina inferior derecha del rectángulo de origen se asigna al cuarto punto implícito del paralelogramo.

*pSrcDC*<br/>
Identifica el contexto de dispositivo de origen.

*xSrc*<br/>
Especifica la coordenada x, en unidades lógicas, de la esquina superior izquierda del rectángulo de origen.

*ySrc*<br/>
Especifica la coordenada y, en unidades lógicas, de la esquina superior izquierda del rectángulo de origen.

*nWidth*<br/>
Especifica el ancho, en unidades lógicas, del rectángulo de origen.

*nHeight*<br/>
Especifica el alto, en unidades lógicas, del rectángulo de origen.

*maskBitmap*<br/>
Identifica un mapa de bits monocromo opcional que se usa para enmascarar los colores del rectángulo de origen.

*xMask*<br/>
Especifica la coordenada x de la esquina superior izquierda del mapa de bits monocromo.

*yMask*<br/>
Especifica la coordenada y de la esquina superior izquierda del mapa de bits monocromo.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Si el identificador de máscara de bits especificado identifica un mapa de bits monocromo válido, la función utiliza este mapa de bits para enmascarar los bits de los datos de color del rectángulo de origen.

El cuarto vértice del paralelogramo (D) se define tratando los tres primeros puntos (A, B y C) como vectores y Computing D = B + C-A.

Si la máscara de la máscara existe, el valor 1 de la máscara indica que el color del píxel de origen debe copiarse en el destino. Un valor de 0 en la máscara indica que el color del píxel de destino no se va a cambiar.

Si el rectángulo de máscara es menor que los rectángulos de origen y de destino, la función replica el patrón de máscara.

Las transformaciones de escala, traslación y reflexión se permiten en el contexto del dispositivo de origen. sin embargo, las transformaciones de giro y de recorte no lo son. Si el mapa de bits de la máscara no es un mapa de bits monocromo, se produce un error. El modo de ajuste para el contexto de dispositivo de destino se usa para determinar cómo expandir o comprimir los píxeles, si es necesario. Cuando se graba un metarchivo mejorado, se produce un error si el contexto de dispositivo de origen identifica un contexto de dispositivo de metarchivo mejorado.

Las coordenadas de destino se transforman según el contexto de dispositivo de destino; las coordenadas de origen se transforman según el contexto de dispositivo de origen. Si la transformación de origen tiene una rotación o un corte, se devuelve un error. Si los rectángulos de origen y de destino no tienen el mismo formato de color, `PlgBlt` convierte el rectángulo de origen para que coincida con el rectángulo de destino. No todos los dispositivos admiten `PlgBlt`. Para obtener más información, vea la descripción de la funcionalidad de RC_BITBLT raster en la función miembro `CDC::GetDeviceCaps`.

Si los contextos de dispositivo de origen y de destino representan dispositivos incompatibles, `PlgBlt` devuelve un error.

##  <a name="polybezier"></a>CDC::P olyBezier

Dibuja una o varias curvas spline de Bzier.

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de estructuras de datos de [punto](/windows/win32/api/windef/ns-windef-point) que contienen los extremos y los puntos de control de las curvas spline.

*nCount*<br/>
Especifica el número de puntos de la matriz *lpPoints* . Este valor debe ser uno más de tres veces el número de splines que se van a dibujar, porque cada spline Bzier requiere dos puntos de control y un punto de conexión, y la spline inicial requiere un punto de partida adicional.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función dibuja curvas spline Bziers cúbicas mediante los puntos de conexión y los puntos de control especificados por el parámetro *lpPoints* . La primera spline se dibuja desde el primer punto hasta el cuarto punto utilizando el segundo y tercer punto como puntos de control. Cada spline subsiguiente de la secuencia necesita exactamente tres puntos más: el punto final de la spline anterior se usa como punto de partida, los dos puntos siguientes de la secuencia son puntos de control y el tercero es el punto final.

La función `PolyBezier` no usa ni actualiza la posición actual. La figura no se rellena. Esta función dibuja líneas utilizando el lápiz actual.

##  <a name="polybezierto"></a>CDC::P olyBezierTo

Dibuja una o varias curvas spline de Bzier.

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de estructuras de datos de [punto](/windows/win32/api/windef/ns-windef-point) que contiene los extremos y los puntos de control.

*nCount*<br/>
Especifica el número de puntos de la matriz *lpPoints* . Este valor debe ser tres veces el número de splines que se van a dibujar, porque cada spline Bzier requiere dos puntos de control y un punto final.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función dibuja splines Bzier cúbicas mediante los puntos de control especificados por el parámetro *lpPoints* . La primera spline se dibuja desde la posición actual hasta el tercer punto mediante los dos primeros puntos como puntos de control. Para cada spline subsiguiente, la función necesita exactamente tres puntos más y usa el punto final de la curva spline anterior como punto de partida para el siguiente. `PolyBezierTo` mueve la posición actual al punto final de la última spline Bzier. La figura no se rellena. Esta función dibuja líneas utilizando el lápiz actual.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC:: BeginPath](#beginpath).

##  <a name="polydraw"></a>CDC::P olyDraw

Dibuja un conjunto de segmentos de línea y curvas spline Bzier.

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de estructuras de datos de [punto](/windows/win32/api/windef/ns-windef-point) que contiene los extremos para cada segmento de línea y los extremos y puntos de control de cada spline de Bzier.

*lpTypes*<br/>
Apunta a una matriz que especifica cómo se usa cada punto de la matriz *lpPoints* . Los valores pueden ser cualquier de los siguientes:

- PT_MOVETO especifica que este punto inicia una figura separada. Este punto se convierte en la nueva posición actual.

- PT_LINETO especifica que una línea debe dibujarse desde la posición actual hasta este punto, que se convierte en la nueva posición actual.

- PT_BEZIERTO especifica que este punto es un punto de control o punto final para una spline Bzier.

Los tipos de PT_BEZIERTO siempre se producen en conjuntos de tres. La posición actual define el punto inicial de la curva spline Bzier. Los dos primeros puntos PT_BEZIERTO son los puntos de control y el tercer punto de PT_BEZIERTO es el punto final. El punto final se convierte en la nueva posición actual. Si no hay tres puntos de PT_BEZIERTO consecutivos, se produce un error.

   Un tipo PT_LINETO o PT_BEZIERTO se puede combinar con la siguiente constante mediante el operador bit a bit o para indicar que el punto correspondiente es el último punto de una figura y la figura está cerrada:

- PT_CLOSEFIGURE especifica que la figura se cierra automáticamente después de que se realice el tipo de PT_LINETO o PT_BEZIERTO para este punto. Una línea se dibuja desde este punto hasta el punto de PT_MOVETO o `MoveTo` más reciente.

   Esta marca se combina con el tipo de PT_LINETO para una línea o con el tipo de punto final PT_BEZIERTO para una spline Bzier, mediante el operador OR **bit a** bit. La posición actual se establece en el punto final de la línea de cierre.

*nCount*<br/>
Especifica el número total de puntos de la matriz *lpPoints* , igual que el número de bytes de la matriz *lpTypes* .

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función se puede utilizar para dibujar figuras disjuntos en lugar de llamadas consecutivas a `CDC::MoveTo`, `CDC::LineTo`y funciones miembro de `CDC::PolyBezierTo`. Las líneas y las curvas spline se dibujan utilizando el lápiz actual y las figuras no se rellenan. Si hay una ruta de acceso activa iniciada mediante una llamada a la función miembro `CDC::BeginPath`, `PolyDraw` agrega a la ruta de acceso. Los puntos contenidos en la matriz *lpPoints* y en *lpTypes* indican si cada punto forma parte de un `CDC::MoveTo`, un `CDC::LineTo`o una operación de `CDC::BezierTo`. También es posible cerrar figuras. Esta función actualiza la posición actual.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC:: BeginPath](#beginpath).

##  <a name="polygon"></a>CDC::P olygon

Dibuja un polígono que consta de dos o más puntos (vértices) conectados mediante líneas, utilizando el lápiz actual.

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de puntos que especifica los vértices del polígono. Cada punto de la matriz es una estructura de `POINT` o un objeto `CPoint`.

*nCount*<br/>
Especifica el número de vértices de la matriz.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El sistema cierra automáticamente el polígono, si es necesario, dibujando una línea desde el último vértice hasta el primero.

El modo de relleno de polígonos actual se puede recuperar o establecer mediante las funciones miembro `GetPolyFillMode` y `SetPolyFillMode`.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

##  <a name="polyline"></a>CDC::P olyline

Dibuja un conjunto de segmentos de línea que conectan los puntos especificados por *lpPoints*.

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de `POINT` estructuras o `CPoint` objetos que se van a conectar.

*nCount*<br/>
Especifica el número de puntos de la matriz. Este valor debe ser al menos 2.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Las líneas se dibujan desde el primer punto a través de los puntos siguientes con el lápiz actual. A diferencia de la función miembro `LineTo`, la función `Polyline` no usa ni actualiza la posición actual.

Para obtener más información, consulte [PolyLine](/windows/win32/api/wingdi/nf-wingdi-polyline) en el Windows SDK.

##  <a name="polylineto"></a>CDC::P olylineTo

Dibuja una o varias líneas rectas.

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de estructuras de datos de [punto](/windows/win32/api/windef/ns-windef-point) que contiene los vértices de la línea.

*nCount*<br/>
Especifica el número de puntos de la matriz.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Una línea se dibuja desde la posición actual hasta el primer punto especificado por el parámetro *lpPoints* usando el lápiz actual. Para cada línea adicional, la función dibuja desde el punto final de la línea anterior hasta el siguiente punto especificado por *lpPoints*. `PolylineTo` mueve la posición actual al punto final de la última línea. Si los segmentos de línea dibujados por esta función forman una figura cerrada, la figura no se rellena.

##  <a name="polypolygon"></a>CDC::P olyPolygon

Crea dos o más polígonos que se rellenan con el modo de relleno de polígonos actual.

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de `POINT` estructuras u objetos `CPoint` que definen los vértices de los polígonos.

*lpPolyCounts*<br/>
Apunta a una matriz de enteros, cada uno de los cuales especifica el número de puntos de uno de los polígonos de la matriz *lpPoints* .

*nCount*<br/>
Número de entradas de la matriz *lpPolyCounts* . Este número especifica el número de polígonos que se van a dibujar. Este valor debe ser al menos 2.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Los polígonos pueden estar separados o superpuestos.

Cada polígono especificado en una llamada a la función `PolyPolygon` debe estar cerrado. A diferencia de los polígonos creados por la función miembro `Polygon`, los polígonos creados por `PolyPolygon` no se cierran automáticamente.

La función crea dos o más polígonos. Para crear un solo polígono, una aplicación debe usar la función miembro `Polygon`.

El modo de relleno de polígonos actual se puede recuperar o establecer mediante las funciones miembro `GetPolyFillMode` y `SetPolyFillMode`.

##  <a name="polypolyline"></a>CDC::P olyPolyline

Dibuja varias series de segmentos de línea conectados.

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>Parámetros

*lpPoints*<br/>
Apunta a una matriz de estructuras que contiene los vértices de las polilíneas. Las polilíneas se especifican de forma consecutiva.

*lpPolyPoints*<br/>
Apunta a una matriz de variables que especifica el número de puntos de la matriz *lpPoints* para el polígono correspondiente. Cada entrada debe ser mayor o igual que 2.

*nCount*<br/>
Especifica el número total de recuentos de la matriz *lpPolyPoints* .

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Los segmentos de línea se dibujan utilizando el lápiz actual. No se rellenan las cifras que forman los segmentos. Esta función no usa ni actualiza la posición actual.

##  <a name="ptvisible"></a>CDC::P tVisible

Determina si el punto especificado está dentro de la región de recorte del contexto del dispositivo.

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x lógica del punto.

*y*<br/>
Especifica la coordenada y lógica del punto.

*Elija*<br/>
Especifica el punto para proteger las coordenadas lógicas. Puede pasar una estructura `POINT` o un objeto `CPoint` para este parámetro.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si el punto especificado está dentro de la región de recorte; de lo contrario, es 0.

##  <a name="queryabort"></a>CDC:: QueryAbort

Llama a la función Abort instalada por la función miembro [SetAbortProc](#setabortproc) para una aplicación de impresión y consulta si se debe terminar la impresión.

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>Valor devuelto

El valor devuelto es distinto de cero si la impresión debe continuar o si no hay ningún procedimiento de anulación. Es 0 si se debe terminar el trabajo de impresión. La función Abort proporciona el valor devuelto.

##  <a name="realizepalette"></a>CDC:: RealizePalette

Asigna entradas de la paleta lógica actual a la paleta del sistema.

```
UINT RealizePalette();
```

### <a name="return-value"></a>Valor devuelto

Indica el número de entradas de la paleta lógica que se han asignado a distintas entradas en la paleta del sistema. Representa el número de entradas que esta función ha reasignado para dar cabida a los cambios en la paleta del sistema desde la última vez que se realizó la paleta lógica.

### <a name="remarks"></a>Observaciones

Una paleta de colores lógica actúa como un búfer entre las aplicaciones con un uso intensivo de colores y el sistema, lo que permite que una aplicación use tantos colores como sea necesario sin interferir con sus propios colores mostrados o con colores mostrados por otras ventanas.

Cuando una ventana tiene el foco de entrada y llama `RealizePalette`, Windows garantiza que la ventana mostrará todos los colores solicitados hasta el número máximo disponible simultáneamente en la pantalla. Windows también muestra los colores no encontrados en la paleta de la ventana, para lo que los hace coincidir con los colores disponibles.

Además, Windows coincide con los colores solicitados por las ventanas inactivas que llaman a la función lo más cerca posible a los colores disponibles. Esto reduce significativamente los cambios no deseables en los colores mostrados en ventanas inactivas.

##  <a name="rectangle"></a>CDC:: Rectangle

Dibuja un rectángulo utilizando el lápiz actual.

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>Parámetros

*1*<br/>
Especifica la coordenada x de la esquina superior izquierda del rectángulo (en unidades lógicas).

*y1*<br/>
Especifica la coordenada y de la esquina superior izquierda del rectángulo (en unidades lógicas).

*RCA*<br/>
Especifica la coordenada x de la esquina inferior derecha del rectángulo (en unidades lógicas).

*a2*<br/>
Especifica la coordenada y de la esquina inferior derecha del rectángulo (en unidades lógicas).

*lpRect*<br/>
Especifica el rectángulo en unidades lógicas. Puede pasar un objeto de `CRect` o un puntero a una estructura de `RECT` para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El interior del rectángulo se rellena con el pincel actual.

El rectángulo extiende hasta, pero no incluye, las coordenadas derecha e inferior. Esto significa que el alto del rectángulo es *y2* - *Y1* y el ancho del rectángulo es *x2* - *x1*. El ancho y el alto de un rectángulo deben ser mayores de 2 unidades y menos de 32.767 unidades.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

##  <a name="rectvisible"></a>CDC:: RectVisible

Determina si alguna parte del rectángulo especificado está dentro de la región de recorte del contexto de presentación.

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>Parámetros

*lpRect*<br/>
Apunta a una estructura de `RECT` o un objeto `CRect` que contiene las coordenadas lógicas del rectángulo especificado.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si alguna parte del rectángulo especificado está dentro de la región de recorte; de lo contrario, es 0.

##  <a name="releaseattribdc"></a>CDC:: ReleaseAttribDC

Llame a esta función miembro para establecer `m_hAttribDC` en NULL.

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>Observaciones

Esto no hace que se produzca una `Detach`. Solo el contexto de dispositivo de salida se adjunta al objeto `CDC` y solo se puede desasociar.

##  <a name="releaseoutputdc"></a>CDC:: ReleaseOutputDC

Llame a esta función miembro para establecer el `m_hDC` miembro en NULL.

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>Observaciones

No se puede llamar a esta función miembro cuando el contexto de dispositivo de salida está asociado al objeto de `CDC`. Utilice la función miembro `Detach` para desasociar el contexto de dispositivo de salida.

##  <a name="resetdc"></a>CDC:: ResetDC

Llame a esta función miembro para actualizar el contexto de dispositivo encapsulado por el objeto `CDC`.

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>Parámetros

*lpDevMode*<br/>
Puntero a una estructura de `DEVMODE` de Windows.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El contexto del dispositivo se actualiza a partir de la información especificada en la estructura de Windows `DEVMODE`. Esta función miembro solo restablece el contexto de dispositivo de atributo.

Normalmente, una aplicación utilizará la función miembro `ResetDC` cuando una ventana procese un mensaje `WM_DEVMODECHANGE`. También puede usar esta función miembro para cambiar la orientación del papel o las bandejas de papel durante la impresión de un documento.

No puede usar esta función miembro para cambiar el nombre del controlador, el nombre del dispositivo o el puerto de salida. Cuando el usuario cambia la conexión del puerto o el nombre del dispositivo, debe eliminar el contexto del dispositivo original y crear un nuevo contexto de dispositivo con la nueva información.

Antes de llamar a esta función miembro, debe asegurarse de que todos los objetos (distintos de los objetos estándar) que se han seleccionado en el contexto del dispositivo se han seleccionado.

##  <a name="restoredc"></a>CDC:: RestoreDC

Restaura el contexto del dispositivo al estado anterior identificado por *nSavedDC*.

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>Parámetros

*nSavedDC*<br/>
Especifica el contexto de dispositivo que se va a restaurar. Puede ser un valor devuelto por una llamada de función `SaveDC` anterior. Si *nSavedDC* es-1, se restaura el contexto de dispositivo guardado más recientemente.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si se restauró el contexto especificado; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

`RestoreDC` restaura el contexto del dispositivo extrasacando información de estado de una pila creada por llamadas anteriores a la función miembro `SaveDC`.

La pila puede contener la información de estado de varios contextos de dispositivo. Si el contexto especificado por *nSavedDC* no está en la parte superior de la pila, `RestoreDC` elimina toda la información de estado entre el contexto de dispositivo especificado por *nSavedDC* y la parte superior de la pila. La información eliminada se pierde.

##  <a name="roundrect"></a>CDC:: RoundRect

Dibuja un rectángulo con esquinas redondeadas utilizando el lápiz actual.

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>Parámetros

*1*<br/>
Especifica la coordenada x de la esquina superior izquierda del rectángulo (en unidades lógicas).

*y1*<br/>
Especifica la coordenada y de la esquina superior izquierda del rectángulo (en unidades lógicas).

*RCA*<br/>
Especifica la coordenada x de la esquina inferior derecha del rectángulo (en unidades lógicas).

*a2*<br/>
Especifica la coordenada y de la esquina inferior derecha del rectángulo (en unidades lógicas).

*X3*<br/>
Especifica el ancho de la elipse utilizada para dibujar las esquinas redondeadas (en unidades lógicas).

*Single*<br/>
Especifica el alto de la elipse utilizada para dibujar las esquinas redondeadas (en unidades lógicas).

*lpRect*<br/>
Especifica el rectángulo delimitador en unidades lógicas. Puede pasar un objeto de `CRect` o un puntero a una estructura de `RECT` para este parámetro.

*Elija*<br/>
La coordenada x de *Point* especifica el ancho de la elipse para dibujar las esquinas redondeadas (en unidades lógicas). La coordenada y de *Point* especifica el alto de la elipse para dibujar las esquinas redondeadas (en unidades lógicas). Puede pasar una estructura `POINT` o un objeto `CPoint` para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El interior del rectángulo se rellena con el pincel actual.

La figura que dibuja esta función extiende hasta pero no incluye las coordenadas derecha e inferior. Esto significa que el alto de la figura es *y2* - *Y1* y el ancho de la ilustración es *x2* - *x1*. Tanto el alto como el ancho del rectángulo delimitador deben ser mayores de 2 unidades y menos de 32.767 unidades.

### <a name="example"></a>Ejemplo

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

##  <a name="savedc"></a>CDC:: SaveDC

Guarda el estado actual del contexto del dispositivo mediante la copia de la información de estado (por ejemplo, la región de recorte, los objetos seleccionados y el modo de asignación) en una pila de contexto mantenida por Windows.

```
virtual int SaveDC();
```

### <a name="return-value"></a>Valor devuelto

Entero que identifica el contexto de dispositivo guardado. Es 0 si se produce un error. Este valor devuelto se puede usar para restaurar el contexto de dispositivo mediante una llamada a `RestoreDC`.

### <a name="remarks"></a>Observaciones

El contexto de dispositivo guardado se puede restaurar posteriormente mediante `RestoreDC`.

`SaveDC` se puede usar cualquier número de veces para guardar cualquier número de Estados de contexto del dispositivo.

##  <a name="scaleviewportext"></a>CDC:: ScaleViewportExt

Modifica las extensiones de la ventanilla en relación con los valores actuales.

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parámetros

*xNum*<br/>
Especifica la cantidad por la que se va a multiplicar la extensión x actual.

*xDenom*<br/>
Especifica la cantidad por la que se divide el resultado de multiplicar la extensión x actual por el valor del parámetro *xNum* .

*yNum*<br/>
Especifica la cantidad por la que se va a multiplicar la extensión y actual.

*yDenom*<br/>
Especifica la cantidad por la que se divide el resultado de multiplicar la extensión y actual por el valor del parámetro *yNum* .

### <a name="return-value"></a>Valor devuelto

Extensiones de la ventanilla anterior (en unidades de dispositivo) como un objeto `CSize`.

### <a name="remarks"></a>Observaciones

Las fórmulas se escriben de la siguiente manera:

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

Las nuevas extensiones de la ventanilla se calculan multiplicando las extensiones actuales por el numerador dado y dividiendo el denominador dado.

##  <a name="scalewindowext"></a>CDC:: ScaleWindowExt

Modifica las extensiones de la ventana con respecto a los valores actuales.

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parámetros

*xNum*<br/>
Especifica la cantidad por la que se va a multiplicar la extensión x actual.

*xDenom*<br/>
Especifica la cantidad por la que se divide el resultado de multiplicar la extensión x actual por el valor del parámetro *xNum* .

*yNum*<br/>
Especifica la cantidad por la que se va a multiplicar la extensión y actual.

*yDenom*<br/>
Especifica la cantidad por la que se divide el resultado de multiplicar la extensión y actual por el valor del parámetro *yNum* .

### <a name="return-value"></a>Valor devuelto

Extensiones de ventana anteriores (en unidades lógicas) como un objeto `CSize`.

### <a name="remarks"></a>Observaciones

Las fórmulas se escriben de la siguiente manera:

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

Las nuevas extensiones de ventana se calculan multiplicando las extensiones actuales por el numerador dado y dividiendo el denominador dado.

##  <a name="scrolldc"></a>CDC:: ScrollDC

Desplaza un rectángulo de bits horizontal y verticalmente.

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>Parámetros

*DX*<br/>
Especifica el número de unidades de desplazamiento horizontal.

*DY*<br/>
Especifica el número de unidades de desplazamiento verticales.

*lpRectScroll*<br/>
Apunta a la estructura `RECT` o `CRect` objeto que contiene las coordenadas del rectángulo de desplazamiento.

*lpRectClip*<br/>
Apunta a la estructura `RECT` o `CRect` objeto que contiene las coordenadas del rectángulo de recorte. Cuando este rectángulo es más pequeño que el original al que apunta *lpRectScroll*, el desplazamiento solo se produce en el rectángulo más pequeño.

*pRgnUpdate*<br/>
Identifica la región descubierta por el proceso de desplazamiento. La función `ScrollDC` define esta región; no es necesariamente un rectángulo.

*lpRectUpdate*<br/>
Apunta a la estructura `RECT` o `CRect` objeto que recibe las coordenadas del rectángulo que delimita la región de actualización desplazada. Este es el área rectangular más grande que requiere volver a pintar. Los valores de la estructura o el objeto cuando la función devuelve se encuentran en coordenadas de cliente, independientemente del modo de asignación para el contexto de dispositivo determinado.

### <a name="return-value"></a>Valor devuelto

Distinto de cero si se ejecuta el desplazamiento. de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Si *lpRectUpdate* es null, Windows no calcula el rectángulo de actualización. Si *pRgnUpdate* y *lpRectUpdate* son NULL, Windows no calcula la región de actualización. Si *pRgnUpdate* no es null, Windows supone que contiene un puntero válido a la región descubierta por el proceso de desplazamiento (definido por la función miembro `ScrollDC`). La región de actualización devuelta en *lpRectUpdate* se puede pasar a `CWnd::InvalidateRgn` si es necesario.

Una aplicación debe usar la función miembro `ScrollWindow` de la clase `CWnd` cuando sea necesario desplazarse por todo el área cliente de una ventana. De lo contrario, debe usar `ScrollDC`.

##  <a name="selectclippath"></a>CDC:: SelectClipPath

Selecciona la ruta de acceso actual como una región de recorte para el contexto de dispositivo, combinando la nueva región con cualquier región de recorte existente mediante el modo especificado.

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>Parámetros

*nMode*<br/>
Especifica la manera de usar la ruta de acceso. Se admiten los valores siguientes:

- RGN_AND la nueva región de recorte incluye la intersección (áreas superpuestas) de la región de recorte actual y la ruta de acceso actual.

- RGN_COPY la nueva región de recorte es la ruta de acceso actual.

- RGN_DIFF la nueva región de recorte incluye las áreas de la región de recorte actual y las de la ruta de acceso actual se excluyen.

- RGN_OR la nueva región de recorte incluye la Unión (áreas combinadas) de la región de recorte actual y la ruta de acceso actual.

- RGN_XOR la nueva región de recorte incluye la Unión de la región de recorte actual y la ruta de acceso actual, pero sin las áreas superpuestas.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El contexto de dispositivo identificado debe contener una ruta de acceso cerrada.

##  <a name="selectcliprgn"></a>CDC:: SelectClipRgn

Selecciona la región determinada como la región de recorte actual para el contexto del dispositivo.

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>Parámetros

*pRgn*<br/>
Identifica la región que se va a seleccionar.

- En la primera versión de esta función, si este valor es NULL, se selecciona todo el área cliente y la salida se sigue recortando en la ventana.

- Para la segunda versión de esta función, este identificador puede ser NULL solo cuando se especifica el modo de RGN_COPY.

*nMode*<br/>
Especifica la operación que se va a realizar. Debe ser uno de los siguientes valores:

- RGN_AND la nueva región de recorte combina las áreas superpuestas de la región de recorte actual y la región identificada por *pRgn*.

- RGN_COPY la nueva región de recorte es una copia de la región identificada por *pRgn*. Esta funcionalidad es idéntica a la primera versión de `SelectClipRgn`. Si la región identificada por *pRgn* es null, la nueva región de recorte se convierte en la región de recorte predeterminada (una región nula).

- RGN_DIFF la nueva región de recorte combina las áreas de la región de recorte actual con las áreas excluidas de la región identificada por *pRgn*.

- RGN_OR la nueva región de recorte combina la región de recorte actual y la región identificada por *pRgn*.

- RGN_XOR la nueva región de recorte combina la región de recorte actual y la región identificada por *pRgn* , pero excluye las áreas superpuestas.

### <a name="return-value"></a>Valor devuelto

Tipo de la región. Puede ser cualquiera de los siguientes valores:

- COMPLEXREGION nueva región de recorte tiene bordes superpuestos.

- El contexto o la región del dispositivo de ERROR no es válido.

- NULLREGION nueva región de recorte está vacía.

- SIMPLEREGION nueva región de recorte no tiene bordes superpuestos.

### <a name="remarks"></a>Observaciones

Solo se usa una copia de la región seleccionada. La propia región se puede seleccionar para cualquier número de otros contextos de dispositivo o se puede eliminar.

La función supone que las coordenadas de la región determinada se especifican en unidades de dispositivo. Algunos dispositivos de impresora admiten la salida de texto en una resolución más alta que la salida de gráficos para conservar la precisión necesaria para expresar las métricas de texto. Estos dispositivos informan de unidades de dispositivo con la resolución más alta, es decir, en unidades de texto. Después, estos dispositivos escalan las coordenadas de los gráficos para que varias unidades de dispositivo informadas se asignen solo a 1 unidad gráfica. Siempre debe llamar a la función `SelectClipRgn` mediante unidades de texto.

Las aplicaciones que deben tomar el escalado de objetos gráficos en el GDI pueden usar el escape de impresora GETSCALINGFACTOR para determinar el factor de escala. Este factor de escala afecta al recorte. Si se usa una región para recortar gráficos, GDI divide las coordenadas por el factor de escala. Si la región se usa para recortar el texto, GDI no realiza ningún ajuste de escala. Un factor de escala de 1 hace que las coordenadas se divida en 2; un factor de escala de 2 hace que las coordenadas se divida en 4; etc.

##  <a name="selectobject"></a>CDC:: SelectObject

Selecciona un objeto en el contexto del dispositivo.

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>Parámetros

*pPen*<br/>
Un puntero a un objeto [CPen (](../../mfc/reference/cpen-class.md) que se va a seleccionar.

*pBrush*<br/>
Un puntero a un objeto [CBrush (](../../mfc/reference/cbrush-class.md) que se va a seleccionar.

*pFont*<br/>
Un puntero a un objeto [Cfont (](../../mfc/reference/cfont-class.md) que se va a seleccionar.

*pBitmap*<br/>
Un puntero a un objeto [CBitmap](../../mfc/reference/cbitmap-class.md) que se va a seleccionar.

*pRgn*<br/>
Un puntero a un objeto [crgn (](../../mfc/reference/crgn-class.md) que se va a seleccionar.

*pObject*<br/>
Un puntero a un objeto [CGdiObject](../../mfc/reference/cgdiobject-class.md) que se va a seleccionar.

### <a name="return-value"></a>Valor devuelto

Puntero al objeto que se va a reemplazar. Es un puntero a un objeto de una de las clases derivadas de `CGdiObject`, como `CPen`, en función de la versión de la función que se utilice. El valor devuelto es NULL si se produce un error. Esta función puede devolver un puntero a un objeto temporal. Este objeto temporal solo es válido durante el procesamiento de un mensaje de Windows. Para más información, consulte `CGdiObject::FromHandle`.

La versión de la función miembro que toma un parámetro region realiza la misma tarea que la `SelectClipRgn` función miembro. Su valor devuelto puede ser cualquiera de los siguientes:

- COMPLEXREGION nueva región de recorte tiene bordes superpuestos.

- El contexto o la región del dispositivo de ERROR no es válido.

- NULLREGION nueva región de recorte está vacía.

- SIMPLEREGION nueva región de recorte no tiene bordes superpuestos.

### <a name="remarks"></a>Observaciones

La clase `CDC` proporciona cinco versiones especializadas para determinados tipos de objetos GDI, como lápices, pinceles, fuentes, mapas de bits y regiones. El objeto recién seleccionado reemplaza el objeto anterior del mismo tipo. Por ejemplo, si *pObject* de la versión general de `SelectObject` apunta a un objeto [CPen (](../../mfc/reference/cpen-class.md) , la función reemplaza el lápiz actual por el lápiz especificado por *pObject*.

Una aplicación puede seleccionar un mapa de bits en contextos de dispositivo de memoria únicamente y solo en un contexto de dispositivo de memoria cada vez. El formato del mapa de bits debe ser monocromo o compatible con el contexto del dispositivo. Si no es así, `SelectObject` devuelve un error.

En Windows 3,1 y versiones posteriores, la función `SelectObject` devuelve el mismo valor tanto si se usa en un metarchivo como si no. En versiones anteriores de Windows, `SelectObject` devolvía un valor distinto de cero para Success y 0 en caso de error cuando se usaba en un metarchivo.

##  <a name="selectpalette"></a>CDC:: SelectPalette

Selecciona la paleta lógica especificada por *pPalette* como el objeto de paleta seleccionado del contexto del dispositivo.

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>Parámetros

*pPalette*<br/>
Identifica la paleta lógica que se va a seleccionar. Esta paleta ya se debe haber creado con la `CPalette` función miembro [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette).

*bForceBackground*<br/>
Especifica si la paleta lógica está forzada a ser una paleta de fondo. Si *bForceBackground* es distinto de cero, la paleta seleccionada siempre es una paleta de fondo, independientemente de si la ventana tiene el foco de entrada. Si *bForceBackground* es 0 y el contexto del dispositivo se adjunta a una ventana, la paleta lógica es una paleta de primer plano cuando la ventana tiene el foco de entrada.

### <a name="return-value"></a>Valor devuelto

Un puntero a un objeto `CPalette` que identifica la paleta lógica reemplazada por la paleta especificada por *pPalette*. Es NULL si se produce un error.

### <a name="remarks"></a>Observaciones

La nueva paleta se convierte en el objeto de paleta utilizado por GDI para controlar los colores mostrados en el contexto del dispositivo y reemplaza la paleta anterior.

Una aplicación puede seleccionar una paleta lógica en más de un contexto de dispositivo. Sin embargo, los cambios en una paleta lógica afectarán a todos los contextos de dispositivo para los que está seleccionado. Si una aplicación selecciona una paleta en más de un contexto de dispositivo, todos los contextos de dispositivo deben pertenecer al mismo dispositivo físico.

##  <a name="selectstockobject"></a>CDC:: SelectStockObject

Selecciona un objeto [CGdiObject](../../mfc/reference/cgdiobject-class.md) que corresponde a uno de los lápices, pinceles o fuentes predefinidos.

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>Parámetros

*nIndex*<br/>
Especifica el tipo de objeto estándar deseado. Puede ser uno de los siguientes valores:

- BLACK_BRUSH pincel negro.

- DKGRAY_BRUSH pincel gris oscuro.

- GRAY_BRUSH pincel gris.

- HOLLOW_BRUSH pincel hueco.

- LTGRAY_BRUSH pincel gris claro.

- NULL_BRUSH pincel nulo.

- WHITE_BRUSH pincel blanco.

- BLACK_PEN lápiz negro.

- NULL_PEN lápiz nulo.

- WHITE_PEN lápiz blanco.

- ANSI_FIXED_FONT fuente de sistema fijo ANSI.

- ANSI_VAR_FONT fuente del sistema de variables ANSI.

- DEVICE_DEFAULT_FONT fuente dependiente del dispositivo.

- OEM_FIXED_FONT fuente fija dependiente del OEM.

- SYSTEM_FONT la fuente del sistema. De forma predeterminada, Windows usa la fuente del sistema para dibujar menús, controles de cuadro de diálogo y otro texto. Sin embargo, es mejor no confiar en SYSTEM_FONT para obtener la fuente utilizada por los cuadros de diálogo y las ventanas. En su lugar, use la función `SystemParametersInfo` con el parámetro SPI_GETNONCLIENTMETRICS para recuperar la fuente actual. `SystemParametersInfo` tiene en cuenta el tema actual y proporciona información de fuente para los títulos, menús y cuadros de diálogo de mensaje.

- SYSTEM_FIXED_FONT la fuente del sistema de ancho fijo utilizada en Windows anterior a la versión 3,0. Este objeto está disponible para ofrecer compatibilidad con versiones anteriores de Windows.

- DEFAULT_PALETTE paleta de colores predeterminada. Esta paleta se compone de los 20 colores estáticos de la paleta del sistema.

### <a name="return-value"></a>Valor devuelto

Puntero al objeto de `CGdiObject` que se reemplazó si la función se realiza correctamente. El objeto real al que se apunta es un objeto [CPen (](../../mfc/reference/cpen-class.md), [CBrush (](../../mfc/reference/cbrush-class.md)o [Cfont (](../../mfc/reference/cfont-class.md) . Si la llamada no se realiza correctamente, el valor devuelto es NULL.

##  <a name="setabortproc"></a>CDC:: SetAbortProc

Instala el procedimiento de anulación para el trabajo de impresión.

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>Parámetros

*lpfn*<br/>
Puntero a la función Abort que se va a instalar como procedimiento de anulación. Para obtener más información sobre la función de devolución de llamada, vea [función de devolución de llamada para CDC:: SetAbortProc](callback-functions-used-by-mfc.md#setabortproc).

### <a name="return-value"></a>Valor devuelto

Especifica el resultado de la función `SetAbortProc`. Algunos de los valores siguientes son más probables que otros, pero todos son posibles.

- SP_ERROR error general.

- SP_OUTOFDISK espacio en disco insuficiente actualmente está disponible para la puesta en cola y no habrá más espacio disponible.

- SP_OUTOFMEMORY no hay suficiente memoria disponible para la puesta en cola.

- SP_USERABORT usuario finalizó el trabajo a través del administrador de impresión.

### <a name="remarks"></a>Observaciones

Si una aplicación va a permitir que se cancele el trabajo de impresión durante la puesta en cola, debe establecer la función de anulación antes de que se inicie el trabajo de impresión con la función miembro [StartDoc](#startdoc) . El administrador de impresión llama a la función Abort durante la puesta en cola para permitir que la aplicación cancele el trabajo de impresión o procese condiciones de espacio insuficiente en disco. Si no se establece ninguna función de anulación, se producirá un error en el trabajo de impresión si no hay suficiente espacio en disco para la puesta en cola.

Tenga en cuenta que las características de C++ Microsoft Visual simplifican la creación de la función de devolución de llamada que se pasa a `SetAbortProc`. La dirección que se pasa a la función miembro `EnumObjects` es un puntero a una función exportada con `__declspec(dllexport)` y con la Convención de llamada de `__stdcall`.

Tampoco tiene que exportar el nombre de la función en una instrucción **Exports** en el archivo de definición de módulo de la aplicación. En su lugar, puede usar el modificador de función **Export** , como en

**exportación de devolución de llamada bool** AFunction ( **HDC**, `int` **);**

para hacer que el compilador emita el registro de exportación adecuado para exportar por nombre sin alias. Esto funciona con la mayoría de las necesidades. En algunos casos especiales, como la exportación de una función por ordinal o el suavizado de la exportación, todavía es necesario usar una instrucción **Exports** en un archivo de definición de módulo.

Las interfaces de registro de devolución de llamada ahora tienen seguridad de tipos (debe pasar un puntero de función que apunte al tipo correcto de función para la devolución de llamada específica).

Tenga en cuenta también que todas las funciones de devolución de llamada deben interceptar las excepciones de Microsoft Foundation antes de volver a Windows, ya que no se pueden iniciar excepciones en los límites de devolución de llamada. Para obtener más información sobre las excepciones, vea el artículo [excepciones](../../mfc/exception-handling-in-mfc.md).

##  <a name="setarcdirection"></a>CDC:: SetArcDirection

Establece la dirección de dibujo que se va a utilizar para las funciones de arco y rectángulo.

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>Parámetros

*nArcDirection*<br/>
Especifica la nueva dirección del arco. Este parámetro puede ser cualquiera de los valores siguientes:

- AD_COUNTERCLOCKWISE figuras dibujadas en sentido contrario a las agujas del reloj.

- AD_CLOCKWISE figuras dibujadas a la derecha.

### <a name="return-value"></a>Valor devuelto

Especifica la dirección del arco anterior, si se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La dirección predeterminada es en sentido contrario a las agujas del reloj. La función `SetArcDirection` especifica la dirección en la que se dibujan las siguientes funciones:

|Vería|Circular|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

##  <a name="setattribdc"></a>CDC:: SetAttribDC

Llame a esta función para establecer el contexto de dispositivo de atributo, `m_hAttribDC`.

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>Parámetros

*Cámaras*<br/>
Un contexto de dispositivo de Windows.

### <a name="remarks"></a>Observaciones

Esta función miembro no adjunta el contexto de dispositivo al objeto de `CDC`. Solo el contexto de dispositivo de salida se adjunta a un objeto de `CDC`.

##  <a name="setbkcolor"></a>CDC:: SetBkColor

Establece el color de fondo actual en el color especificado.

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>Parámetros

*crColor*<br/>
Especifica el nuevo color de fondo.

### <a name="return-value"></a>Valor devuelto

El color de fondo anterior como valor de color RGB. Si se produce un error, el valor devuelto es 0x80000000.

### <a name="remarks"></a>Observaciones

Si el modo de fondo es opaco, el sistema utiliza el color de fondo para rellenar los huecos de las líneas con estilo, los espacios entre las líneas sombreadas de los pinceles y el fondo de las celdas de caracteres. El sistema también usa el color de fondo al convertir los mapas de bits entre los contextos de dispositivo de color y monocromo.

Si el dispositivo no puede mostrar el color especificado, el sistema establece el color de fondo en el color físico más cercano.

##  <a name="setbkmode"></a>CDC:: SetBkMode

Establece el modo en segundo plano.

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>Parámetros

*nBkMode*<br/>
Especifica el modo que se va a establecer. Este parámetro puede ser cualquiera de los valores siguientes:

- El fondo opaco se rellena con el color de fondo actual antes de que se dibuje el texto, el pincel sombreado o el lápiz. Este es el modo de fondo predeterminado.

- El fondo transparente no se cambia antes del dibujo.

### <a name="return-value"></a>Valor devuelto

El modo en segundo plano anterior.

### <a name="remarks"></a>Observaciones

El modo en segundo plano define si el sistema quita los colores de fondo existentes en la superficie de dibujo antes de dibujar el texto, los pinceles sombreados o cualquier estilo de pluma que no sea una línea sólida.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CWnd:: OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

##  <a name="setboundsrect"></a>CDC:: SetBoundsRect

Controla la acumulación de información del rectángulo delimitador para el contexto de dispositivo especificado.

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parámetros

*lpRectBounds*<br/>
Apunta a una estructura de `RECT` o `CRect` objeto que se usa para establecer el rectángulo delimitador. Las dimensiones de rectángulo se proporcionan en coordenadas lógicas. Este parámetro puede ser NULL.

*flags*<br/>
Especifica cómo se combinará el nuevo rectángulo con el rectángulo acumulado. Este parámetro puede ser una combinación de los siguientes valores:

- DCB_ACCUMULATE agregar el rectángulo especificado por *lpRectBounds* al rectángulo delimitador (mediante una operación de unión de rectángulo).

- DCB_DISABLE desactivar la acumulación de límites.

- DCB_ENABLE activar la acumulación de límites. (La configuración predeterminada para la acumulación de límites está deshabilitada).

### <a name="return-value"></a>Valor devuelto

Estado actual del rectángulo delimitador, si la función se realiza correctamente. Al igual que las *marcas*, el valor devuelto puede ser una combinación de valores **DCB_** :

- DCB_ACCUMULATE el rectángulo delimitador no está vacío. Siempre se establecerá este valor.

- DCB_DISABLE acumulación de límites está desactivada.

- DCB_ENABLE acumulación de límites está activada.

### <a name="remarks"></a>Observaciones

Windows puede mantener un rectángulo delimitador para todas las operaciones de dibujo. La aplicación puede consultar y restablecer este rectángulo. Los límites de dibujo son útiles para invalidar memorias caché de mapa de bits.

##  <a name="setbrushorg"></a>CDC:: SetBrushOrg

Especifica el origen que GDI asignará al siguiente pincel que la aplicación selecciona en el contexto del dispositivo.

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x (en unidades de dispositivo) del nuevo origen. Este valor debe estar en el intervalo 0-7.

*y*<br/>
Especifica la coordenada y (en unidades de dispositivo) del nuevo origen. Este valor debe estar en el intervalo 0-7.

*Elija*<br/>
Especifica las coordenadas x e y del nuevo origen. Cada valor debe estar en el intervalo de 0-7. Puede pasar una estructura `POINT` o un objeto `CPoint` para este parámetro.

### <a name="return-value"></a>Valor devuelto

El origen anterior del pincel en unidades de dispositivo.

### <a name="remarks"></a>Observaciones

Las coordenadas predeterminadas para el origen del pincel son (0,0). Para modificar el origen de un pincel, llame a la función `UnrealizeObject` para el objeto `CBrush`, llame a `SetBrushOrg`y, a continuación, llame a la función miembro `SelectObject` para seleccionar el pincel en el contexto del dispositivo.

No utilice `SetBrushOrg` con objetos de `CBrush` de existencias.

##  <a name="setcoloradjustment"></a>CDC:: SetColorAdjustment

Establece los valores de ajuste de color para el contexto de dispositivo usando los valores especificados.

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>Parámetros

*lpColorAdjust*<br/>
Apunta a una estructura de datos [coloradjustment (](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) que contiene los valores de ajuste de color.

### <a name="return-value"></a>Valor devuelto

Si es correcta, su valor es distinto de cero. En caso contrario, es cero.

### <a name="remarks"></a>Observaciones

Los valores de ajuste de color se utilizan para ajustar el color de entrada del mapa de bits de origen para las llamadas a la función miembro `CDC::StretchBlt` cuando se establece el modo de SEMITONO.

##  <a name="setdcbrushcolor"></a>CDC:: SetDCBrushColor

Establece el color del pincel de contexto de dispositivo (DC) actual en el valor de color especificado.

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>Parámetros

*crColor*<br/>
Especifica el nuevo color del pincel.

### <a name="return-value"></a>Valor devuelto

Si la función se ejecuta correctamente, el valor devuelto especifica el color del pincel del controlador de dominio anterior como valor de COLORREF.

Si la función no se realiza correctamente, el valor devuelto es CLR_INVALID.

### <a name="remarks"></a>Observaciones

Este método emula la funcionalidad de la función [SetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-setdcbrushcolor), tal y como se describe en el Windows SDK.

##  <a name="setdcpencolor"></a>CDC:: SetDCPenColor

Establece el color del lápiz de contexto de dispositivo (DC) actual en el valor de color especificado.

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>Parámetros

*crColor*<br/>
Especifica el nuevo color de la pluma.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función miembro emplea la función [SetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-setdcpencolor)de Win32, tal como se describe en el Windows SDK.

##  <a name="setgraphicsmode"></a>CDC:: SetGraphicsMode

Establece el modo de gráficos para el contexto de dispositivo especificado.

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>Parámetros

*iMode*<br/>
Especifica el modo de gráficos. Para obtener una lista de los valores que puede tomar este parámetro, vea [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

### <a name="return-value"></a>Valor devuelto

Devuelve el modo de gráficos anterior en caso de éxito.

Devuelve 0 en caso de error. Para obtener información de error extendida, llame a [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Observaciones

Este método ajusta la función GDI de Windows [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

##  <a name="setlayout"></a>CDC:: SetLayout

Llame a esta función miembro para cambiar el diseño del texto y los gráficos de un contexto de dispositivo de derecha a izquierda, el diseño estándar para las referencias culturales como el árabe y el hebreo.

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>Parámetros

*dwLayout*<br/>
Diseño del contexto de dispositivo y marcas de control de mapa de bits. Puede ser una combinación de los valores siguientes.

|Value|Significado|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|Deshabilita cualquier reflexión para las llamadas a [CDC:: bitblt](#bitblt) y [CDC:: StretchBlt](#stretchblt).|
|LAYOUT_RTL|Establece el diseño horizontal predeterminado de derecha a izquierda.|
|LAYOUT_LTR|Establece el diseño predeterminado de izquierda a derecha.|

### <a name="return-value"></a>Valor devuelto

Si es correcto, el diseño anterior del contexto del dispositivo.

Si no se realiza correctamente, GDI_ERROR. Para obtener información de error extendida, llame a [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Observaciones

Normalmente, no llamaría a `SetLayout` para una ventana. En su lugar, puede controlar el diseño de derecha a izquierda en una ventana estableciendo los [estilos extendidos](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) de la ventana, como WS_EX_RTLREADING. Un contexto de dispositivo, como una impresora o un metarchivo, no hereda este diseño. La única manera de establecer el contexto de dispositivo para un diseño de derecha a izquierda es mediante una llamada a `SetLayout`.

Si llama a **SetLayout (LAYOUT_RTL** ), `SetLayout` cambia automáticamente el modo de asignación a MM_ISOTROPIC. Como resultado, una llamada subsiguiente a [GetMapMode](#getmapmode) devolverá MM_ISOTROPIC en lugar de MM_TEXT.

En algunos casos, como con muchos mapas de bits, puede que desee conservar el diseño de izquierda a derecha. En estos casos, represente la imagen llamando `BitBlt` o `StretchBlt`y, a continuación, establezca la marca de control de mapa de bits para *dwLayout* en LAYOUT_BITMAPORIENTATIONPRESERVED.

Una vez que se cambia el diseño con la marca LAYOUT_RTL, se invierten las marcas que especifican normalmente a la derecha o a la izquierda. Para evitar confusiones, puede que desee definir nombres alternativos para las marcas estándar. Para obtener una lista de nombres de marcas alternativas sugeridas, consulte [SetLayout](/windows/win32/api/wingdi/nf-wingdi-setlayout) en el Windows SDK.

##  <a name="setmapmode"></a>CDC:: SetMapMode

Establece el modo de asignación.

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>Parámetros

*nMapMode*<br/>
Especifica el nuevo modo de asignación. Puede ser cualquiera de los siguientes valores:

- MM_ANISOTROPIC unidades lógicas se convierten en unidades arbitrarias con ejes escalados de forma arbitraria. Establecer el modo de asignación en MM_ANISOTROPIC no cambia la configuración actual de la ventana o la ventanilla. Para cambiar las unidades, la orientación y el escalado, llame a las funciones miembro [SetWindowExt](#setwindowext) y [SetViewportExt](#setviewportext) .

- MM_HIENGLISH cada unidad lógica se convierte en 0,001 pulgadas. La x positiva es hacia la derecha; el y positivo es up.

- MM_HIMETRIC cada unidad lógica se convierte en 0,01 milímetros. La x positiva es hacia la derecha; el y positivo es up.

- MM_ISOTROPIC unidades lógicas se convierten en unidades arbitrarias con ejes igualmente escalados; es decir, 1 unidad a lo largo del eje x es igual a 1 unidad a lo largo del eje y. Use las funciones miembro `SetWindowExt` y `SetViewportExt` para especificar las unidades deseadas y la orientación de los ejes. GDI realiza ajustes según sea necesario para asegurarse de que las unidades x e y tienen el mismo tamaño.

- MM_LOENGLISH cada unidad lógica se convierte en 0,01 pulgadas. La x positiva es hacia la derecha; el y positivo es up.

- MM_LOMETRIC cada unidad lógica se convierte en 0,1 milímetros. La x positiva es hacia la derecha; el y positivo es up.

- MM_TEXT cada unidad lógica se convierte en un píxel de dispositivo. La x positiva es hacia la derecha; la y positiva está inactiva.

- MM_TWIPS cada unidad lógica se convierte en 1/20 de un punto. (Dado que un punto es 1/72 pulgada, una twip es de 1/1440 pulgadas). La x positiva es hacia la derecha; el y positivo es up.

### <a name="return-value"></a>Valor devuelto

Modo de asignación anterior.

### <a name="remarks"></a>Observaciones

El modo de asignación define la unidad de medida utilizada para convertir unidades lógicas en unidades de dispositivo. también define la orientación de los ejes x e y del dispositivo. GDI usa el modo de asignación para convertir las coordenadas lógicas en las coordenadas de dispositivo adecuadas. El modo de MM_TEXT permite que las aplicaciones funcionen en píxeles del dispositivo, donde 1 unidad es igual a 1 píxel. El tamaño físico de un píxel varía según el dispositivo y el dispositivo.

Los modos MM_HIENGLISH, MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC y MM_TWIPS son útiles para las aplicaciones que deben dibujar en unidades físicamente significativas (como pulgadas o milímetros). El modo de MM_ISOTROPIC garantiza una relación de aspecto 1:1, lo que resulta útil cuando es importante conservar la forma exacta de una imagen. El modo de MM_ANISOTROPIC permite ajustar las coordenadas x e y de forma independiente.

> [!NOTE]
>  Si llama a [SetLayout](#setlayout) para cambiar el controlador de dominio (contexto de dispositivo) al diseño de derecha a izquierda, `SetLayout` cambia automáticamente el modo de asignación a MM_ISOTROPIC.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CView:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setmapperflags"></a>CDC:: SetMapperFlags

Cambia el método utilizado por el asignador de fuentes cuando convierte una fuente lógica en una fuente física.

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>Parámetros

*dwFlag*<br/>
Especifica si el asignador de fuentes intenta hacer coincidir el alto y el ancho de aspecto de una fuente con el dispositivo. Cuando se ASPECT_FILTERING este valor, el asignador selecciona solo las fuentes cuyos aspectos x e y coinciden exactamente con los del dispositivo especificado.

### <a name="return-value"></a>Valor devuelto

Valor anterior de la marca de asignador de fuentes.

### <a name="remarks"></a>Observaciones

Una aplicación puede utilizar `SetMapperFlags` para hacer que el asignador de fuentes intente elegir solo una fuente física que coincida exactamente con la relación de aspecto del dispositivo especificado.

Una aplicación que usa únicamente fuentes de tramas puede utilizar la función `SetMapperFlags` para asegurarse de que la fuente seleccionada por el asignador de fuentes es atractiva y legible en el dispositivo especificado. Las aplicaciones que usan Fuentes escalables (TrueType) no usan normalmente `SetMapperFlags`.

Si ninguna fuente física tiene una relación de aspecto que coincide con la especificación en la fuente lógica, GDI elige una nueva relación de aspecto y selecciona una fuente que coincida con esta nueva relación de aspecto.

##  <a name="setmiterlimit"></a>CDC:: SetMiterLimit

Establece el límite para la longitud de las combinaciones en ángulo para el contexto del dispositivo.

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>Parámetros

*fMiterLimit*<br/>
Especifica el nuevo límite angular para el contexto del dispositivo.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La longitud del inglete se define como la distancia entre la intersección de los planos laterales de línea en el interior de la combinación y la intersección de los planos de línea en el exterior de la combinación. El límite angular es la proporción máxima permitida de la longitud del inglete en el ancho de línea. El límite angular predeterminado es 10,0.

##  <a name="setoutputdc"></a>CDC:: SetOutputDC

Llame a esta función miembro para establecer el contexto de dispositivo de salida, `m_hDC`.

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>Parámetros

*Cámaras*<br/>
Un contexto de dispositivo de Windows.

### <a name="remarks"></a>Observaciones

Solo se puede llamar a esta función miembro cuando no se ha adjuntado un contexto de dispositivo al objeto de `CDC`. Esta función miembro establece `m_hDC` pero no adjunta el contexto del dispositivo al objeto `CDC`.

##  <a name="setpixel"></a>CDC:: SetPixel

Establece el píxel en el punto especificado en la aproximación más cercana del color especificado por *crColor*.

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x lógica del punto que se va a establecer.

*y*<br/>
Especifica la coordenada y lógica del punto que se va a establecer.

*crColor*<br/>
Valor de COLORREF RGB que especifica el color usado para dibujar el punto. Vea [COLORREF](/windows/win32/gdi/colorref) en el Windows SDK para obtener una descripción de este valor.

*Elija*<br/>
Especifica las coordenadas lógicas x e y del punto que se va a establecer. Puede pasar una estructura `POINT` o un objeto `CPoint` para este parámetro.

### <a name="return-value"></a>Valor devuelto

Valor RGB para el color en el que se dibuja realmente el punto. Este valor puede ser diferente del especificado por *crColor* si se usa una aproximación de ese color. Si se produce un error en la función (si el punto está fuera de la región de recorte), el valor devuelto es-1.

### <a name="remarks"></a>Observaciones

El punto debe estar en la región de recorte. Si el punto no está en la región de recorte, la función no hace nada.

No todos los dispositivos admiten la función `SetPixel`. Para determinar si un dispositivo admite `SetPixel`, llame a la función miembro `GetDeviceCaps` con el índice RASTERCAPS y compruebe el valor devuelto para la marca RC_BITBLT.

##  <a name="setpixelv"></a>CDC:: SetPixelV

Establece el píxel en las coordenadas especificadas en la aproximación más cercana del color especificado.

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x, en unidades lógicas, del punto que se va a establecer.

*y*<br/>
Especifica la coordenada y, en unidades lógicas, del punto que se va a establecer.

*crColor*<br/>
Especifica el color que se va a usar para pintar el punto.

*Elija*<br/>
Especifica las coordenadas lógicas x e y del punto que se va a establecer. Puede pasar una estructura de datos de [punto](/windows/win32/api/windef/ns-windef-point) o un objeto [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) para este parámetro.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El punto debe estar en la región de recorte y en la parte visible de la superficie del dispositivo. No todos los dispositivos admiten la función miembro. Para obtener más información, vea la funcionalidad RC_BITBLT en la función miembro `CDC::GetDeviceCaps`. `SetPixelV` es más rápido que `SetPixel` porque no necesita devolver el valor de color del punto pintado realmente.

##  <a name="setpolyfillmode"></a>CDC:: SetPolyFillMode

Establece el modo de relleno de polígonos.

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>Parámetros

*nPolyFillMode*<br/>
Especifica el nuevo modo de relleno. Este valor puede ser alternativo o de bobinado. El modo predeterminado establecido en Windows es alternativo.

### <a name="return-value"></a>Valor devuelto

El modo de llenado anterior, si es correcto; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Cuando el modo de relleno de polígonos es alternativo, el sistema rellena el área entre los lados de los polígonos con número impar e par en cada línea de exploración. Es decir, el sistema rellena el área entre el primer y el segundo lado, entre el tercero y el cuarto, y así sucesivamente. Este modo es el valor predeterminado.

Cuando el modo de relleno de polígonos es bobinado, el sistema utiliza la dirección en la que se dibujó una figura para determinar si se debe rellenar un área. Cada segmento de línea de un polígono se dibuja en sentido de las agujas del reloj o en el sentido contrario a las agujas del reloj. Siempre que una línea imaginaria dibujada a partir de un área delimitada a la parte externa de una figura pasa a través de un segmento de línea en el sentido de las agujas del reloj, se incrementa el recuento. Cuando la línea pasa a través de un segmento de línea en sentido contrario a las agujas del reloj, se reduce el recuento. El área se rellena si el recuento es distinto de cero cuando la línea llega a la parte externa de la figura.

##  <a name="setrop2"></a>CDC:: SetROP2

Establece el modo de dibujo actual.

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>Parámetros

*nDrawMode*<br/>
Especifica el nuevo modo de dibujo. Puede ser cualquiera de los siguientes valores:

- R2_BLACK píxel siempre es negro.

- R2_WHITE píxel siempre es blanco.

- R2_NOP píxel permanece sin cambios.

- R2_NOT píxel es el inverso del color de la pantalla.

- R2_COPYPEN píxel es el color del lápiz.

- R2_NOTCOPYPEN píxel es el inverso del color de la pluma.

- R2_MERGEPENNOT píxel es una combinación del color del lápiz y el inverso del color de la pantalla (último píxel = (no píxel de la pantalla) o pluma).

- R2_MASKPENNOT píxel es una combinación de los colores comunes al lápiz y al inverso de la pantalla (píxel final = (no píxel de la pantalla) y lápiz).

- R2_MERGENOTPEN píxel es una combinación del color de la pantalla y el inverso del color del lápiz (píxel final = (no lápiz) o píxel de la pantalla).

- R2_MASKNOTPEN píxel es una combinación de los colores comunes a la pantalla y al inverso del lápiz (el píxel final = (no el lápiz) y el píxel de la pantalla).

- R2_MERGEPEN píxel es una combinación del color del lápiz y el color de la pantalla (píxel final = lápiz o píxel de la pantalla).

- R2_NOTMERGEPEN píxel es el inverso del color R2_MERGEPEN (píxel final = no (lápiz o píxel de la pantalla)).

- R2_MASKPEN píxel es una combinación de los colores comunes al lápiz y la pantalla (píxel final = lápiz y píxel de la pantalla).

- R2_NOTMASKPEN píxel es el inverso del color R2_MASKPEN (el píxel final = no (lápiz y pantalla)).

- R2_XORPEN píxel es una combinación de los colores que se encuentran en el lápiz o en la pantalla, pero no en los dos (píxel final = píxel XOR de la pantalla).

- R2_NOTXORPEN píxel es el inverso del color de la R2_XORPEN (el píxel final = no (lápiz de pantalla de lápiz XOR)).

### <a name="return-value"></a>Valor devuelto

Modo de dibujo anterior.

Puede ser cualquiera de los valores especificados en el Windows SDK.

### <a name="remarks"></a>Observaciones

El modo de dibujo especifica cómo se combinan los colores del lápiz y el interior de los objetos rellenos con el color que ya está en la superficie de la pantalla.

El modo de dibujo es solo para dispositivos rasterizados; no se aplica a los dispositivos vectoriales. Los modos de dibujo son códigos de operación de trama binaria binaria que representan todas las posibles combinaciones booleanas de dos variables, mediante los operadores binarios AND, OR y XOR (Exclusive OR) y la operación unaria.

##  <a name="setstretchbltmode"></a>CDC:: SetStretchBltMode

Establece el modo de ajuste de mapa de bits para la función miembro `StretchBlt`.

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>Parámetros

*nStretchMode*<br/>
Especifica el modo de ajuste. Puede ser cualquiera de los siguientes valores:

|Value|Descripción|
|-----------|-----------------|
|BLACKONWHITE|Realiza una operación AND booleana usando los valores de color de los píxeles eliminados y existentes. Si el mapa de bits es un mapa de bits monocromo, este modo conserva los píxeles negros a costa de los píxeles blancos.|
|COLORONCOLOR|Elimina los píxeles. Este modo elimina todas las líneas de píxeles eliminadas sin intentar conservar su información.|
|MEDIO|Asigna píxeles del rectángulo de origen en bloques de píxeles del rectángulo de destino. El color medio sobre el bloque de píxeles de destino aproxima el color de los píxeles de origen.|
||Después de establecer el modo de ajuste de SEMITONO, una aplicación debe llamar a la función [SetBrushOrgEx](/windows/win32/api/wingdi/nf-wingdi-setbrushorgex) de Win32 para establecer el origen del pincel. Si no lo hace, se produce un error de alineación del pincel.|
|STRETCH_ANDSCANS|**Windows 95/98**: igual que BLACKONWHITE|
|STRETCH_DELETESCANS|**Windows 95/98**: igual que COLORONCOLOR|
|STRETCH_HALFTONE|**Windows 95/98**: igual que el semitono.|
|STRETCH_ORSCANS|**Windows 95/98**: igual que WHITEONBLACK|
|WHITEONBLACK|Realiza una operación OR booleana usando los valores de color de los píxeles eliminados y existentes. Si el mapa de bits es un mapa de bits monocromo, este modo conserva los píxeles blancos a costa de los píxeles negros.|

### <a name="return-value"></a>Valor devuelto

Modo de ajuste anterior. Puede ser STRETCH_ANDSCANS, STRETCH_DELETESCANS o STRETCH_ORSCANS.

### <a name="remarks"></a>Observaciones

El modo de ajuste de mapa de bits define cómo se quita la información de los mapas de bits que se comprimen con la función.

Los modos BLACKONWHITE (STRETCH_ANDSCANS) y WHITEONBLACK (STRETCH_ORSCANS) se suelen usar para conservar los píxeles de primer plano en mapas de bits monocromáticos. El modo COLORONCOLOR (STRETCH_DELETESCANS) se usa normalmente para conservar el color en los mapas de bits de color.

El modo de SEMITONO requiere más procesamiento de la imagen de origen que los otros tres modos; es más lento que los demás, pero genera imágenes de mayor calidad. Tenga en cuenta también que se debe llamar a `SetBrushOrgEx` después de establecer el modo de SEMITONO para evitar la alineación incorrecta del pincel.

También pueden estar disponibles otros modos de ajuste en función de las capacidades del controlador de dispositivo.

##  <a name="settextalign"></a>CDC:: SetTextAlign

Establece las marcas de alineación de texto.

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>Parámetros

*nFlags*<br/>
Especifica las marcas de alineación de texto. Las marcas especifican la relación entre un punto y un rectángulo que delimita el texto. El punto puede ser la posición actual o las coordenadas especificadas por una función de salida de texto. El rectángulo que delimita el texto se define mediante las celdas de caracteres adyacentes en la cadena de texto. El parámetro *nFlags* puede ser una o varias marcas de las tres categorías siguientes. Elija solo una marca de cada categoría. La primera categoría afecta a la alineación del texto en la dirección x:

- TA_CENTER alinea el punto con el centro horizontal del rectángulo delimitador.

- TA_LEFT alinea el punto con el lado izquierdo del rectángulo delimitador. Esta es la configuración predeterminada.

- TA_RIGHT alinea el punto con el lado derecho del rectángulo delimitador.

La segunda categoría afecta a la alineación del texto en la dirección y:

- TA_BASELINE alinea el punto con la línea base de la fuente elegida.

- TA_BOTTOM alinea el punto con la parte inferior del rectángulo delimitador.

- TA_TOP alinea el punto con la parte superior del rectángulo delimitador. Esta es la configuración predeterminada.

La tercera categoría determina si la posición actual se actualiza cuando se escribe texto:

- TA_NOUPDATECP no actualiza la posición actual después de cada llamada a una función de salida de texto. Esta es la configuración predeterminada.

- TA_UPDATECP actualiza la posición x actual después de cada llamada a una función de salida de texto. La nueva posición se encuentra en el lado derecho del rectángulo delimitador del texto. Cuando se establece esta marca, se omiten las coordenadas especificadas en llamadas a la función miembro `TextOut`.

### <a name="return-value"></a>Valor devuelto

La configuración de alineación de texto anterior, si se realiza correctamente. El byte de orden inferior contiene la configuración horizontal y el byte de orden superior contiene el valor vertical; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Las funciones miembro `TextOut` y `ExtTextOut` usan estas marcas al colocar una cadena de texto en una pantalla o un dispositivo. Las marcas especifican la relación entre un punto específico y un rectángulo que delimita el texto. Las coordenadas de este punto se pasan como parámetros a la función miembro `TextOut`. El rectángulo que delimita el texto está formado por las celdas de caracteres adyacentes en la cadena de texto.

##  <a name="settextcharacterextra"></a>CDC:: SetTextCharacterExtra

Establece la cantidad de espaciado entre caracteres.

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>Parámetros

*nCharExtra*<br/>
Especifica la cantidad de espacio adicional (en unidades lógicas) que se va a agregar a cada carácter. Si el modo de asignación actual no es `MM_TEXT`, *nCharExtra* se transforma y redondea al píxel más cercano.

### <a name="return-value"></a>Valor devuelto

La cantidad del espaciado de intercaracteres anterior.

### <a name="remarks"></a>Observaciones

GDI agrega este espaciado a cada carácter, incluidos los caracteres de salto, cuando escribe una línea de texto en el contexto del dispositivo. El valor predeterminado para la cantidad de espaciado entre caracteres es 0.

##  <a name="settextcolor"></a>CDC:: SetTextColor

Establece el color del texto en el color especificado.

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>Parámetros

*crColor*<br/>
Especifica el color del texto como un valor de color RGB.

### <a name="return-value"></a>Valor devuelto

Valor RGB para el color del texto anterior.

### <a name="remarks"></a>Observaciones

El sistema usará este color de texto al escribir texto en este contexto de dispositivo y también al convertir los mapas de bits entre los contextos de dispositivo de color y monocromo.

Si el dispositivo no puede representar el color especificado, el sistema establece el color del texto en el color físico más cercano. El color de fondo de un carácter se especifica mediante las funciones miembro `SetBkColor` y `SetBkMode`.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CWnd:: OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

##  <a name="settextjustification"></a>CDC:: SetTextJustification

Agrega espacio a los caracteres de salto de una cadena.

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>Parámetros

*nBreakExtra*<br/>
Especifica el espacio adicional total que se va a agregar a la línea de texto (en unidades lógicas). Si no se `MM_TEXT`el modo de asignación actual, el valor proporcionado por este parámetro se convierte en el modo de asignación actual y se redondea a la unidad de dispositivo más cercana.

*nBreakCount*<br/>
Especifica el número de caracteres de salto en la línea.

### <a name="return-value"></a>Valor devuelto

Una si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Una aplicación puede utilizar las funciones miembro de `GetTextMetrics` para recuperar el carácter de salto de una fuente.

Una vez que se llama a la función miembro de `SetTextJustification`, una llamada a una función de salida de texto (como `TextOut`) distribuye el espacio adicional especificado uniformemente entre el número especificado de caracteres de salto. El carácter de salto suele ser el carácter de espacio (ASCII 32), pero puede estar definido por una fuente como algún otro carácter.

La función miembro `GetTextExtent` se utiliza normalmente con `SetTextJustification`. `GetTextExtent` calcula el ancho de una línea determinada antes de la alineación. Una aplicación puede determinar la cantidad de espacio que se va a especificar en el parámetro *nBreakExtra* restando el valor devuelto por `GetTextExtent` del ancho de la cadena después de la alineación.

La función `SetTextJustification` se puede utilizar para alinear una línea que contenga varias ejecuciones en distintas fuentes. En este caso, la línea se debe crear por etapas alineando y escribiendo cada ejecución por separado.

Dado que los errores de redondeo pueden producirse durante la alineación, el sistema mantiene un término de error en ejecución que define el error actual. Al alinear una línea que contiene varias ejecuciones, `GetTextExtent` usa automáticamente este término de error cuando calcula la extensión de la siguiente ejecución. Esto permite que la función de salida de texto mezcle el error en la nueva ejecución.

Una vez alineada cada línea, este término de error debe borrarse para evitar que se incorpore a la línea siguiente. El término se puede borrar llamando a `SetTextJustification` con *nBreakExtra* establecido en 0.

##  <a name="setviewportext"></a>CDC:: SetViewportExt

Establece las extensiones x e y de la ventanilla del contexto del dispositivo.

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>Parámetros

*serie*<br/>
Especifica la extensión x de la ventanilla (en unidades de dispositivo).

*CY*<br/>
Especifica la extensión y de la ventanilla (en unidades de dispositivo).

*size*<br/>
Especifica las extensiones x e y de la ventanilla (en unidades de dispositivo).

### <a name="return-value"></a>Valor devuelto

Las extensiones anteriores de la ventanilla como un objeto [CSize](../../atl-mfc-shared/reference/csize-class.md) . Cuando se produce un error, las coordenadas x e y del objeto `CSize` devuelto se establecen en 0.

### <a name="remarks"></a>Observaciones

La ventanilla, junto con la ventana de contexto del dispositivo, define el modo en que GDI asigna puntos en el sistema de coordenadas lógico a puntos en el sistema de coordenadas del dispositivo real. En otras palabras, definen cómo GDI convierte las coordenadas lógicas en coordenadas de dispositivo.

Cuando se establecen los siguientes modos de asignación, se omiten las llamadas a `SetWindowExt` y `SetViewportExt`:

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

Cuando se establece el modo de MM_ISOTROPIC, una aplicación debe llamar a la función miembro `SetWindowExt` antes de llamar a `SetViewportExt`.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CView:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setviewportorg"></a>CDC:: SetViewportOrg

Establece el origen de la ventanilla del contexto del dispositivo.

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x (en unidades de dispositivo) del origen de la ventanilla. El valor debe estar dentro del intervalo del sistema de coordenadas del dispositivo.

*y*<br/>
Especifica la coordenada y (en unidades de dispositivo) del origen de la ventanilla. El valor debe estar dentro del intervalo del sistema de coordenadas del dispositivo.

*Elija*<br/>
Especifica el origen de la ventanilla. Los valores deben estar dentro del intervalo del sistema de coordenadas del dispositivo. Puede pasar una estructura `POINT` o un objeto `CPoint` para este parámetro.

### <a name="return-value"></a>Valor devuelto

El origen anterior de la ventanilla (en coordenadas de dispositivo) como un objeto `CPoint`.

### <a name="remarks"></a>Observaciones

La ventanilla, junto con la ventana de contexto del dispositivo, define el modo en que GDI asigna puntos en el sistema de coordenadas lógico a puntos en el sistema de coordenadas del dispositivo real. En otras palabras, definen cómo GDI convierte las coordenadas lógicas en coordenadas de dispositivo.

El origen de la ventanilla marca el punto en el sistema de coordenadas del dispositivo al que GDI asigna el origen de la ventana, un punto en el sistema de coordenadas lógico especificado por la función miembro `SetWindowOrg`. GDI asigna todos los demás puntos siguiendo el mismo proceso necesario para asignar el origen de la ventana al origen de la ventanilla. Por ejemplo, todos los puntos de un círculo alrededor del punto en el origen de la ventana estarán en un círculo alrededor del punto en el origen de la ventanilla. De forma similar, todos los puntos de una línea que pasan a través del origen de la ventana estarán en una línea que pase por el origen de la ventanilla.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CView:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setwindowext"></a>CDC:: SetWindowExt

Establece las extensiones x e y de la ventana asociada al contexto del dispositivo.

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>Parámetros

*serie*<br/>
Especifica la extensión x (en unidades lógicas) de la ventana.

*CY*<br/>
Especifica la extensión y (en unidades lógicas) de la ventana.

*size*<br/>
Especifica las extensiones x e y (en unidades lógicas) de la ventana.

### <a name="return-value"></a>Valor devuelto

Extensiones anteriores de la ventana (en unidades lógicas) como un objeto `CSize`. Si se produce un error, las coordenadas x e y del objeto `CSize` devuelto se establecen en 0.

### <a name="remarks"></a>Observaciones

La ventana de, junto con la ventanilla de contexto de dispositivo, define la forma en que GDI asigna puntos en el sistema de coordenadas lógicos a puntos en el sistema de coordenadas del dispositivo.

Cuando se establecen los siguientes modos de asignación, se omiten las llamadas a las funciones `SetWindowExt` y `SetViewportExt`:

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

Cuando se establece el modo de MM_ISOTROPIC, una aplicación debe llamar a la función miembro `SetWindowExt` antes de llamar a `SetViewportExt`.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CView:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setwindoworg"></a>CDC:: SetWindowOrg

Establece el origen de la ventana del contexto del dispositivo.

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x lógica del nuevo origen de la ventana.

*y*<br/>
Especifica la coordenada y lógica del nuevo origen de la ventana.

*Elija*<br/>
Especifica las coordenadas lógicas del nuevo origen de la ventana. Puede pasar una estructura `POINT` o un objeto `CPoint` para este parámetro.

### <a name="return-value"></a>Valor devuelto

El origen anterior de la ventana como un objeto `CPoint`.

### <a name="remarks"></a>Observaciones

La ventana de, junto con la ventanilla de contexto de dispositivo, define la forma en que GDI asigna puntos en el sistema de coordenadas lógicos a puntos en el sistema de coordenadas del dispositivo.

El origen de la ventana marca el punto en el sistema de coordenadas lógico desde el que GDI asigna el origen de la ventanilla, un punto en el sistema de coordenadas del dispositivo especificado por la función `SetWindowOrg`. GDI asigna todos los demás puntos siguiendo el mismo proceso necesario para asignar el origen de la ventana al origen de la ventanilla. Por ejemplo, todos los puntos de un círculo alrededor del punto en el origen de la ventana estarán en un círculo alrededor del punto en el origen de la ventanilla. De forma similar, todos los puntos de una línea que pasan a través del origen de la ventana estarán en una línea que pase por el origen de la ventanilla.

##  <a name="setworldtransform"></a>CDC:: SetWorldTransform

Establece una transformación lineal bidimensional entre el espacio universal y el espacio de página para el contexto de dispositivo especificado. Esta transformación se puede usar para escalar, girar, distorsionar o traducir resultados de gráficos.

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>Parámetros

*rXform*<br/>
Referencia a una estructura [XForm](/windows/win32/api/wingdi/ns-wingdi-xform) que contiene los datos de la transformación.

### <a name="return-value"></a>Valor devuelto

Devuelve un valor distinto de cero en caso de éxito.

Devuelve 0 en caso de error.

Para obtener información de error extendida, llame a [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Observaciones

Este método ajusta la función GDI de Windows [SetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-setworldtransform).

##  <a name="startdoc"></a>CDC:: StartDoc

Informa al controlador de dispositivo de que se está iniciando un nuevo trabajo de impresión y que todas las llamadas `StartPage` y `EndPage` subsiguientes se deben poner en cola en el mismo trabajo hasta que se produzca una llamada a `EndDoc`.

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>Parámetros

*lpDocInfo*<br/>
Apunta a una estructura [DOCINFO](/windows/win32/api/wingdi/ns-wingdi-docinfow) que contiene el nombre del archivo de documento y el nombre del archivo de salida.

*lpszDocName*<br/>
Puntero a una cadena que contiene el nombre del archivo de documento.

### <a name="return-value"></a>Valor devuelto

Si la función se ejecuta correctamente, el valor devuelto es mayor que cero. Este valor es el identificador del trabajo de impresión para el documento.

Si se produce un error en la función, el valor devuelto es menor o igual que cero.

### <a name="remarks"></a>Observaciones

Esto garantiza que los documentos que tengan más de una página no se intercalarán con otros trabajos.

En las versiones 3,1 y posteriores de Windows, esta función reemplaza el escape de la impresora STARTDOC. El uso de esta función garantiza que los documentos que contienen más de una página no se intercalan con otros trabajos de impresión.

`StartDoc` no se deben usar dentro de los metaarchivos.

### <a name="example"></a>Ejemplo

Este fragmento de código obtiene la impresora predeterminada, abre un trabajo de impresión y pone en cola una página con "Hello, World!" en él. Dado que el texto impreso por este código no se ajusta a las unidades lógicas de la impresora, el texto de salida puede estar en letras minúsculas, por lo que el resultado es ilegible. Las funciones de escala CDC, como `SetMapMode`, `SetViewportOrg`y `SetWindowExt`, se pueden usar para corregir el escalado.

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

##  <a name="startpage"></a>CDC:: StartPage

Llame a esta función miembro para preparar el controlador de impresora para recibir datos.

```
int StartPage();
```

### <a name="return-value"></a>Valor devuelto

Mayor o igual que 0 si la función es correcta, o un valor negativo si se produce un error.

### <a name="remarks"></a>Observaciones

`StartPage` sustituye a los escapes NEWFRAME y BANDINFO.

Para obtener información general sobre la secuencia de llamadas de impresión, vea la función miembro [StartDoc](#startdoc) .

El sistema deshabilita la función miembro `ResetDC` entre las llamadas a `StartPage` y `EndPage`.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC:: StartDoc](#startdoc).

##  <a name="stretchblt"></a>CDC:: StretchBlt

Copia un mapa de bits de un rectángulo de origen en un rectángulo de destino, estirando o comprimiendo el mapa de bits si es necesario para ajustarse a las dimensiones del rectángulo de destino.

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada X (en unidades lógicas) de la esquina superior izquierda del rectángulo de destino.

*y*<br/>
Especifica la coordenada Y (en unidades lógicas) de la esquina superior izquierda del rectángulo de destino.

*nWidth*<br/>
Especifica el ancho (en unidades lógicas) del rectángulo de destino.

*nHeight*<br/>
Especifica el alto (en unidades lógicas) del rectángulo de destino.

*pSrcDC*<br/>
Especifica el contexto de dispositivo de origen.

*xSrc*<br/>
Especifica la coordenada X (en unidades lógicas) de la esquina superior izquierda del rectángulo de origen.

*ySrc*<br/>
Especifica la coordenada Y (en unidades lógicas) de la esquina superior izquierda del rectángulo de origen.

*nSrcWidth*<br/>
Especifica el ancho (en unidades lógicas) del rectángulo de origen.

*nSrcHeight*<br/>
Especifica el alto (en unidades lógicas) del rectángulo de origen.

*dwRop*<br/>
Especifica la operación de trama que se va a realizar. Los códigos de operación de trama definen cómo combina GDI los colores en las operaciones de salida que implican un pincel actual, un posible mapa de bits de origen y un mapa de bits de destino. Este parámetro puede tener uno de los valores siguientes:

- La impresión de color negro activa todas las salidas.

- DSTINVERT invierte el mapa de bits de destino.

- MERGECOPY combina el patrón y el mapa de bits de origen mediante el operador booleano AND.

- MERGEPAINT combina el mapa de bits de origen invertido con el mapa de bits de destino mediante el operador booleano OR.

- NOTSRCCOPY copia el mapa de bits de origen invertido en el destino.

- NOTSRCERASE invierte el resultado de la combinación de los mapas de bits de destino y de origen mediante el operador booleano OR.

- PATCOPY copia el patrón en el mapa de bits de destino.

- PATINVERT combina el mapa de bits de destino con el patrón mediante el operador booleano XOR.

- PATPAINT combina el mapa de bits de origen invertido con el patrón mediante el operador booleano OR. Combina el resultado de esta operación con el mapa de bits de destino mediante el operador booleano OR.

- SRCAND combina píxeles de los mapas de bits de destino y de origen mediante el operador booleano AND.

- SRCCOPY copia el mapa de bits de origen en el mapa de bits de destino.

- SRCERASE invierte el mapa de bits de destino y combina el resultado con el mapa de bits de origen mediante el operador booleano AND.

- SRCINVERT combina píxeles de los mapas de bits de destino y de origen mediante el operador booleano XOR.

- SRCPAINT combina píxeles de los mapas de bits de destino y de origen mediante el operador booleano OR.

- La impresión convierte todo el blanco de salida.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si se dibuja el mapa de bits; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

La función emplea el modo de ajuste del contexto de dispositivo de destino (establecido por `SetStretchBltMode`) para determinar cómo estirar o comprimir el mapa de bits.

La función `StretchBlt` mueve el mapa de bits del dispositivo de origen proporcionado por *pSrcDC* al dispositivo de destino representado por el objeto de contexto del dispositivo cuya función miembro se está llamando. Los parámetros *xSrc*, *ySrc*, *nSrcWidth*y *nSrcHeight* definen la esquina superior izquierda y las dimensiones del rectángulo de origen. Los parámetros *x*, *y*, *nWidth*y *nHeight* proporcionan la esquina superior izquierda y las dimensiones del rectángulo de destino. La operación de trama especificada por *dwRop* define cómo se combinan el mapa de bits de origen y los bits que ya están en el dispositivo de destino.

La función `StretchBlt` crea una imagen reflejada de un mapa de bits si los signos de los parámetros *nSrcWidth* y *nWidth* , *nSrcHeight* y *nHeight* difieren. Si *nSrcWidth* y *nWidth* tienen signos diferentes, la función crea una imagen reflejada del mapa de bits a lo largo del eje x. Si *nSrcHeight* y *nHeight* tienen signos diferentes, la función crea una imagen reflejada del mapa de bits a lo largo del eje y.

La función `StretchBlt` estira o comprime el mapa de bits de origen en memoria y después copia el resultado al destino. Si se va a combinar un patrón con el resultado, no se combina hasta que el mapa de bits de origen estirado no se copia al destino. Si se usa un pincel, es el pincel seleccionado en el contexto de dispositivo de destino. Las coordenadas de destino se transforman según el contexto de dispositivo de destino; las coordenadas de origen se transforman según el contexto de dispositivo de origen.

Si los mapas de bits de destino, origen y patrón no tienen el mismo formato de color, `StretchBlt` convierte los mapas de bits de origen y de patrón para que coincidan con los mapas de bits de destino. En la conversión se usan los colores de primer plano y de fondo del contexto de dispositivo de destino.

Si `StretchBlt` debe convertir un mapa de bits monocromo a color, establece los bits blancos (1) al color de fondo y los bits negros (0) al color de primer plano. Para convertir de color a monocromo, establece en blanco (1) los píxeles que coinciden con el color de fondo y establece en negro (0) todos los demás píxeles. Se usan los colores de primer plano y de fondo del contexto de dispositivo con color.

No todos los dispositivos admiten la función `StretchBlt`. Para determinar si un dispositivo admite `StretchBlt`, llame a la función miembro `GetDeviceCaps` con el índice RASTERCAPS y compruebe el valor devuelto para la marca RC_STRETCHBLT.

##  <a name="strokeandfillpath"></a>CDC:: StrokeAndFillPath

Cierra las figuras abiertas en un trazado, traza el contorno del trazado mediante el lápiz actual y rellena su interior con el pincel actual.

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El contexto de dispositivo debe contener una ruta de acceso cerrada. La función miembro `StrokeAndFillPath` tiene el mismo efecto que cerrar todas las figuras abiertas en el trazado, y trazar y rellenar la ruta de acceso por separado, con la excepción de que la región rellena no se superpondrá a la región trazada aunque el lápiz sea ancho.

##  <a name="strokepath"></a>CDC:: StrokePath

Representa la ruta de acceso especificada utilizando el lápiz actual.

```
BOOL StrokePath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

El contexto de dispositivo debe contener una ruta de acceso cerrada.

##  <a name="tabbedtextout"></a>CDC:: TabbedTextOut

Llame a esta función miembro para escribir una cadena de caracteres en la ubicación especificada y expandir las pestañas hasta los valores especificados en la matriz de posiciones de detención de tabulación.

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada x lógica del punto inicial de la cadena.

*y*<br/>
Especifica la coordenada y lógica del punto inicial de la cadena.

*lpszString*<br/>
Apunta a la cadena de caracteres que se va a dibujar. Puede pasar un puntero a una matriz de caracteres o un objeto [CString](../../atl-mfc-shared/reference/cstringt-class.md) para este parámetro.

*nCount*<br/>
Especifica la [longitud de la cadena a la](/windows/win32/gdi/specifying-length-of-text-output-string) que apunta *lpszString*.

*nTabPositions*<br/>
Especifica el número de valores de la matriz de posiciones de tabulación.

*lpnTabStopPositions*<br/>
Apunta a una matriz que contiene las posiciones de tabulación (en unidades lógicas). Las tabulaciones se deben ordenar en orden ascendente; el valor x más pequeño debe ser el primer elemento de la matriz.

*nTabOrigin*<br/>
Especifica la coordenada x de la posición inicial desde la que se expanden las pestañas (en unidades lógicas).

*str*<br/>
`CString` objeto que contiene los caracteres especificados.

### <a name="return-value"></a>Valor devuelto

Dimensiones de la cadena (en unidades lógicas) como un objeto `CSize`.

### <a name="remarks"></a>Observaciones

El texto se escribe en la fuente seleccionada actualmente. Si *nTabPositions* es 0 y *lpnTabStopPositions* es null, las tabulaciones se expanden hasta ocho veces el ancho promedio de caracteres.

Si *nTabPositions* es 1, las tabulaciones se separan por la distancia especificada por el primer valor de la matriz *lpnTabStopPositions* . Si la matriz *lpnTabStopPositions* contiene más de un valor, se establece una tabulación para cada valor de la matriz, hasta el número especificado por *nTabPositions*. El parámetro *nTabOrigin* permite a una aplicación llamar a la función `TabbedTextOut` varias veces para una sola línea. Si la aplicación llama a la función más de una vez con el *nTabOrigin* establecido en el mismo valor cada vez, la función expande todas las pestañas en relación con la posición especificada por *nTabOrigin*.

De forma predeterminada, la función no usa ni actualiza la posición actual. Si una aplicación necesita actualizar la posición actual cuando llama a la función, la aplicación puede llamar a la función miembro [SetTextAlign](#settextalign) con *nFlags* establecida en TA_UPDATECP. Cuando se establece esta marca, Windows omite los parámetros *x* e *y en* las llamadas subsiguientes a `TabbedTextOut`, usando en su lugar la posición actual.

##  <a name="textout"></a>CDC:: TextOut

Escribe una cadena de caracteres en la ubicación especificada usando la fuente seleccionada actualmente.

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>Parámetros

*x*<br/>
Especifica la coordenada X lógica del punto inicial del texto.

*y*<br/>
Especifica la coordenada Y lógica del punto inicial del texto.

*lpszString*<br/>
Apunta a la cadena de caracteres que se va a dibujar.

*nCount*<br/>
Especifica el número de caracteres de la cadena.

*str*<br/>
Objeto `CString` que contiene los caracteres que se van a dibujar.

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Los orígenes de los caracteres están en la esquina superior izquierda de la celda de caracteres. De forma predeterminada, la función no usa ni actualiza la posición actual.

Si una aplicación necesita actualizar la posición actual cuando llama a `TextOut`, la aplicación puede llamar a la función miembro `SetTextAlign` con *nFlags* establecida en TA_UPDATECP. Cuando se establece esta marca, Windows omite los parámetros *x* e *y en* las llamadas subsiguientes a `TextOut`, usando en su lugar la posición actual.

### <a name="example"></a>Ejemplo

  Vea el ejemplo de [CDC:: BeginPath](#beginpath).

##  <a name="transparentblt"></a>CDC:: TransparentBlt

Llame a esta función miembro para transferir un bloque de bits de los datos de color, que corresponde a un rectángulo de píxeles desde el contexto de dispositivo de origen especificado, a un contexto de dispositivo de destino.

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>Parámetros

*xDest*<br/>
Especifica la coordenada x, en unidades lógicas, de la esquina superior izquierda del rectángulo de destino.

*yDest*<br/>
Especifica la coordenada y, en unidades lógicas, de la esquina superior izquierda del rectángulo de destino.

*nDestWidth*<br/>
Especifica el ancho, en unidades lógicas, del rectángulo de destino.

*nDestHeight*<br/>
Especifica el alto, en unidades lógicas, del rectángulo de destino.

*pSrcDC*<br/>
Puntero al contexto de dispositivo de origen.

*xSrc*<br/>
Especifica la coordenada x, en unidades lógicas, del rectángulo de origen.

*ySrc*<br/>
Especifica la coordenada y, en unidades lógicas, del rectángulo de origen.

*nSrcWidth*<br/>
Especifica el ancho, en unidades lógicas, del rectángulo de origen.

*nSrcHeight*<br/>
Especifica el alto, en unidades lógicas, del rectángulo de origen.

*clrTransparent*<br/>
Color RGB del mapa de bits de origen que se va a tratar como transparente.

### <a name="return-value"></a>Valor devuelto

TRUE si es correcto; en caso contrario, FALSE.

### <a name="remarks"></a>Observaciones

`TransparentBlt` permite la transparencia; es decir, el color RGB indicado por *clrTransparent* se representa como transparente para la transferencia.

Para obtener más información, vea [TransparentBlt](/windows/win32/api/wingdi/nf-wingdi-transparentblt) en el Windows SDK.

##  <a name="updatecolors"></a>CDC:: UpdateColors

Actualiza el área cliente del contexto del dispositivo al hacer coincidir los colores actuales del área cliente con la paleta del sistema píxel a píxel.

```
void UpdateColors();
```

### <a name="remarks"></a>Observaciones

Una ventana inactiva con una paleta lógica realizada puede llamar `UpdateColors` como alternativa a volver a dibujar su área cliente cuando cambia la paleta del sistema.

Para obtener más información sobre cómo usar las paletas de colores, vea [UpdateColors](/windows/win32/api/wingdi/nf-wingdi-updatecolors) en el Windows SDK.

Normalmente, la función miembro `UpdateColors` actualiza un área cliente más rápido que volver a dibujar el área. Sin embargo, dado que la función realiza la traducción de color en función del color de cada píxel antes de que cambie la paleta del sistema, cada llamada a esta función provoca la pérdida de alguna precisión del color.

##  <a name="widenpath"></a>CDC:: WidenPath

Vuelve a definir la ruta de acceso actual como área que se va a pintar si la ruta de acceso se traza con el lápiz seleccionado actualmente en el contexto del dispositivo.

```
BOOL WidenPath();
```

### <a name="return-value"></a>Valor devuelto

Es distinto de cero si la función se realiza correctamente; de lo contrario, es 0.

### <a name="remarks"></a>Observaciones

Esta función se realiza correctamente solo si el lápiz actual es un lápiz geométrico creado por la segunda versión de `CreatePen` función miembro, o si el lápiz se crea con la primera versión de `CreatePen` y tiene un ancho, en unidades de dispositivo, mayor que 1. El contexto de dispositivo debe contener una ruta de acceso cerrada. Cualquier curva Bzier en la ruta de acceso se convierte en secuencias de líneas rectas aproximadas a las curvas ampliadas. Como tal, no quedan curvas Bzier en la ruta de acceso una vez que se llama a `WidenPath`.

## <a name="see-also"></a>Consulte también

[CObject (clase)](../../mfc/reference/cobject-class.md)<br/>
[Gráfico de jerarquías](../../mfc/hierarchy-chart.md)<br/>
[CPaintDC (clase)](../../mfc/reference/cpaintdc-class.md)<br/>
[CWindowDC (clase)](../../mfc/reference/cwindowdc-class.md)<br/>
[CClientDC (clase)](../../mfc/reference/cclientdc-class.md)<br/>
[CMetaFileDC (clase)](../../mfc/reference/cmetafiledc-class.md)
