---
title: Errores del compilador de C3500 a C3999
ms.date: 04/21/2019
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
ms.openlocfilehash: eddadeeeb014c6b64376554f7ff025a06e8935c9
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/17/2020
ms.locfileid: "79446940"
---
# <a name="compiler-errors-c3500-through-c3999"></a>Errores del compilador de C3500 a C3999

En los artículos de esta sección de la documentación se explica un subconjunto de los mensajes de error generados por el compilador.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Mensajes de error

|Error|Message|
|-----------|-------------|
|[Error del compilador C3500](compiler-error-c3500.md)|ProgID '*ProgID*' no válido|
|[Error del compilador C3501](compiler-error-c3501.md)|no hay ninguna typelib registrada para el ID. de programa '*ProgID*'|
|Error del compilador C3502|no se puede obtener el identificador de programa *(ProgID)* para ProgID|
|Error del compilador C3503|no se permite el carácter ' 0x*Value*' en un literal de cadena sin formato|
|Error del compilador C3504|no se puede crear el GUID a partir de la cadena '*String*'|
|[Error del compilador C3505](compiler-error-c3505.md)|no se puede cargar la biblioteca de tipos '*Library*'|
|[Error del compilador C3506](compiler-error-c3506.md)|no hay ninguna typelib registrada para el LIBId '*Library*'|
|[Error del compilador C3507](compiler-error-c3507.md)|un ProgID no puede tener más de 39 caracteres '*ProgID*'; ni contienen signos de puntuación separados de '. '; ni comenzar por un dígito|
|[Error del compilador C3508](compiler-error-c3508.md)|'*Type*': no es un tipo de automatización válido|
|[Error del compilador C3509](compiler-error-c3509.md)|'*Type*': tipo de valor devuelto de automatización no válido; Cuando un parámetro está marcado como ' retval ', el tipo de valor devuelto debe ser ' void ', ' HRESULT ' o ' SCODE '|
|[Error del compilador C3510](compiler-error-c3510.md)|no se encuentra la *biblioteca* de biblioteca de tipos dependiente|
|Error del compilador C3511|'*Identifier*': una llamada a un constructor de delegación debe ser el único inicializador de miembro|
|Error del compilador C3512|la secuencia de caracteres delimitadores de un literal de cadena sin formato no debe tener más de 16 caracteres.|
|Error del compilador C3513|'*String*': carácter delimitador de literal de cadena sin formato no admitido|
|Error del compilador C3514|'*carácter*' (*valor*): carácter delimitador de literal de cadena sin formato no admitido|
|Error del compilador C3515|Si un argumento de una especialización parcial de una plantilla de clase es una expansión de paquete, será el último argumento.|
|Error del compilador C3516|se encontró un final de archivo inesperado al procesar el literal de cadena sin formato; no se encontró ninguna coincidencia con la secuencia de delimitador '*cadena*'|
|Error del compilador C3517|'*Identifier*': una declaración de alias no puede tener un tipo que contiene ' auto '|
|Error del compilador C3518|'*Identifier*': en un contexto de inicialización de lista directa, el tipo para '*Type*' solo se puede deducir a partir de una expresión de inicializador única|
|[Error del compilador C3519](compiler-error-c3519.md)|'*parámetro*': parámetro no válido para embedded_idl atributo|
|Error del compilador C3520|'*Identifier*': el paquete de parámetros debe expandirse en este contexto|
|Error del compilador C3521|'*Identifier*' no es un paquete de parámetros|
|Error del compilador C3522|'*Type*': el paquete de parámetros no se puede expandir en este contexto|
|Error del compilador C3523|' sizeof... ' requiere como argumento un paquete de parámetros no expandido|
|Error del compilador C3524|'*Identifier*': ' sizeof ' no se puede aplicar a un paquete de parámetros. ¿Pretendía usar ' sizeof... '?|
|Error del compilador C3525|'*parámetro*': Si una plantilla de clase tiene un paquete de parámetros de plantilla, debe aparecer al final de la lista de parámetros de plantilla|
|Error del compilador C3526|'...' no se puede aplicar a ' this '|
|Error del compilador C3527|'*Identifier*' no es un operando válido para ' sizeof... '. ¿Pretendía usar ' sizeof '?|
|Error del compilador C3528|'*identificador1*': el número de elementos de esta expansión del paquete no coincide con el número de elementos de '*identificador2*'|
|Error del compilador C3529|'*parámetro*': un paquete de parámetros de plantilla no puede tener un argumento predeterminado|
|[Error del compilador C3530](compiler-error-c3530.md)|'*Type*' no se puede combinar con ningún otro especificador de tipo|
|[Error del compilador C3531](compiler-error-c3531.md)|'*Identifier*': un símbolo cuyo tipo contiene '*Type*' debe tener un inicializador|
|[Error del compilador C3532](compiler-error-c3532.md)|el tipo de elemento de una matriz no puede ser un tipo que contenga '*tipo*'|
|[Error del compilador C3533](compiler-error-c3533.md)|un parámetro no puede tener un tipo que contenga '*Type*'|
|Error del compilador C3534|Obsoleto.|
|[Error del compilador C3535](compiler-error-c3535.md)|no se puede deducir el tipo de '*Type1*' de '*tipo2*'|
|[Error del compilador C3536](compiler-error-c3536.md)|'*Identifier*': no se puede usar antes de inicializarse|
|[Error del compilador C3537](compiler-error-c3537.md)|no se puede convertir a un tipo que contiene '*Type*'|
|[Error del compilador C3538](compiler-error-c3538.md)|en una lista de declaradores, '*tipo*' siempre debe deducirse en el mismo tipo|
|[Error del compilador C3539](compiler-error-c3539.md)|un argumento de plantilla no puede ser un tipo que contiene '*tipo*'|
|[Error del compilador C3540](compiler-error-c3540.md)|sizeof no se puede aplicar a un tipo que contiene '*Type*'|
|[Error del compilador C3541](compiler-error-c3541.md)|no se puede aplicar typeid a un tipo que contiene '*Type*'|
|Error del compilador C3542|'*Identifier*': una función miembro virtual no debe tener un tipo de valor devuelto que contenga '*Type*'|
|Error del compilador C3543|'*tipo*': no contiene un paquete de parámetros|
|Error del compilador C3544|'*parámetro*': el paquete de parámetros espera un argumento de plantilla de tipo|
|Error del compilador C3545|'*parámetro*': el paquete de parámetros espera un argumento de plantilla sin tipo|
|Error del compilador C3546|'... ': no hay paquetes de parámetros disponibles para expandir|
|Error del compilador C3547|no se puede usar el parámetro de plantilla '*parámetro*' porque sigue a un paquete de parámetros de plantilla y no se puede deducir de los parámetros de función de '*función*'.|
|Error del compilador C3548|'*Identifier*': el paquete de parámetros no se puede usar en este contexto|
|Error del compilador C3549|'*valor*': un paquete de parámetros de función no puede tener un argumento predeterminado|
|[Error del compilador C3550](compiler-error-c3550.md)|solo se permite 'decltype(auto)' sin formato en este contexto|
|[Error del compilador C3551](compiler-error-c3551.md)|Si se usa un tipo de valor devuelto final, el tipo de valor devuelto inicial debe ser el tipo único-especificador ' auto ' (no '*Type*')|
|[Error del compilador C3552](compiler-error-c3552.md)|se esperaba ' decltype (auto) '|
|[Error del compilador C3553](compiler-error-c3553.md)|decltype espera una expresión, no un tipo|
|[Error del compilador C3554](compiler-error-c3554.md)|'*Type*' no se puede combinar con ningún otro especificador de tipo|
|[Error del compilador C3555](compiler-error-c3555.md)|argumento incorrecto para 'decltype'|
|[Error del compilador C3556](compiler-error-c3556.md)|'*expresión*': argumento incorrecto para ' decltype '|
|Error del compilador C3557|Obsoleto.|
|Error del compilador C3558|Obsoleto.|
|Error del compilador C3559|llamada recursiva a '*función*': se detectó una recursividad al compilar el gráfico de llamadas para Concurrency::p arallel_for_each en: '*function*'|
|Error del compilador C3560|'*función*': Il no está disponible al compilar el gráfico de llamadas para Concurrency::p arallel_for_each en: '*function*'|
|Error del compilador C3561|se encontró una operación de barrera de mosaico en el flujo de control que no es uniforme en el mosaico al compilar el gráfico de llamadas para la simultaneidad::p arallel_for_each en: '*function*'|
|Error del compilador C3562|la función intrínseca '*función*' está limitada a no tener más de parámetros de *número*|
|Error del compilador C3563|Se detectó un bucle infinito al compilar el gráfico de llamadas para Concurrency::p arallel_for_each en: '*function*'|
|Error del compilador C3564|leyendo un valor sin inicializar al compilar el gráfico de llamadas para Concurrency::p arallel_for_each en: '*function*'|
|Error del compilador C3565|La cantidad total de memoria tile_static (*número* de bytes) supera el límite de *número* de bytes al compilar el gráfico de llamadas para la simultaneidad::p arallel_for_each|
|Error del compilador C3566|los bloques con efectos secundarios anidados son demasiado profundos al compilar el gráfico de llamadas para Concurrency::p arallel_for_each en: '*function*'|
|Error del compilador C3567|se ha detectado división o mod por cero al compilar el gráfico de llamadas para Concurrency::p arallel_for_each en: '*function*'|
|Error del compilador C3568|la suma de registros supera el límite de *número* al compilar el gráfico de llamadas para la simultaneidad::p arallel_for_each. Simplifique el programa|
|Error del compilador C3569|condición de carrera detectada al compilar el gráfico de llamadas para Concurrency::p arallel_for_each en: '*function*'|
|Error del compilador C3570|uso no válido del ámbito con restricción de amp al compilar con/CLR|
|Error del compilador C3571|'*Type*': argumento de dominio de cálculo no válido; no es un tipo de clase|
|Error del compilador C3572|'*Type*': argumento de dominio de cálculo no válido; falta el miembro público: ' Static const int Rank ' o el valor de rango no es positivo|
|Error del compilador C3573|El número de instancias de Concurrency:: Graphics:: Sampler pasado a Concurrency::p arallel_for_each no puede superar el *número*|
|Error del compilador C3574|'*Type*': extensiones de mosaico no válidas: debe ser positivo y (1) Z < = *número*; (2) Z*Y*X < = *número*|
|Error del compilador C3575|'*Type*': argumento de dominio de cálculo no válido; falta el miembro público: ' concurrency:: index <*número*> _map_index (const Concurrency:: index <*Number*> &) Restrict (amp) '|
|Error del compilador C3576|'*Type*': el*número* de argumento de Concurrency::d etalles:: _Parallel_for_each n.º no es compatible|
|Error del compilador C3577|Concurrency::p arallel_for_each argumento kernel no es válido: no se puede resolver la llamada al miembro ' void Operator () (*Type*) Restrict (amp) '|
|Error del compilador C3578|El tamaño del objeto de función pasado a Concurrency::p arallel_for_each no puede superar el *número* de bytes|
|Error del compilador C3579|El número de instancias de solo lectura de Concurrency:: Array y Concurrency:: Graphics:: Texture pasadas a Concurrency::p arallel_for_each no puede superar el *número*|
|Error del compilador C3580|El número de instancias de escritura de Concurrency:: Array y Concurrency:: Graphics:: Texture pasadas a Concurrency::p arallel_for_each no puede superar el *número*|
|Error del compilador C3581|'*Type*': tipo no compatible en código con restricción de amp|
|Error del compilador C3582|Obsoleto.|
|Error del compilador C3583|'*Identifier*': el tamaño de la variable (*número* de bytes) es mayor que el tamaño máximo (*número* de bytes) admitido en el código con restricción de amp|
|Error del compilador C3584|uso no admitido de tile_static en '*Identifier*'|
|Error del compilador C3585|'*Identifier*' tiene una clase de almacenamiento no admitida en código con restricción de amp|
|Error del compilador C3586|'*Identifier*': el uso de variables globales o estáticas no se admite en código con restricción de amp|
|Error del compilador C3587|dynamic_cast no se admite en código con restricción de amp|
|Error del compilador C3588|no se admite la conversión de '*tipo1*' a '*tipo2*' en código con restricción de amp|
|Error del compilador C3589|'*cadena*': uso no admitido de literales de cadena en código con restricción de amp|
|Error del compilador C3590|'*token*': la captura por referencia o la captura ' this ' no se admiten si la expresión lambda tiene restricción de amp|
|Error del compilador C3591|el operador typeid no se admite en código con restricción de amp|
|Error del compilador C3592|El ensamblado nativo alineado (' __asm ') no se admite en código con restricción de amp|
|Error del compilador C3593|' GOTO ' no se admite en código con restricción de amp|
|Error del compilador C3594|el control de excepciones (try, Catch, Throw etc.) no se admite en código con restricción de amp|
|Error del compilador C3595|el valor constante está fuera del intervalo admitido en el código con restricción de amp|
|Error del compilador C3596|'*parámetro*' ('*tipo*'): la variable capturada por lambda tiene un tipo no admitido en código con restricción de amp|
|Error del compilador C3597|'*parámetro*': '*Identifier*' no se permite capturar por valor si la expresión lambda es con restricción de amp|
|Error del compilador C3598|no se admite la instrucción Label en código con restricción de amp|
|Error del compilador C3599|'*Operator*': no se puede realizar aritmética de puntero en un puntero a bool en código con restricción de amp|
|Error del compilador C3600|'*función*': se ha detectado el uso del icono\_memoria estática al compilar el gráfico de llamadas para la simultaneidad sin mosaico::p arallel\_for_each en: '*function*'|
|Error del compilador C3601|'*Type*': no es un tipo de argumento válido para la función de diagnóstico amp '*function*'|
|Error del compilador C3602|Se detectó un flujo de control no compatible al compilar el gráfico de llamadas para Concurrency::p arallel_for_each en: '*function*'|
|[Error del compilador C3603](compiler-error-c3603.md)|'*Symbol*': el tipo '*Type*' todavía no se admite|
|Error del compilador C3604|'*Identifier*': solo puede crear un objeto administrado en el montón GC|
|Error del compilador C3605|El número total de muestras (*número* capturado y *número* predefinido) supera el *número* al compilar el gráfico de llamadas para la simultaneidad::p arallel_for_each en: '*función*'|
|Error del compilador C3606|Obsoleto.|
|Error del compilador C3607|Obsoleto.|
|Error del compilador C3608|Obsoleto.|
|[Error del compilador C3609](compiler-error-c3609.md)|'*Identifier*': una función ' Sealed/final ' debe ser virtual|
|[Error del compilador C3610](compiler-error-c3610.md)|'*Identifier*': el tipo de valor debe ser ' boxed ' antes de que se pueda llamar al método '*Method*'|
|[Error del compilador C3611](compiler-error-c3611.md)|'*Identifier*': una función sellada no puede tener un especificador Pure|
|[Error del compilador C3612](compiler-error-c3612.md)|'*Identifier*': una clase sellada no puede tener ningún método virtual puro|
|Error del compilador C3613|falta el tipo de valor devuelto después de '-> ' (se supone ' int ')|
|Error del compilador C3614|Valores diferentes para el tamaño de paquete dentro de la misma clase; Previous era '*Value*', el nuevo valor es '*Value*'|
|[Error del compilador C3615](compiler-error-c3615.md)|la función constexpr '*function*' no puede dar como resultado una expresión constante|
|Error del compilador C3616|Obsoleto.|
|Error del compilador C3617|Obsoleto.|
|[Error del compilador C3618](compiler-error-c3618.md)|'*declaration*': no se puede definir un método marcado como DllImport|
|[Error del compilador C3619](compiler-error-c3619.md)|una plantilla no se puede declarar dentro de un tipo administrado o WinRT|
|Error del compilador C3620|'*Type*': no se permite establecer la alineación en los tipos WinRT|
|Error del compilador C3621|'*tipo*': solo se permite el valor de empaquetado predeterminado (*número*) para los tipos WinRT|
|[Error del compilador C3622](compiler-error-c3622.md)|*tipo*': no se puede crear una instancia de una clase declarada como '*Keyword*'|
|[Error del compilador C3623](compiler-error-c3623.md)|'*Identifier*': no se admiten campos de bits en tipos administrados/WinRT|
|[Error del compilador C3624](compiler-error-c3624.md)|'*Type*': el uso de este tipo requiere una referencia al ensamblado o módulo '*Identifier*'|
|[Error del compilador C3625](compiler-error-c3625.md)|'*Class*': un tipo nativo no puede derivar de un tipo administrado o WinRT '*Type*'|
|[Error del compilador C3626](compiler-error-c3626.md)|'*Identifier*': la palabra clave '*Keyword*' solo se puede usar en interfaces com, funciones miembro y miembros de datos que sean punteros a delegados|
|[Error del compilador C3627](compiler-error-c3627.md)|Solo se puede aplicar la conversión boxing a un tipo de valor|
|[Error del compilador C3628](compiler-error-c3628.md)|'*Class*': las clases administradas/WinRT solo admiten herencia pública|
|Error del compilador C3629|'*token*': un valor predeterminado de captura solo puede aparecer al principio de una lista de capturas lambda|
|[Error del compilador C3630](compiler-error-c3630.md)|Error al procesar el token '*token*'|
|[Error del compilador C3631](compiler-error-c3631.md)|'*evento*': no se pueden sobrecargar eventos administrados/WinRT|
|[Error del compilador C3632](compiler-error-c3632.md)|'*evento*': estilo no válido del evento para la *construcción*|
|[Error del compilador C3633](compiler-error-c3633.md)|no se puede definir '*Identifier*' como miembro de '*Class*' administrado|
|[Error del compilador C3634](compiler-error-c3634.md)|'*member*': no se puede definir un método abstracto de una clase administrada o WinRT|
|Error del compilador C3635|'*Identifier*': no se puede aplicar a una clase administrada o WinRT (use '*Identifier*' en su lugar)|
|Error del compilador C3636|'*Identifier*': no se puede aplicar a este tipo|
|[Error del compilador C3637](compiler-error-c3637.md)|'*function*': una definición de función Friend no puede ser una especialización de una plantilla de función/Generic|
|[Error del compilador C3638](compiler-error-c3638.md)|'*Operator*': los operadores de conversión boxing y unboxing estándar no se pueden redefinir|
|Error del compilador C3639|Obsoleto.|
|[Error del compilador C3640](compiler-error-c3640.md)|'*member*': se debe definir una función miembro virtual o de referencia de una clase local|
|[Error del compilador C3641](compiler-error-c3641.md)|'*función*': Convención de llamada no válida '*Convención*' para la función compilada con/CLR: Pure o/CLR: Safe|
|[Error del compilador C3642](compiler-error-c3642.md)|'*función*': no se puede llamar a una función con __clrcall Convención de llamada desde código nativo|
|Error del compilador C3643|Obsoleto.|
|[Error del compilador C3644](compiler-error-c3644.md)|'*función*': no se puede compilar la función para generar código administrado|
|[Error del compilador C3645](compiler-error-c3645.md)|'*función*': no se puede usar __clrcall en funciones compiladas en código nativo|
|[Error del compilador C3646](compiler-error-c3646.md)|'*Identifier*': especificador de invalidación desconocido|
|Error del compilador C3647|Obsoleto.|
|[Error del compilador C3648](compiler-error-c3648.md)|Esta sintaxis de invalidación explícita no es compatible con los tipos administrados|
|Error del compilador C3649|no se permite esta sintaxis de invalidación explícita con/ZW|
|[Error del compilador C3650](compiler-error-c3650.md)|'*member*': no se puede usar como una invalidación explícita; debe ser una función miembro virtual de una clase base|
|[Error del compilador C3651](compiler-error-c3651.md)|'*member*': no se puede usar como una invalidación explícita; debe ser miembro de una clase base|
|[Error del compilador C3652](compiler-error-c3652.md)|'*miembro*': una función que invalida explícitamente debe ser virtual|
|[Error del compilador C3653](compiler-error-c3653.md)|'*Identifier*': no se puede usar como una invalidación con nombre: no se encuentra una función que se va a invalidar; ¿olvidó asignar un nombre a la función de forma explícita, mediante un operador::?|
|[Error del compilador C3654](compiler-error-c3654.md)|'*token*': error de sintaxis en la invalidación explícita|
|[Error del compilador C3655](compiler-error-c3655.md)|'*member*': la función ya se invalidó explícitamente|
|[Error del compilador C3656](compiler-error-c3656.md)|'*Keyword*': el especificador de invalidación no puede repetirse|
|[Error del compilador C3657](compiler-error-c3657.md)|un destructor o finalizador no puede invalidar explícitamente ni se puede reemplazar explícitamente|
|Error del compilador C3658|Obsoleto.|
|Error del compilador C3659|'*member*': no se admite el especificador de invalidación '*Keyword*'|
|Error del compilador C3660|'*member1*': oculta el miembro heredado '*miembro2*'|
|[Error del compilador C3661](compiler-error-c3661.md)|la lista de invalidaciones explícitas no encontró ningún método para invalidar|
|[Error del compilador C3662](compiler-error-c3662.md)|'*member*': el especificador de invalidación '*Keyword*' solo se permite en funciones miembro de clases administradas o WinRT|
|Error del compilador C3663|Obsoleto.|
|Error del compilador C3664|'*member*': no se puede usar como una invalidación explícita; debe tener accesibilidad ' Public ' o ' Protected '|
|[Error del compilador C3665](compiler-error-c3665.md)|'*member*': el especificador de invalidación '*Keyword*' no se permite en un destructor o finalizador|
|[Error del compilador C3666](compiler-error-c3666.md)|'*constructor*': el especificador de invalidación '*palabra clave*' no se permite en un constructor|
|Error del compilador C3667|'*atributo*': el atributo no admite la expansión del paquete|
|[Error del compilador C3668](compiler-error-c3668.md)|'*member*': el método con el especificador de invalidación ' override ' no invalidó ningún método de clase base|
|[Error del compilador C3669](compiler-error-c3669.md)|'*member*': el especificador de invalidación ' override ' no se permite en constructores ni funciones miembro estáticos|
|[Error del compilador C3670](compiler-error-c3670.md)|'*member*': no se puede invalidar el método de clase base inaccesible '*member*'|
|[Error del compilador C3671](compiler-error-c3671.md)|'*member*': la función no invalida '*member*'|
|[Error del compilador C3672](compiler-error-c3672.md)|la expresión del pseudo destructor solo se puede usar como parte de una llamada de función|
|[Error del compilador C3673](compiler-error-c3673.md)|'*Class*': la clase no tiene un constructor de copia|
|Error del compilador C3674|no se encontró el módulo de biblioteca estándar '*módulo*'|
|[Error del compilador C3675](compiler-error-c3675.md)|'*function*': está reservado porque '*Property*' está definido|
|Error del compilador C3676|'*Class*': la clase Ref y la clase base tienen atributos incompatibles ' [*Attribute*] '|
|Error del compilador C3677|el literal de cadena después de ' Operator ' no puede tener un prefijo de codificación|
|Error del compilador C3678|el literal de cadena después de ' Operator ' debe ser la cadena vacía ' "" "" '|
|Error del compilador C3679|se esperaba un identificador de sufijo literal después de ' Operator ' "" "'|
|Error del compilador C3680|no se pueden concatenar literales de cadena definidos por el usuario con identificadores de sufijo literal no coincidentes|
|Error del compilador C3681|' fallthrough ': el atributo solo puede aparecer en una instrucción switch envolvente|
|Error del compilador C3682|' operator *Identifier*': la plantilla de operador literal/literal no se puede declarar para que tenga ' vinculación C '|
|Error del compilador C3683|no se puede definir un operador literal sin formato y una plantilla de operador literal con el mismo identificador de sufijo literal|
|Error del compilador C3684|' operator *Identifier*': la declaración del operador literal tiene una lista de parámetros no válidos|
|Error del compilador C3685|' operator *Identifier*': la plantilla del operador literal no puede tener parámetros de función|
|Error del compilador C3686|' operator *Identifier*': la plantilla del operador literal debe tener exactamente un parámetro de plantilla que sea un paquete de parámetros|
|Error del compilador C3687|' operator *Identifier*': la plantilla del operador literal debe tener un parámetro de plantilla sin tipo de tipo ' char '|
|Error del compilador C3688|sufijo literal no válido '*sufijo*'; no se encontró el operador literal o la plantilla de operador literal ' *identificador*de operador '|
|Error del compilador C3689|' operator *Identifier*': la plantilla del operador literal/literal debe estar en un ámbito global o de espacio de nombres|
|Error del compilador C3690|se esperaba un literal de cadena, pero se encontró un literal de cadena definido por el usuario en su lugar.|
|Error del compilador C3691|Prefijo de literal no válido '*prefijo*'|
|Error del compilador C3692|Obsoleto.|
|Error del compilador C3693|Obsoleto.|
|Error del compilador C3694|Obsoleto.|
|Error del compilador C3695|Obsoleto.|
|Error del compilador C3696|'*Keyword*': no se puede usar este calificador en '% '|
|[Error del compilador C3697](compiler-error-c3697.md)|'*Keyword*': no se puede usar este calificador en ' ^ '|
|[Error del compilador C3698](compiler-error-c3698.md)|'*Type*': no se puede usar este tipo como argumento de '*Operator*'|
|[Error del compilador C3699](compiler-error-c3699.md)|'*Operator*': no se puede usar este direccionamiento indirecto en el tipo '*Type*'|
|Error del compilador C3700|Obsoleto.|
|[Error del compilador C3701](compiler-error-c3701.md)|'*función*': el origen del evento no tiene eventos|
|[Error del compilador C3702](compiler-error-c3702.md)|ATL es necesario para los eventos COM|
|[Error del compilador C3703](compiler-error-c3703.md)|'*event_handler*': un método de controlador de eventos debe tener la misma clase de almacenamiento que el '*evento*' de origen|
|[Error del compilador C3704](compiler-error-c3704.md)|'*member*': un método vararg no puede activar eventos|
|[Error del compilador C3705](compiler-error-c3705.md)|'*función*': no se puede encontrar la interfaz de eventos|
|[Error del compilador C3706](compiler-error-c3706.md)|'*función*': debe ser una interfaz com para desencadenar eventos com|
|[Error del compilador C3707](compiler-error-c3707.md)|'*member*': el método dispinterface debe tener un DISPID|
|[Error del compilador C3708](compiler-error-c3708.md)|'*function*': uso incorrecto de '*Keyword*'; debe ser miembro de un origen de eventos compatible|
|[Error del compilador C3709](compiler-error-c3709.md)|'*función*': Sintaxis incorrecta para especificar un evento en __hook/__unhook|
|[Error del compilador C3710](compiler-error-c3710.md)|'*función*': Sintaxis incorrecta para especificar el controlador de eventos en __hook/__unhook|
|[Error del compilador C3711](compiler-error-c3711.md)|'*evento*': un método de origen de eventos no administrado debe devolver void o un tipo entero|
|[Error del compilador C3712](compiler-error-c3712.md)|'*event_handler*': un método de controlador de eventos debe devolver el mismo tipo que el '*evento*' de origen|
|[Error del compilador C3713](compiler-error-c3713.md)|'*event_handler*': un método de controlador de eventos debe tener los mismos parámetros de función que el '*evento*' de origen|
|[Error del compilador C3714](compiler-error-c3714.md)|'*event_handler*': un método de controlador de eventos debe tener la misma Convención de llamada que el '*evento*' de origen|
|[Error del compilador C3715](compiler-error-c3715.md)|'*Pointer*': debe ser un puntero a '*Type*'|
|Error del compilador C3716|Obsoleto.|
|[Error del compilador C3717](compiler-error-c3717.md)|'*member*': no se puede definir un método que desencadene eventos|
|[Error del compilador C3718](compiler-error-c3718.md)|solo se puede llamar a ' _ _*Keyword*' en el contexto de una función miembro de la clase receptora|
|[Error del compilador C3719](compiler-error-c3719.md)|'*member*': un origen de eventos basado en interfaz solo se puede usar para eventos com|
|Error del compilador C3720|'*Type*': solo se puede implementar IDispatch en una interfaz dispinterface o dual|
|[Error del compilador C3721](compiler-error-c3721.md)|'*Signature*': signatura no compatible para el evento|
|[Error del compilador C3722](compiler-error-c3722.md)|no se permite un evento genérico|
|[Error del compilador C3723](compiler-error-c3723.md)|'*función*': no se pudo resolver el evento|
|[Error del compilador C3724](compiler-error-c3724.md)|debe #include \<Windows. h > para usar varios subprocesos con eventos|
|Error del compilador C3725|Obsoleto.|
|Error del compilador C3726|Obsoleto.|
|[Error del compilador C3727](compiler-error-c3727.md)|'*evento*': un evento administrado debe ser una función miembro o un miembro de datos que sea un puntero a un delegado|
|[Error del compilador C3728](compiler-error-c3728.md)|'*evento*': el evento no tiene un método raise|
|Error del compilador C3729|Obsoleto.|
|Error del compilador C3730|Obsoleto.|
|[Error del compilador C3731](compiler-error-c3731.md)|evento no compatible '*Event*' y handler '*event_handler*'; el origen del evento y el controlador de eventos deben tener el mismo tipo de evento|
|[Error del compilador C3732](compiler-error-c3732.md)|'*interfaz*': una interfaz personalizada que activa eventos com no puede heredar de IDispatch|
|[Error del compilador C3733](compiler-error-c3733.md)|'*Event*': Sintaxis incorrecta para especificar un evento com; ¿olvidó ' __interface '?|
|[Error del compilador C3734](compiler-error-c3734.md)|'*Class*': una clase administrada o WinRT no puede ser una coclase|
|Error del compilador C3735|Obsoleto.|
|[Error del compilador C3736](compiler-error-c3736.md)|'*member*': debe ser un método o, en el caso de eventos administrados, opcionalmente un miembro de datos|
|[Error del compilador C3737](compiler-error-c3737.md)|'*Identifier*': un delegado no puede tener una Convención de llamada explícita|
|[Error del compilador C3738](compiler-error-c3738.md)|'*Convention*': la Convención de llamada de la creación de instancias explícita debe coincidir con la de la plantilla de la que se crean instancias|
|[Error del compilador C3739](compiler-error-c3739.md)|'*Class*': la sintaxis solo se admite cuando el parámetro ' layout\_dependent ' de event_receiver es true|
|[Error del compilador C3740](compiler-error-c3740.md)|'*plantilla*': las plantillas no pueden tener eventos de origen o recepción|
|[Error del compilador C3741](compiler-error-c3741.md)|'*Class*': debe ser una coclase cuando el parámetro ' layout\_dependent ' de event_receiver sea true.|
|Error del compilador C3742|'*token1*': secuencia de token desequilibrada en el argumento de atributo de '*atributo*'; se esperaba '*token2*'|
|[Error del compilador C3743](compiler-error-c3743.md)|solo se puede enlazar/desenlazar una interfaz completa cuando el parámetro ' layout_dependent ' de event_receiver es true|
|[Error del compilador C3744](compiler-error-c3744.md)|__unhook debe tener al menos 3 argumentos para los eventos administrados|
|[Error del compilador C3745](compiler-error-c3745.md)|'*función*': solo un evento puede ser ' generated '|
|Error del compilador C3746|el atributo estándar '*Identifier*' puede aparecer como máximo una vez en una lista de atributos|
|[Error del compilador C3747](compiler-error-c3747.md)|falta la plantilla o el parámetro genérico predeterminados: *número* de parámetro|
|[Error del compilador C3748](compiler-error-c3748.md)|'*interfaz*': es posible que las interfaces no administradas no desencadenen eventos|
|[Error del compilador C3749](compiler-error-c3749.md)|'*atributo*': no se puede usar un atributo personalizado dentro de una función|
|Error del compilador C3750|'*token*': token inesperado en la lista de atributos|
|Error del compilador C3751|'*Identifier*': identificador inesperado en la lista de atributos|
|[Error del compilador C3752](compiler-error-c3752.md)|'*atributo*': no se puede clasificar el atributo; '*Keyword*' no se debe usar en este contexto|
|[Error del compilador C3753](compiler-error-c3753.md)|no se permite una propiedad genérica|
|[Error del compilador C3754](compiler-error-c3754.md)|constructor delegado: no se puede llamar a la función miembro '*member*' en una instancia de tipo '*Type*'|
|[Error del compilador C3755](compiler-error-c3755.md)|'*Identifier*': no se puede definir un delegado|
|Error del compilador C3756|Obsoleto.|
|Error del compilador C3757|'*Type*': tipo no permitido para la función ' constexpr '|
|Error del compilador C3758|'*member*': la función virtual no se puede declarar como ' constexpr '|
|Error del compilador C3759|'*member*': la función miembro de tipo no literal no se puede declarar como ' constexpr '|
|Error del compilador C3760|Use __property palabra clave para declarar la propiedad en la clase administrada/WinRT '*Class*'|
|[Error del compilador C3761](compiler-error-c3761.md)|'*función*': ' retval ' solo puede aparecer en el último argumento de una función|
|[Error del compilador C3762](compiler-error-c3762.md)|no se puede procesar el atributo '*atributo*'|
|[Error del compilador C3763](compiler-error-c3763.md)|'*Type*': ' retval ' y ' out ' solo pueden aparecer en un tipo de puntero de datos|
|[Error del compilador C3764](compiler-error-c3764.md)|'*member*': no se puede invalidar el método de clase base '*member*'|
|[Error del compilador C3765](compiler-error-c3765.md)|'*evento*': no se puede definir un evento en una clase o estructura '*Type*' marcada como event_receiver|
|[Error del compilador C3766](compiler-error-c3766.md)|'*Type*' debe proporcionar una implementación para el método de interfaz '*function*'|
|[Error del compilador C3767](compiler-error-c3767.md)|'*función*': no se puede obtener acceso a las funciones candidatas|
|[Error del compilador C3768](compiler-error-c3768.md)|no se puede adquirir la dirección de una función vararg virtual en código administrado puro|
|[Error del compilador C3769](compiler-error-c3769.md)|'*Identifier*': una clase anidada no puede tener el mismo nombre que la clase de inclusión inmediata|
|Error del compilador C3770|'*Type*': no es una clase base válida|
|[Error del compilador C3771](compiler-error-c3771.md)|'*Identifier*': no se encuentra la Declaración friend en el ámbito de espacio de nombres más próximo|
|[Error del compilador C3772](compiler-error-c3772.md)|'*Identifier*': Declaración de plantilla Friend no válida|
|Error del compilador C3773|Use el modificador de compilador/Await para habilitar las corrutinas.|
|Error del compilador C3774|no se encuentra '*Scope*::*Identifier*': incluya el encabezado de *encabezado*|
|Error del compilador C3775|el tipo de valor devuelto de '*function*' no debe ser '*Type*'|
|Error del compilador C3776|no se puede devolver un expresión de tipo void en una corrutina con un tipo de valor devuelto eventual distinto de void|
|Error del compilador C3777|'*función*': una corutina no puede tomar una lista de argumentos de variable|
|Error del compilador C3778|alloca: no se puede usar en una corrutina|
|Error del compilador C3779|'*function*': una función que devuelve '*Type*' no se puede usar antes de definirse|
|Error del compilador C3780|'*function*': una función de conversión que devuelve '*Type*' no se puede usar antes de definirse|
|Error del compilador C3781|'*Keyword*': no se puede usar en una corutina de tipo '*Type*'. Las *palabras clave* o *palabras clave* deben estar presentes en los promise_type asociados|
|Error del compilador C3782|*Type*: el compromiso de una corutina no puede contener la *palabra clave* y la *palabra clave*|
|Error del compilador C3783|'*Identifier*': no puede ser una corrutina|
|Error del compilador C3784|la expresión de *palabra clave* no puede aparecer en este contexto|
|Error del compilador C3785|el primer argumento de plantilla para ' STD:: integer_sequence ' debe ser un tipo entero|
|Error del compilador C3786|el segundo argumento de plantilla para ' STD:: make_integer_sequence ' debe ser una constante de tipo entero mayor o igual que cero|
|Error del compilador C3787|no se puede deducir el tipo de valor devuelto de esta corrutina|
|Error del compilador C3788|Obsoleto.|
|Error del compilador C3789|Obsoleto.|
|Error del compilador C3790|Obsoleto.|
|Error del compilador C3791|Obsoleto.|
|Error del compilador C3792|Obsoleto.|
|Error del compilador C3793|Obsoleto.|
|Error del compilador C3794|Obsoleto.|
|Error del compilador C3795|Obsoleto.|
|Error del compilador C3796|Obsoleto.|
|[Error del compilador C3797](compiler-error-c3797.md)|'*Keyword*': la declaración de evento no puede tener un especificador de invalidación (en su lugar, debe colocarse en métodos Add/Remove/raise)|
|[Error del compilador C3798](compiler-error-c3798.md)|'*Keyword*': la declaración de propiedad no puede tener un especificador de invalidación (en su lugar, debe colocarse en métodos Get/Set de propiedad)|
|[Error del compilador C3799](compiler-error-c3799.md)|la propiedad indizada no puede tener una lista de parámetros vacía|
|[Error del compilador C3800](compiler-error-c3800.md)|'*declaration*': no se pueden mezclar propiedades y eventos|
|Error del compilador C3801|'*Attribute*': el atributo no puede tener una cláusula argument|
|Error del compilador C3802|Obsoleto.|
|[Error del compilador C3803](compiler-error-c3803.md)|'*Property*': la propiedad tiene un tipo que es incompatible con uno de sus*descriptores*de acceso ' accessor '|
|[Error del compilador C3804](compiler-error-c3804.md)|'*member*': los métodos de descriptor de acceso de una propiedad deben ser todos estáticos o no estáticos|
|[Error del compilador C3805](compiler-error-c3805.md)|'*token*': token inesperado; se esperaba '} ' o ', '|
|Error del compilador C3806|'*token*': token inesperado. se esperaba ' {' o un inicializador de miembro|
|[Error del compilador C3807](compiler-error-c3807.md)|'*Type*': una clase con el atributo ComImport no puede derivar de '*Type*', solo se permite la implementación de la interfaz|
|[Error del compilador C3808](compiler-error-c3808.md)|'*Type*': una clase con el atributo ComImport no puede definir el miembro '*member*'; solo se permiten funciones abstract o DllImport|
|[Error del compilador C3809](compiler-error-c3809.md)|'*Type*': un tipo administrado o WinRT no puede tener ninguna función, clase o interfaz Friend|
|Error del compilador C3810|Obsoleto.|
|Error del compilador C3811|Obsoleto.|
|[Error del compilador C3812](compiler-error-c3812.md)|' __property ' debe ser el primer token de una declaración de propiedad|
|[Error del compilador C3813](compiler-error-c3813.md)|una declaración de propiedad solo puede aparecer dentro de la definición de un tipo administrado o WinRT|
|Error del compilador C3814|Obsoleto.|
|[Error del compilador C3815](compiler-error-c3815.md)|el tipo de valor devuelto del método '*member*' debe coincidir con el tipo del último parámetro de un establecedor|
|[Error del compilador C3816](compiler-error-c3816.md)|' Class/struct *member*' se declaró o se definió anteriormente con un modificador administrado/WinRT diferente|
|[Error del compilador C3817](compiler-error-c3817.md)|'*declaration*': la propiedad solo se puede aplicar a una función|
|[Error del compilador C3818](compiler-error-c3818.md)|la declaración de propiedad de matriz '*Property*' no debe sobrecargar una propiedad de índice '*Property*'|
|Error del compilador C3819|Obsoleto.|
|[Error del compilador C3820](compiler-error-c3820.md)|'*Identifier*': los inicializadores deben ser administrados|
|[Error del compilador C3821](compiler-error-c3821.md)|'*función*': no se puede usar la función o el tipo administrado en una función no administrada|
|Error del compilador C3822|Obsoleto.|
|Error del compilador C3823|Obsoleto.|
|[Error del compilador C3824](compiler-error-c3824.md)|'*Type*': este tipo no puede aparecer en este contexto (parámetro de función, tipo de valor devuelto o miembro estático)|
|[Error del compilador C3825](compiler-error-c3825.md)|'*Type*': una clase administrada o winrt solo puede admitir eventos administrados/winrt|
|Error del compilador C3826|Obsoleto.|
|Error del compilador C3827|el atributo estándar ' deprecated ' puede que no tenga ningún argumento o un literal de cadena que describa el motivo|
|[Error del compilador C3828](compiler-error-c3828.md)|no se pueden especificar argumentos de colocación para una expresión '*Keyword*' para el tipo '*Type*'|
|Error del compilador C3829|el atributo estándar ' noreturn ' solo se puede aplicar a funciones|
|[Error del compilador C3830](compiler-error-c3830.md)|'*tipo1*': no se puede heredar de '*tipo2*', los tipos de valor solo pueden heredar de clases de interfaz|
|[Error del compilador C3831](compiler-error-c3831.md)|'*Identifier*': '*Type*' no puede tener un miembro de datos anclado o una función miembro que devuelva un puntero anclado|
|[Error del compilador C3832](compiler-error-c3832.md)|'*typelib*': la biblioteca de tipos parece si se compiló para punteros de 32 bits; Cambie el calificador "ptrsize".|
|[Error del compilador C3833](compiler-error-c3833.md)|'*Type*': tipo de destino no válido para el *identificador*|
|[Error del compilador C3834](compiler-error-c3834.md)|conversión explícita no válida a un puntero anclado; usar una variable local anclada en su lugar|
|Error del compilador C3835|Obsoleto.|
|[Error del compilador C3836](compiler-error-c3836.md)|un constructor estático no puede tener una lista de inicializadores de miembro|
|Error del compilador C3837|no se permiten atributos en este contexto|
|[Error del compilador C3838](compiler-error-c3838.md)|no se puede heredar de '*Type*'|
|[Error del compilador C3839](compiler-error-c3839.md)|no se puede cambiar la alineación en un tipo administrado o WinRT|
|Error del compilador C3840|Obsoleto.|
|Error del compilador C3841|Obsoleto.|
|[Error del compilador C3842](compiler-error-c3842.md)|'*Identifier*': no se admiten calificadores ' const ' y ' volatile ' en funciones miembro de tipos administrados/WinRT|
|Error del compilador C3843|'*Identifier*': no se admiten calificadores de referencia en funciones miembro de tipos administrados/WinRT|
|Error del compilador C3844|'*Identifier*': no se puede importar el símbolo desde '*source*': ya existe '*Identifier*' en el ámbito actual|
|Error del compilador C3845|Obsoleto.|
|[Error del compilador C3846](compiler-error-c3846.md)|'*Identifier*': no se puede importar el símbolo desde '*source*': ya se ha importado '*Identifier*' desde otro ensamblado '*Assembly*'|
|Error del compilador C3847|Obsoleto.|
|[Error del compilador C3848](compiler-error-c3848.md)|una expresión que tiene el tipo '*tipo*' perdería algunos calificadores const-volatile para llamar a '*Identifier*'|
|[Error del compilador C3849](compiler-error-c3849.md)|la llamada de estilo de función en una expresión de tipo '*Type*' perdería calificadores const y/o volatile para todas las sobrecargas de operador disponibles de *número*|
|[Error del compilador C3850](compiler-error-c3850.md)|'*token*': un nombre de carácter universal especifica un carácter no válido|
|[Error del compilador C3851](compiler-error-c3851.md)|'*token*': un nombre de carácter universal no puede designar un carácter en el juego de caracteres básico|
|[Error del compilador C3852](compiler-error-c3852.md)|'*member*' tiene el tipo '*Type*': la inicialización de agregado no pudo inicializar este miembro|
|[Error del compilador C3853](compiler-error-c3853.md)|' = ': la reinicialización de una referencia o asignación a través de una referencia a una función no es válida|
|[Error del compilador C3854](compiler-error-c3854.md)|la expresión a la izquierda de ' = ' se evalúa como una función. No se puede asignar a una función (una función no es un valor l)|
|[Error del compilador C3855](compiler-error-c3855.md)|'*función*': el parámetro '*Identifier*' de plantilla o genérico no es compatible con la declaración|
|[Error del compilador C3856](compiler-error-c3856.md)|'*Class*': la clase no es una plantilla de clase/genérica|
|[Error del compilador C3857](compiler-error-c3857.md)|'*Template*': no se permiten varias listas de parámetros de plantilla o genéricos|
|[Error del compilador C3858](compiler-error-c3858.md)|'*Identifier*': no se puede volver a declarar en el ámbito actual|
|[Error del compilador C3859](compiler-error-c3859.md)|se superó el intervalo de memoria virtual para PCH. Vuelva a compilar con una opción de línea de comandos de '-ZM*Number*' o superior|
|[Error del compilador C3860](compiler-error-c3860.md)|la lista de argumentos genéricos o de plantilla siguiente debe mostrar los parámetros en el orden utilizado en la lista de parámetros de plantilla/genéricos|
|[Error del compilador C3861](compiler-error-c3861.md)|'*Identifier*': no se encontró el identificador|
|[Error del compilador C3862](compiler-error-c3862.md)|'*función*': no se puede compilar una función no administrada con/CLR: Pure o/CLR: Safe|
|Error del compilador C3863|el tipo de matriz '*tipo*' no es asignable|
|Error del compilador C3864|Obsoleto.|
|[Error del compilador C3865](compiler-error-c3865.md)|'*Keyword*': solo se puede usar en funciones miembro nativas|
|[Error del compilador C3866](compiler-error-c3866.md)|falta la lista de argumentos de la llamada de destructor/finalizador|
|[Error del compilador C3867](compiler-error-c3867.md)|'*función*': sintaxis no estándar; usar ' & ' para crear un puntero a un miembro|
|[Error del compilador C3868](compiler-error-c3868.md)|'*Type*': las restricciones del parámetro genérico '*Parameter*' difieren de las de la declaración|
|[Error del compilador C3869](compiler-error-c3869.md)|la restricción gcnew no tiene una lista de parámetros vacía ' () '|
|Error del compilador C3870|'*Parameter*': ' __declspec (*Specifier*) ' solo se puede aplicar a parámetros de tipo entero|
|Error del compilador C3871|'*parámetro*': ' __declspec (Guard (overflow)) ' solo se admite en los primeros 64 parámetros de una función|
|[Error del compilador C3872](compiler-error-c3872.md)|' 0x*Value*': este carácter no se permite en un identificador|
|[Error del compilador C3873](compiler-error-c3873.md)|' 0x*Value*': este carácter no se permite como primer carácter de un identificador|
|[Error del compilador C3874](compiler-error-c3874.md)|el tipo de valor devuelto de '*Identifier*' debe ser '*tipo1*' en lugar de '*tipo2*'|
|Error del compilador C3875|falta la lista de argumentos de la llamada a la función miembro no estática|
|Error del compilador C3876|Obsoleto.|
|Error del compilador C3877|Obsoleto.|
|Error del compilador C3878|Obsoleto.|
|Error del compilador C3879|'*member*': no puede ser un miembro de datos initonly|
|[Error del compilador C3880](compiler-error-c3880.md)|'*member*': no puede ser un miembro de datos literal|
|Error del compilador C3881|solo puede heredar el constructor de la base directa|
|Error del compilador C3882|'*Class*': el constructor ya se ha heredado de '*Class*'|
|Error del compilador C3883|'*member*': se debe inicializar un miembro de datos estático InitOnly|
|Error del compilador C3884|'*Type*': una matriz de tamaño desconocido no se puede inicializar con valores|
|Error del compilador C3885|'*Type*': no se puede inicializar una matriz de tamaño desconocido con una lista de inicializadores vacía|
|[Error del compilador C3886](compiler-error-c3886.md)|'*member*': se debe inicializar un miembro de datos literal|
|[Error del compilador C3887](compiler-error-c3887.md)|'*member*': el inicializador de un miembro de datos literal debe ser una expresión constante|
|[Error del compilador C3888](compiler-error-c3888.md)|'*member*': la expresión const asociada con este miembro de datos literal no es compatible C++con/CLI|
|Error del compilador C3889|Obsoleto.|
|[Error del compilador C3890](compiler-error-c3890.md)|'*member*': no se puede tomar la dirección de un miembro de datos literal|
|[Error del compilador C3891](compiler-error-c3891.md)|'*member*': no se puede usar un miembro de datos literal como valor l|
|[Error del compilador C3892](compiler-error-c3892.md)|'*variable*': no se puede asignar a una variable que sea const|
|[Error del compilador C3893](compiler-error-c3893.md)|'*member*': el uso del valor l del miembro de datos initonly solo se permite en un constructor de instancia de la clase '*Class*'|
|[Error del compilador C3894](compiler-error-c3894.md)|'*member*': el uso del valor l del miembro de datos estático InitOnly solo se permite en el constructor de clase de la clase '*Class*'|
|[Error del compilador C3895](compiler-error-c3895.md)|'*member*': los miembros de datos de *tipo* no pueden ser ' volatile '|
|[Error del compilador C3896](compiler-error-c3896.md)|'*member*': inicializador incorrecto: este miembro de datos literal solo se puede inicializar con ' nullptr '|
|Error del compilador C3897|Obsoleto.|
|[Error del compilador C3898](compiler-error-c3898.md)|'*member*': los miembros de datos de *tipo* solo pueden ser miembros de tipos administrados|
|[Error del compilador C3899](compiler-error-c3899.md)|'*member*': no se permite el uso del valor l del miembro de datos initonly directamente dentro de una región paralela de la clase '*Class*'|
|[Error del compilador C3900](compiler-error-c3900.md)|'*member*': no se permite en el ámbito actual|
|[Error del compilador C3901](compiler-error-c3901.md)|'*function*': debe tener el tipo de valor devuelto '*Type*'|
|[Error del compilador C3902](compiler-error-c3902.md)|'*función*': el tipo del último parámetro debe ser '*tipo*'|
|[Error del compilador C3903](compiler-error-c3903.md)|'*Property*': no tiene el método Set o get|
|[Error del compilador C3904](compiler-error-c3904.md)|'*Property*': debe especificar los parámetros de *número*|
|Error del compilador C3905|no se admiten accesos no alineados para el tipo intrínseco '*Type*'|
|Error del compilador C3906|el tipo intrínseco '*Type*' no es un tipo de valor devuelto o argumento admitido para funciones vararg o sin prototipo|
|Error del compilador C3907|Obsoleto.|
|[Error del compilador C3908](compiler-error-c3908.md)|nivel de acceso menos restrictivo que el de '*Identifier*'|
|[Error del compilador C3909](compiler-error-c3909.md)|una declaración de evento administrado/WinRT debe aparecer en un tipo administrado o WinRT|
|[Error del compilador C3910](compiler-error-c3910.md)|'*evento*': debe definir el miembro '*miembro*'|
|[Error del compilador C3911](compiler-error-c3911.md)|'*member*': la función debe tener el tipo '*Type*'|
|[Error del compilador C3912](compiler-error-c3912.md)|'*evento*': el tipo de evento debe ser un tipo delegado|
|[Error del compilador C3913](compiler-error-c3913.md)|se debe indexar una propiedad predeterminada|
|[Error del compilador C3914](compiler-error-c3914.md)|una propiedad predeterminada no puede ser estática|
|[Error del compilador C3915](compiler-error-c3915.md)|'*Identifier*' no tiene una propiedad indizada predeterminada (indizador de clase)|
|Error del compilador C3916|Obsoleto.|
|[Error del compilador C3917](compiler-error-c3917.md)|'*token*': estilo de declaración de *construcción* obsoleto (¿pretendía usar ' [' '] ' en su lugar?)|
|[Error del compilador C3918](compiler-error-c3918.md)|el uso requiere que '*Identifier*' sea un miembro de datos|
|[Error del compilador C3919](compiler-error-c3919.md)|'*función*': la función debe tener el tipo '*return_type* (*tipo*) '|
|[Error del compilador C3920](compiler-error-c3920.md)|'*Operator*': no se puede definir un operador CLR/winrt de incremento o decremento postfijo que llama al operador CLR/winrt de postfijo que llamará al operador CLR/winrt de prefijo correspondiente (op_Increment/op_Decrement), pero con semántica de postfijo|
|Error del compilador C3921|Obsoleto.|
|Error del compilador C3922|Obsoleto.|
|[Error del compilador C3923](compiler-error-c3923.md)|'*member*': las definiciones de clase, struct o unión locales no se permiten en una función miembro de una clase administrada o WinRT|
|Error del compilador C3924|error en el argumento n.º*número* de llamada al constructor delegado '*constructor*':|
|Error del compilador C3925|se esperaba un bucle (for, while o do) después de la Directiva '*Directive*'|
|Error del compilador C3926|constante no válida en la Directiva ' Parallel '|
|Error del compilador C3927|'-> ': no se permite el tipo de valor devuelto final después de un declarador que no es de función|
|Error del compilador C3928|'-> ': no se permite el tipo de valor devuelto final después de un declarador entre paréntesis|
|Error del compilador C3929|Obsoleto.|
|Error del compilador C3930|'*function*': ninguna función sobrecargada tiene especificadores de restricción que son compatibles con el contexto ambiente '*Context*'|
|Error del compilador C3931|'*Type*': no se puede llamar a una función que tenga especificadores de restricción que no sean compatibles con el contexto ambiente|
|Error del compilador C3932|Obsoleto.|
|Error del compilador C3933|'*Class*': los especificadores de restricción del destructor deben cubrir la Unión de restricciones en todos los constructores|
|Error del compilador C3934|una función que está en cualquier forma de ' Main ' no puede tener especificadores de restricción distintos de Restrict (CPU)|
|Error del compilador C3935|'*Identifier*': nueva definición; especificadores de restricción superpuestos|
|Error del compilador C3936|'*Identifier*': especificador de restricción no reconocido|
|Error del compilador C3937|no se permite un especificador de restricción vacío|
|Error del compilador C3938|'*Identifier*': no se admiten especificadores de restricción múltiples en funciones extern \042C\042|
|Error del compilador C3939|'*Identifier*': no se permiten funciones de puntero a miembro, punteros de función, referencias a funciones con el especificador de restricción ' amp '|
|Error del compilador C3940|'*Identifier*': no se encontró el identificador: posible incoherencia entre las versiones del compilador y la biblioteca. Asegúrese de que vccorlib. h/. lib, vccorlib120. dll y C1XX. dll coincidan|
|Error del compilador C3941|'*Condition*': requiere la opción de línea de comandos '/CLR '|
|Error del compilador C3942|Obsoleto.|
|Error del compilador C3943|Obsoleto.|
|Error del compilador C3944|Obsoleto.|
|Error del compilador C3945|'*Type*': no se puede iniciar o detectar un objeto winrt que no se deriva de Platform:: Exception|
|Error del compilador C3946|'*Type*': typeid no se puede aplicar a este tipo|
|Error del compilador C3947|'*typeid*': typeid no se puede aplicar a una expansión de paquete|
|Error del compilador C3948|'*Keyword*': no puede aparecer una expansión de paquete en este contexto|
|Error del compilador C3949|una expansión de paquete, '... ', no puede aparecer en un declarador abstracto entre paréntesis|
|Error del compilador C3950|Obsoleto.|
|Error del compilador C3951|No se puede usar un puntero a miembro en el tipo '*Type*' de WinRT previsto. En su lugar, use un delegado.|
|Error del compilador C3952|'*Type*': WinRT no admite matrices ' in/out '. Use ' const array\<T > ^ ' para ' in ' y ' WriteOnlyArray\<T > ' o ' array\<T > ^ * ' para ' out ' en las API públicas.|
|Error del compilador C3953|No se puede usar la clase administrada '*Type*' en el módulo WinRT.|
|Error del compilador C3954|'*Type*': una matriz devuelta por un método publicado en un tipo WinRT debe usar el formato ' array\<t > ^ '|
|Error del compilador C3955|'*Type*': un constructor público no puede contener un parámetro ' out ' o ' WriteOnlyArray\<t > '|
|Error del compilador C3956|'*Type*': el tipo está marcado como exclusivo para '*Type*' y no se puede usar como base de '*derived_type*'|
|Error del compilador C3957|'*Type*': no se puede usar ' New ' en un tipo WinRT; usar ' Ref New ' en su lugar|
|Error del compilador C3958|'*Type*': no se puede usar ' gcnew ' en un tipo WinRT; usar ' Ref New ' en su lugar|
|Error del compilador C3959|' Ref New ' solo se puede usar para crear un objeto con el tipo WinRT|
|Error del compilador C3960|Obsoleto.|
|Error del compilador C3961|no se admite el constructor estático|
|Error del compilador C3962|no se admite la clase genérica|
|Error del compilador C3963|no se admite la matriz multidimensional|
|Error del compilador C3964|no se admite una matriz escalonada|
|Error del compilador C3965|no se admite la matriz de parámetros|
|Error del compilador C3966|'*función*': no se admite la función genérica|
|Error del compilador C3967|Error al importar '*Identifier*' desde el módulo '*Module*'|
|Error del compilador C3968|el token '*token*' no es válido como separador de nombres de módulo; Use el punto ('. ') en su lugar|
|Error del compilador C3969|nombres de módulo incoherentes: '*Module1*' y '*Module1*'|
|Error del compilador C3970|'*Identifier*': '*Keyword*' solo se puede aplicar a ' Ref Class ' o ' Ref struct ' en el ámbito global o de espacio de nombres|
|Error del compilador C3971|'*Type*': la definición parcial no puede aparecer después de la definición completa|
|Error del compilador C3972|'*Type*': ' Partial ' solo se puede aplicar a definiciones o declaraciones de clase|
|Error del compilador C3973|Obsoleto.|
|Error del compilador C3974|Obsoleto.|
|Error del compilador C3975|' *identificador*de clase/struct ' se declaró o se definió anteriormente con un modificador diferente|
|Error del compilador C3976|'*identificador1*' debe declararse como ' Public ' para poder usar '*identificador2*'|
|Error del compilador C3977|El uso requiere una referencia a un ensamblado que define '*Identifier*'|
|Error del compilador C3978|'*Identifier*': no se permite una propiedad estática como miembro de un tipo de valor o una interfaz de WinRT|
|Error del compilador C3979|'*Type*': Use el atributo '*Attribute*' en lugar de '*Value*'|
|Error del compilador C3980|'*Type*' no se puede emitir en metadatos|
|Error del compilador C3981|'*Type*': un tipo de valor no puede tener ningún miembro de datos estático '*Identifier*'|
|Error del compilador C3982|'*Type*': un tipo de valor no puede tener ningún miembro de datos no público '*Identifier*'|
|Error del compilador C3983|'*Type*': un tipo de valor no puede tener ningún miembro público que no sea de datos '*Identifier*'|
|Error del compilador C3984|'*Type*': un tipo que no es de valor no puede tener ningún miembro de datos público '*Identifier*'|
|Error del compilador C3985|'*Identifier*': la Signatura del miembro público contiene el tipo privado '*member*'|
|Error del compilador C3986|'*Identifier*': la Signatura del miembro público contiene el tipo nativo '*member*'|
|Error del compilador C3987|'*Identifier*': la Signatura del miembro público contiene el tipo nativo '*tipo*'|
|Error del compilador C3988|'*Type*': un tipo nativo no puede ser público|
|Error del compilador C3989|'*Type*': un tipo anidado no puede ser público|
|Error del compilador C3990|'*Type*': el atributo '*Attribute*' no puede ser privado ni estar anidado|
|Error del compilador C3991|'*Type*': no se puede implementar una interfaz '*interface*' no pública o anidada|
|Error del compilador C3992|'*Identifier*': la Signatura del miembro público contiene un tipo no válido '*Type*'|
|Error del compilador C3993|'*Type*': un tipo de valor debe contener al menos un campo público|
|Error del compilador C3994|'*Type*': un tipo de valor no puede implementar interfaces o tener funciones virtuales|
|Error del compilador C3995|'*Type*': un tipo de valor no puede tener ningún miembro de evento '*Identifier*'|
|Error del compilador C3996|Obsoleto.|
|Error del compilador C3998|'*versión*de c++ ': C++ versión no admitida; el valor predeterminado es ' c++*versión*'|
|Error del compilador C3999|ERROR desconocido elija el comando soporte técnico en el menú Ayuda C++ visual o abra el archivo de ayuda de soporte técnico para obtener más información.|

## <a name="see-also"></a>Consulte también

[Errores yC++ advertencias de las herramientas de compilación y del compilador de C/](../compiler-errors-1/c-cpp-build-errors.md) \
[Errores del compilador C2000-C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
