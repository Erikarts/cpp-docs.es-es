---
title: Errores del compilador de C3500 a C3999
ms.date: 04/21/2019
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
ms.openlocfilehash: c5cb482804dac90a278036d594dc92e7be33e2bf
ms.sourcegitcommit: 283cb64fd7958a6b7fbf0cd8534de99ac8d408eb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/28/2019
ms.locfileid: "64857715"
---
# <a name="compiler-errors-c3500-through-c3999"></a>Errores del compilador de C3500 a C3999

Los artículos de esta sección de la documentación explican un subconjunto de los mensajes de error generados por el compilador.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Mensajes de error

|Error|Mensaje|
|-----------|-------------|
|[Error del compilador C3500](compiler-error-c3500.md)|ProgID no válido '*progid*'|
|[Error del compilador C3501](compiler-error-c3501.md)|No hay ninguna typelib registrada para el ProgID "*progid*'|
|Error del compilador C3502|no se puede obtener LIBID para ProgID '*progid*'|
|Error del compilador C3503|carácter "0 x*valor*' no se permite en una cadena sin formato literal|
|Error del compilador C3504|no se puede crear un GUID de cadena '*cadena*'|
|[Error del compilador C3505](compiler-error-c3505.md)|no se puede cargar la biblioteca de tipos '*biblioteca*'|
|[Error del compilador C3506](compiler-error-c3506.md)|No hay ninguna typelib registrada para el LIBID '*biblioteca*'|
|[Error del compilador C3507](compiler-error-c3507.md)|un ProgID puede tener no más de 39 caracteres*progid*'; no puede tener cualquier puntuación a excepción de '.'; ni comenzar por un dígito|
|[Error del compilador C3508](compiler-error-c3508.md)|'*tipo*': no es un tipo válido de automatización|
|[Error del compilador C3509](compiler-error-c3509.md)|'*tipo*': no válido del tipo de valor devuelto de automatización; cuando un parámetro se marca como 'retval', el tipo de valor devuelto debe ser 'void', 'HRESULT' o 'SCODE'|
|[Error del compilador C3510](compiler-error-c3510.md)|no se encuentra la biblioteca de tipos dependiente *biblioteca*|
|Error del compilador C3511|'*identificador*': una llamada a un constructor de delegación será el único inicializador de miembro|
|Error del compilador C3512|la secuencia de caracteres delimitadores para un literal de cadena sin formato tendrán no más de 16 caracteres|
|Error del compilador C3513|'*cadena*': no admite el carácter de delimitador de literal de cadena sin formato|
|Error del compilador C3514|'*carácter*' (*valor*): no admite el carácter de delimitador de literal de cadena sin formato|
|Error del compilador C3515|Si un argumento para una especialización parcial de plantillas de clase es una expansión del paquete será el último argumento|
|Error del compilador C3516|inesperado final de archivo encontrado al procesar la cadena sin formato literal; secuencia de delimitador '*cadena*' no coincidió|
|Error del compilador C3517|'*identificador*' una declaración de alias no puede tener un tipo que contiene 'auto'|
|Error del compilador C3518|'*identificador*': en un contexto de inicialización de lista directa del tipo para '*tipo*' solo se puede deducir a partir de una expresión de inicializador simple|
|[Error del compilador C3519](compiler-error-c3519.md)|'*parámetro*': parámetro no válido para el atributo embedded_idl|
|Error del compilador C3520|'*identificador*': paquete de parámetros debe expandirse en este contexto|
|Error del compilador C3521|'*identificador*' no es un paquete de parámetros|
|Error del compilador C3522|'*tipo*': no se puede expandir el paquete de parámetros en este contexto|
|Error del compilador C3523|'sizeof...' requiere como argumento un paquete de parámetros sin expandir|
|Error del compilador C3524|'*identificador*': 'sizeof' no puede aplicarse a un paquete de parámetros. ¿Pretendía usar 'sizeof...'?|
|Error del compilador C3525|'*parámetro*': si una plantilla de clase tiene un paquete de parámetros de plantilla debe aparecer al final de la lista de parámetros de plantilla|
|Error del compilador C3526|'...' no se puede aplicar a 'this'|
|Error del compilador C3527|'*identificador*' no es un operando válido para 'sizeof...'. ¿Pretendía usar 'sizeof'?|
|Error del compilador C3528|'*identificador1*': el número de elementos de esta expansión del paquete no coincide con el número de elementos en '*identificador2*'|
|Error del compilador C3529|'*parámetro*': un paquete de parámetros de plantilla no puede tener un argumento predeterminado|
|[Error del compilador C3530](compiler-error-c3530.md)|'*tipo*' no se puede combinar con ningún otro especificador de tipo|
|[Error del compilador C3531](compiler-error-c3531.md)|'*identificador*': un símbolo cuyo tipo contiene '*tipo*' debe tener un inicializador|
|[Error del compilador C3532](compiler-error-c3532.md)|el tipo de elemento de matriz no puede ser un tipo que contiene '*tipo*'|
|[Error del compilador C3533](compiler-error-c3533.md)|un parámetro no puede tener un tipo que contiene '*tipo*'|
|Error del compilador C3534|Obsoleto.|
|[Error del compilador C3535](compiler-error-c3535.md)|no se puede deducir el tipo de '*type1*'from'*type2*'|
|[Error del compilador C3536](compiler-error-c3536.md)|'*identificador*': no se puede usar antes de inicializarse|
|[Error del compilador C3537](compiler-error-c3537.md)|no se puede convertir a un tipo que contiene '*tipo*'|
|[Error del compilador C3538](compiler-error-c3538.md)|en una lista de declaradores '*tipo*' siempre debe deducirse como el mismo tipo|
|[Error del compilador C3539](compiler-error-c3539.md)|un argumento de plantilla no puede ser un tipo que contiene '*tipo*'|
|[Error del compilador C3540](compiler-error-c3540.md)|no se puede aplicar sizeof a un tipo que contiene '*tipo*'|
|[Error del compilador C3541](compiler-error-c3541.md)|no se puede aplicar typeid a un tipo que contiene '*tipo*'|
|Error del compilador C3542|'*identificador*': una función miembro virtual no debe tener un tipo de valor devuelto que contiene '*tipo*'|
|Error del compilador C3543|'*tipo*': no tiene un paquete de parámetros|
|Error del compilador C3544|'*parámetro*': paquete de parámetros espera un argumento de tipo de plantilla|
|Error del compilador C3545|'*parámetro*': paquete de parámetros espera un argumento de plantilla sin tipo|
|Error del compilador C3546|'...': no hay ningún paquete de parámetros disponible para expandir|
|Error del compilador C3547|parámetro de plantilla '*parámetro*'no se puede usar porque sigue a un paquete de parámetros de plantilla y no se puede deducir de los parámetros de función de'*función*'|
|Error del compilador C3548|'*identificador*': paquete de parámetros no se puede usar en este contexto|
|Error del compilador C3549|'*valor*': un paquete de parámetros de función no puede tener un argumento predeterminado|
|[Error del compilador C3550](compiler-error-c3550.md)|solo se permite 'decltype(auto)' sin formato en este contexto|
|[Error del compilador C3551](compiler-error-c3551.md)|Si se usa un tipo de valor devuelto final, a continuación, el tipo de valor devuelto inicial será el único especificador de tipo 'auto' (no '*tipo*')|
|[Error del compilador C3552](compiler-error-c3552.md)|se esperaba decltype 'de (de Auto)'|
|[Error del compilador C3553](compiler-error-c3553.md)|decltype espera una expresión, no un tipo|
|[Error del compilador C3554](compiler-error-c3554.md)|'*tipo*' no se puede combinar con ningún otro especificador de tipo|
|[Error del compilador C3555](compiler-error-c3555.md)|argumento incorrecto para 'decltype'|
|[Error del compilador C3556](compiler-error-c3556.md)|'*expresión*': argumento incorrecto para 'decltype'|
|Error del compilador C3557|Obsoleto.|
|Error del compilador C3558|Obsoleto.|
|Error del compilador C3559|llamada recursiva a '*función*': la recursividad se detecta al compilar el gráfico de llamadas para Concurrency:: parallel_for_each en: '*función*'|
|Error del compilador C3560|'*función*': IL no está disponible al compilar el gráfico de llamadas para Concurrency:: parallel_for_each en: '*función*'|
|Error del compilador C3561|icono de la operación de barrera se encuentra en el flujo de control que no está uniformidad de mosaico al compilar el gráfico de llamadas para Concurrency:: parallel_for_each en: '*función*'|
|Error del compilador C3562|función intrínseca '*función*' se limita a no tener más de *número* parámetros|
|Error del compilador C3563|Bucle infinito detectado al compilar el gráfico de llamadas para Concurrency:: parallel_for_each en: '*función*'|
|Error del compilador C3564|leer un valor no inicializado al compilar el gráfico de llamadas para Concurrency:: parallel_for_each en: '*función*'|
|Error del compilador C3565|La cantidad total de memoria tile_static (*número* bytes) supera el límite de *número* bytes al compilar el gráfico de llamadas para Concurrency:: parallel_for_each|
|Error del compilador C3566|bloques con efectos secundarios anidados demasiado al compilar la llamada de gráfico para Concurrency:: parallel_for_each en: '*función*'|
|Error del compilador C3567|división o modificación por cero detectado al compilar el gráfico de llamadas para Concurrency:: parallel_for_each en: '*función*'|
|Error del compilador C3568|la suma de registros supera el límite de *número* al compilar el gráfico de llamadas para Concurrency:: parallel_for_each. Simplifique el programa|
|Error del compilador C3569|se detectó al compilar el gráfico de llamadas para Concurrency:: parallel_for_each en una condición de carrera: '*función*'|
|Error del compilador C3570|uso no válido de amp ámbito con restricción cuando se compila con/CLR|
|Error del compilador C3571|'*tipo*': argumento de dominio de cálculo no válido; no es un tipo de clase|
|Error del compilador C3572|'*tipo*': argumento de dominio de cálculo no válido; falta el miembro público: 'static const int rank' o el valor de rango no es positivo|
|Error del compilador C3573|No puede superar el número de instancias de concurrency::graphics::sampler pasado a Concurrency:: parallel_for_each *número*|
|Error del compilador C3574|'*tipo*': extensiones de mosaico no válido: debe ser positivo y (1) Z < = *número*; (2) Z*Y*X < = *número*|
|Error del compilador C3575|'*type*': illegal compute domain argument; missing public member: 'concurrency::index<*number*> _map_index(const concurrency::index<*number*>&) restrict(amp)'|
|Error del compilador C3576|'*tipo*': argumento concurrency::details::_Parallel_for_each #*número* tipo no compatible|
|Error del compilador C3577|argumento de kernel Concurrency:: parallel_for_each no es válida: no se puede resolver la llamada al miembro ' void operator() (*tipo*) Restrict (amp) '|
|Error del compilador C3578|No puede superar el tamaño del objeto de función pasado a Concurrency:: parallel_for_each *número* bytes|
|Error del compilador C3579|No puede superar el número de instancias de solo lectura de Concurrency:: Array y Graphics:: Texture pasado a Concurrency:: parallel_for_each *número*|
|Error del compilador C3580|No puede superar el número de instancias modificables de Concurrency:: Array y Graphics:: Texture pasado a Concurrency:: parallel_for_each *número*|
|Error del compilador C3581|'*tipo*': código con restricción de tipo no admitido en amp|
|Error del compilador C3582|Obsoleto.|
|Error del compilador C3583|'*identificador*': el tamaño de la variable (*número* bytes) es mayor que el tamaño máximo (*número* bytes) admitido en código de la restricción de amp|
|Error del compilador C3584|no se admite el uso de tile_static en '*identificador*'|
|Error del compilador C3585|'*identificador*' con código con restricción de clase de almacenamiento no admitido en amp|
|Error del compilador C3586|'*identificador*': uso de variables globales o estáticas no admitido en el código de la restricción de amp|
|Error del compilador C3587|dynamic_cast no se admite en el código de la restricción de amp|
|Error del compilador C3588|realiza la conversión de '*type1*'para'*type2*' no se admite en código de la restricción de amp|
|Error del compilador C3589|'*cadena*': código con restricción de uso no admitido de literales de cadena de amp|
|Error del compilador C3590|'*token*': 'this' captura o captura por referencia no se admite si la expresión lambda tiene restringida de amp|
|Error del compilador C3591|operador typeid no se admite en el código de la restricción de amp|
|Error del compilador C3592|Ensamblado nativo alineado ('__asm') no se admite en el código de la restricción de amp|
|Error del compilador C3593|'goto' no se admite en el código de la restricción de amp|
|Error del compilador C3594|excepciones (try, catch, throw etc.) no se admite en el código de la restricción de amp|
|Error del compilador C3595|el valor constante está fuera del intervalo admitido en código de la restricción de amp|
|Error del compilador C3596|'*parámetro*' ('*tipo*'): variable capturada por lambda tipo no compatible en el código de la restricción de amp|
|Error del compilador C3597|'*parámetro*': '*identificador*' no se permite que se capturan por valor, si la expresión lambda tiene restringida de amp|
|Error del compilador C3598|instrucción de etiqueta no se admite en el código de la restricción de amp|
|Error del compilador C3599|'*operador*': no se puede realizar aritmética de puntero a bool en código de la restricción de amp|
|Error del compilador C3600|'*función*': uso de icono\_memoria estática detectada al compilar el gráfico de llamadas para el concurrency::parallel sin mosaico\_for_each en: '*función*'|
|Error del compilador C3601|'*tipo*': es el tipo de argumento no válido para la función de diagnóstico amp '*función*'|
|Error del compilador C3602|No admite el flujo de control detectado al compilar el gráfico de llamadas para Concurrency:: parallel_for_each en: '*función*'|
|[Error del compilador C3603](compiler-error-c3603.md)|'*símbolo*': tipo '*tipo*' todavía no se admite|
|Error del compilador C3604|'*identificador*': solo se puede crear un objeto administrado en el montón gc|
|Error del compilador C3605|El número total de muestras (*número* capturan y *número* predefinidas) supera *número* al compilar el gráfico de llamadas para Concurrency:: parallel_for_each en: ' *función*'|
|Error del compilador C3606|Obsoleto.|
|Error del compilador C3607|Obsoleto.|
|Error del compilador C3608|Obsoleto.|
|[Error del compilador C3609](compiler-error-c3609.md)|'*identificador*': una función 'sealed o final' debe ser virtual|
|[Error del compilador C3610](compiler-error-c3610.md)|'*identificador*': tipo de valor debe ser 'boxing' antes del método '*método*' se puede llamar a|
|[Error del compilador C3611](compiler-error-c3611.md)|'*identificador*': una función sealed no puede tener un especificador puro|
|[Error del compilador C3612](compiler-error-c3612.md)|'*identificador*': una clase sellada no puede tener métodos virtuales puros|
|Error del compilador C3613|Falta el tipo de valor devuelto después de '->' ('' se presupone int)|
|Error del compilador C3614|Diferentes valores para el tamaño de paquete dentro de la misma clase. anterior era '*valor*', en el nuevo valor es'*valor*'|
|[Error del compilador C3615](compiler-error-c3615.md)|la función constexpr '*función*' no se puede dar lugar a una expresión constante|
|Error del compilador C3616|Obsoleto.|
|Error del compilador C3617|Obsoleto.|
|[Error del compilador C3618](compiler-error-c3618.md)|'*declaración*': no se puede definir un método marcado como DllImport|
|[Error del compilador C3619](compiler-error-c3619.md)|no se puede declarar una plantilla dentro de un tipo administrado o WinRT|
|Error del compilador C3620|'*tipo*': no se puede establecer la alineación en tipos de WinRT|
|Error del compilador C3621|'*tipo*': solo el valor de empaquetado predeterminado (*número*) se permite para tipos de WinRT|
|[Error del compilador C3622](compiler-error-c3622.md)|*tipo*': una clase declarada como '*palabra clave*' no pueden crearse instancias|
|[Error del compilador C3623](compiler-error-c3623.md)|'*identificador*': no se admiten campos de bits en tipos administrados o WinRT|
|[Error del compilador C3624](compiler-error-c3624.md)|'*tipo*': uso de este tipo requiere una referencia al ensamblado o módulo '*identificador*'|
|[Error del compilador C3625](compiler-error-c3625.md)|'*clase*': un tipo nativo no puede derivar de un tipo administrado o WinRT '*tipo*'|
|[Error del compilador C3626](compiler-error-c3626.md)|'*identificador*': '*palabra clave*' palabra clave solo puede usarse en las interfaces COM, funciones miembro y miembros de datos que sean punteros a delegados|
|[Error del compilador C3627](compiler-error-c3627.md)|Solo un tipo de valor puede aplicarle la conversión boxing|
|[Error del compilador C3628](compiler-error-c3628.md)|'*clase*': las clases administradas o WinRT solo admiten herencia pública|
|Error del compilador C3629|'*token*': un valor predeterminado de captura solo puede aparecer al principio de una lista de capturas lambda|
|[Error del compilador C3630](compiler-error-c3630.md)|Error al procesar el token '*token*'|
|[Error del compilador C3631](compiler-error-c3631.md)|'*eventos*': no se pueden sobrecargar eventos administrados o WinRT|
|[Error del compilador C3632](compiler-error-c3632.md)|'*eventos*': estilo no válido de eventos para *construir*|
|[Error del compilador C3633](compiler-error-c3633.md)|no se puede definir '*identificador*'como administrado de un miembro de'*clase*'|
|[Error del compilador C3634](compiler-error-c3634.md)|'*miembro*': no se puede definir un método abstracto de una clase administrada o WinRT|
|Error del compilador C3635|'*identificador*': no se puede aplicar a una clase administrada o WinRT (use '*identificador*' en su lugar)|
|Error del compilador error C3636|'*identificador*': no se puede aplicar a este tipo|
|[Error del compilador C3637](compiler-error-c3637.md)|'*función*': una definición de función friend no puede ser una especialización de una plantilla de función/generic|
|[Error del compilador C3638](compiler-error-c3638.md)|'*operador*': no se puede redefinir la conversión boxing estándar y los operadores de conversión unboxing|
|Error del compilador C3639|Obsoleto.|
|[Error del compilador C3640](compiler-error-c3640.md)|'*miembro*': se debe definir una función miembro virtual o que se hace referencia de una clase local|
|[Error del compilador C3641](compiler-error-c3641.md)|'*función*': convención de llamada no válida '*convención*' para la función compilada con/CLR: pure o/CLR: safe|
|[Error del compilador C3642](compiler-error-c3642.md)|'*función*': no se puede llamar a una función con la convención de llamada desde código nativo __clrcall|
|Error del compilador C3643|Obsoleto.|
|[Error del compilador C3644](compiler-error-c3644.md)|'*función*': no se puede compilar la función para generar código administrado|
|[Error del compilador C3645](compiler-error-c3645.md)|'*función*': no se puede utilizar __clrcall en funciones compiladas para código nativo|
|[Error del compilador C3646](compiler-error-c3646.md)|'*identificador*': especificador de invalidación desconocido|
|Error del compilador C3647|Obsoleto.|
|[Error del compilador C3648](compiler-error-c3648.md)|Esta sintaxis de invalidación explícita no se admite para tipos administrados|
|Error del compilador C3649|Esta sintaxis de invalidación explícita no se permite con/ZW|
|[Error del compilador C3650](compiler-error-c3650.md)|'*miembro*': no se puede utilizar como invalidación explícita, debe ser una función miembro virtual de una clase base|
|[Error del compilador C3651](compiler-error-c3651.md)|'*miembro*': no se puede utilizar como invalidación explícita, debe ser miembro de una clase base|
|[Error del compilador C3652](compiler-error-c3652.md)|'*miembro*': una función que realiza invalidaciones explícitamente debe ser virtual|
|[Error del compilador C3653](compiler-error-c3653.md)|'*identificador*': no se puede utilizar como invalidación con nombre: una función que se va a reemplazar no se encuentra; ¿olvidó nombre a la función explícitamente, mediante r:: operador?|
|[Error del compilador C3654](compiler-error-c3654.md)|'*token*': error de sintaxis en la invalidación explícita|
|[Error del compilador C3655](compiler-error-c3655.md)|'*miembro*': función ya se ha invalidado explícitamente|
|[Error del compilador C3656](compiler-error-c3656.md)|'*palabra clave*': invalidar especificador no se puede repetir|
|[Error del compilador C3657](compiler-error-c3657.md)|un destructor/finalizador no puede invalidar o ser invalidado explícitamente|
|Error del compilador C3658|Obsoleto.|
|Error del compilador C3659|'*miembro*': especificador de invalidación '*palabra clave*' no se admite|
|Error del compilador C3660|'*member1*': oculta el miembro heredado '*member2*'|
|[Error del compilador C3661](compiler-error-c3661.md)|lista de invalidación explícita no encontró ningún método para invalidar|
|[Error del compilador C3662](compiler-error-c3662.md)|'*miembro*': especificador de invalidación '*palabra clave*' solo se permite en funciones miembro de clases administradas o WinRT|
|Error del compilador C3663|Obsoleto.|
|Error del compilador C3664|'*miembro*': no se puede utilizar como invalidación explícita, debe tener accesibilidad 'public' o 'protected'|
|[Error del compilador C3665](compiler-error-c3665.md)|'*miembro*': especificador de invalidación '*palabra clave*' no se permite en un destructor/finalizador|
|[Error del compilador C3666](compiler-error-c3666.md)|'*constructor*': especificador de invalidación '*palabra clave*' no se permite en un constructor|
|Error del compilador C3667|'*atributo*': atributo no es compatible con la expansión del paquete|
|[Error del compilador C3668](compiler-error-c3668.md)|'*miembro*': el método con el especificador de invalidación 'override' no reemplazó ningún método de clase base|
|[Error del compilador C3669](compiler-error-c3669.md)|'*miembro*': 'override' no se permite en constructores ni las funciones miembro estáticas en el especificador de invalidación|
|[Error del compilador C3670](compiler-error-c3670.md)|'*miembro*': no se puede invalidar el método de clase base inaccesible '*miembro*'|
|[Error del compilador C3671](compiler-error-c3671.md)|'*miembro*': función no invalida '*miembro*'|
|[Error del compilador C3672](compiler-error-c3672.md)|expresión de pseudodestructor solamente puede usarse como parte de una llamada de función|
|[Error del compilador C3673](compiler-error-c3673.md)|'*clase*': clase no tiene un constructor de copias|
|Error del compilador C3674|no se pudo encontrar el módulo de biblioteca estándar '*módulo*'|
|[Error del compilador C3675](compiler-error-c3675.md)|'*función*': se ha reservado porque '*propiedad*' está definido|
|Error del compilador C3676|'*clase*': clase ref y la clase base tienen atributos no compatibles ' [*atributo*]'|
|Error del compilador C3677|literal de cadena después de 'operator' no puede tener un prefijo de codificación|
|Error del compilador C3678|literal de cadena después de 'operator' debe ser una cadena vacía "" ""'|
|Error del compilador C3679|se esperaba un identificador de sufijo literal después de ' operator "" "'|
|Error del compilador C3680|no se pueden concatenar literales de cadena definido por el usuario con identificadores de sufijo literales que no coinciden|
|Error del compilador C3681|'fallthrough': attribute solo puede aparecer en una instrucción switch envolvente|
|Error del compilador C3682|' operador *identificador*': plantilla de operador de operador literal o literal no se pueden declarar para tener una 'Vinculación C'|
|Error del compilador C3683|no se puede definir el operador literal sin formato y la plantilla de operador literal con el mismo identificador de sufijo literal|
|Error del compilador C3684|' operador *identificador*': declaración del operador literal tiene una lista de parámetros no válidos|
|Error del compilador C3685|' operador *identificador*': plantilla de operador literal no puede tener parámetros de función|
|Error del compilador C3686|' operador *identificador*': plantilla de operador literal debe tener exactamente un parámetro de plantilla que es un paquete de parámetros|
|Error del compilador C3687|' operador *identificador*': plantilla de operador literal debe tener el parámetro de plantilla sin tipo del tipo 'char'|
|Error del compilador C3688|sufijo literal no válido '*sufijo*'; literal operador o la plantilla de operador literal ' operator *identificador*' no encontrado|
|Error del compilador C3689|' operador *identificador*': plantilla de operador de operador literal y literal debe estar en un ámbito global o de espacio de nombres|
|Error del compilador C3690|se esperaba una cadena literal, pero se encontró una cadena definida por el usuario literal en su lugar|
|Error del compilador C3691|prefijo literal no válido '*prefijo*'|
|Error del compilador C3692|Obsoleto.|
|Error del compilador C3693|Obsoleto.|
|Error del compilador C3694|Obsoleto.|
|Error del compilador C3695|Obsoleto.|
|Error del compilador C3696|'*palabra clave*': no se puede utilizar este calificador en '%'|
|[Error del compilador C3697](compiler-error-c3697.md)|'*palabra clave*': no se puede utilizar este calificador en ' ^'|
|[Error del compilador C3698](compiler-error-c3698.md)|'*tipo*': no se puede usar este tipo como argumento de '*operador*'|
|[Error del compilador C3699](compiler-error-c3699.md)|'*operador*': no se puede utilizar este direccionamiento indirecto en el tipo '*tipo*'|
|Error del compilador C3700|Obsoleto.|
|[Error del compilador C3701](compiler-error-c3701.md)|'*función*': origen de eventos no tiene eventos|
|[Error del compilador C3702](compiler-error-c3702.md)|Se requiere para los eventos COM ATL|
|[Error del compilador C3703](compiler-error-c3703.md)|'*event_handler*': un método de controlador de eventos debe tener la misma clase de almacenamiento que el origen '*eventos*'|
|[Error del compilador C3704](compiler-error-c3704.md)|'*miembro*': un método vararg no puede desencadenar eventos|
|[Error del compilador C3705](compiler-error-c3705.md)|'*función*': no se puede encontrar la interfaz de eventos|
|[Error del compilador C3706](compiler-error-c3706.md)|'*función*': debe ser una interfaz COM para desencadenar eventos COM|
|[Error del compilador C3707](compiler-error-c3707.md)|'*miembro*': el método dispinterface debe tener un dispid|
|[Error del compilador C3708](compiler-error-c3708.md)|'*función*': uso incorrecto de '*palabra clave*'; debe ser miembro de un origen de eventos compatible|
|[Error del compilador C3709](compiler-error-c3709.md)|'*función*': sintaxis incorrecta para especificar un evento en __hook/__unhook|
|[Error del compilador C3710](compiler-error-c3710.md)|'*función*': sintaxis incorrecta para especificar el controlador de eventos en __hook/__unhook|
|[Error del compilador C3711](compiler-error-c3711.md)|'*eventos*': un método de origen de eventos no administrado debe devolver void o un tipo integral|
|[Error del compilador C3712](compiler-error-c3712.md)|'*event_handler*': un método de controlador de eventos debe devolver el mismo tipo que el origen '*eventos*'|
|[Error del compilador C3713](compiler-error-c3713.md)|'*event_handler*': un método de controlador de eventos debe tener los mismos parámetros de función que el origen '*eventos*'|
|[Error del compilador C3714](compiler-error-c3714.md)|'*event_handler*': un método de controlador de eventos debe tener la misma convención de llamada que el origen '*eventos*'|
|[Error del compilador C3715](compiler-error-c3715.md)|'*puntero*': debe ser un puntero a '*tipo*'|
|Error del compilador C3716|Obsoleto.|
|[Error del compilador C3717](compiler-error-c3717.md)|'*miembro*': no se puede definir un método que desencadena eventos|
|[Error del compilador C3718](compiler-error-c3718.md)|Puede solo llamada ' __*palabra clave*' en el contexto de una función miembro de la clase receptora|
|[Error del compilador C3719](compiler-error-c3719.md)|'*miembro*': un origen de eventos basado en una interfaz solo puede usarse para eventos COM.|
|Error del compilador C3720|'*tipo*': sólo se puede implementar IDispatch en una interfaz dispinterface o doble|
|[Error del compilador C3721](compiler-error-c3721.md)|'*firma*': signatura no compatible para el evento|
|[Error del compilador C3722](compiler-error-c3722.md)|no se permite un evento genérico|
|[Error del compilador C3723](compiler-error-c3723.md)|'*función*': no se pudo resolver el evento|
|[Error del compilador C3724](compiler-error-c3724.md)|debe #include \<windows.h > para usar subprocesamiento múltiple con eventos|
|Error del compilador C3725|Obsoleto.|
|Error del compilador C3726|Obsoleto.|
|[Error del compilador C3727](compiler-error-c3727.md)|'*eventos*': un evento administrado debe ser una función miembro o un miembro de datos es un puntero a un delegado|
|[Error del compilador C3728](compiler-error-c3728.md)|'*eventos*': evento no tiene un método raise|
|Error del compilador C3729|Obsoleto.|
|Error del compilador C3730|Obsoleto.|
|[Error del compilador C3731](compiler-error-c3731.md)|evento incompatible '*eventos*'y el controlador'*event_handler*'; el origen y el controlador de eventos deben tener el mismo tipo de evento|
|[Error del compilador C3732](compiler-error-c3732.md)|'*interfaz*': una interfaz personalizada que desencadena eventos COM no puede heredar de IDispatch|
|[Error del compilador C3733](compiler-error-c3733.md)|'*eventos*': sintaxis incorrecta para especificar un evento COM. ¿ha olvidado '__interface'?|
|[Error del compilador C3734](compiler-error-c3734.md)|'*clase*': una clase administrada o WinRT no puede ser una coclase|
|Error del compilador C3735|Obsoleto.|
|[Error del compilador C3736](compiler-error-c3736.md)|'*miembro*': debe ser un método o, en el caso de eventos administrados, opcionalmente, un miembro de datos|
|[Error del compilador C3737](compiler-error-c3737.md)|'*identificador*': un delegado no puede tener una convención de llamada explícita|
|[Error del compilador C3738](compiler-error-c3738.md)|'*convención*': debe coincidir con la convención de llamada de la creación de instancias explícita de la plantilla que se va a crear una instancia|
|[Error del compilador C3739](compiler-error-c3739.md)|'*clase*': sintaxis solo es compatible cuando el ' diseño\_dependientes ' de event_receiver del parámetro es true|
|[Error del compilador C3740](compiler-error-c3740.md)|'*plantilla*': las plantillas no pueden originar o recibir eventos|
|[Error del compilador C3741](compiler-error-c3741.md)|'*clase*': debe ser una coclase cuando el "diseño\_dependiente ' de event_receiver del parámetro es true|
|Error del compilador C3742|'*token1*': desequilibradas secuencia de token en el argumento de atributo de '*atributo*', esperado'*token2*'|
|[Error del compilador C3743](compiler-error-c3743.md)|Puede solo enlazar/desenlazar una interfaz completa cuando el parámetro 'layout_dependent' de event_receiver es true|
|[Error del compilador C3744](compiler-error-c3744.md)|__unhook debe tener al menos 3 argumentos para eventos administrados|
|[Error del compilador C3745](compiler-error-c3745.md)|'*función*': sólo genera un evento puede ser' '|
|Error del compilador C3746|atributo estándar '*identificador*' puede aparecer como máximo una vez en una lista de atributos|
|[Error del compilador C3747](compiler-error-c3747.md)|Falta el parámetro de plantilla o genérico predeterminado: parámetro *número*|
|[Error del compilador C3748](compiler-error-c3748.md)|'*interfaz*': las interfaces no administradas no pueden desencadenar eventos|
|[Error del compilador C3749](compiler-error-c3749.md)|'*atributo*': un atributo personalizado no puede usarse dentro de una función|
|Error del compilador C3750|'*token*': token inesperado en la lista de atributos|
|Error del compilador C3751|'*identificador*': identificador inesperado en la lista de atributos|
|[Error del compilador C3752](compiler-error-c3752.md)|'*atributo*': no se puede clasificar el atributo; '*palabra clave*' no debe usarse en este contexto|
|[Error del compilador C3753](compiler-error-c3753.md)|no se permiten propiedades genéricas|
|[Error del compilador C3754](compiler-error-c3754.md)|constructor delegado: función miembro '*miembro*'no puede llamarse en una instancia del tipo'*tipo*'|
|[Error del compilador C3755](compiler-error-c3755.md)|'*identificador*': no se puede definir un delegado|
|Error del compilador C3756|Obsoleto.|
|Error del compilador C3757|'*tipo*': tipo no permitido para la función 'constexpr'|
|Error del compilador C3758|'*miembro*': función virtual no se pueden declarar 'constexpr'|
|Error del compilador C3759|'*miembro*': función miembro de tipo no literal no se puede declarar 'constexpr'|
|Error del compilador C3760|use la palabra clave __property para declarar la propiedad administrada o WinRT '*clase*'|
|[Error del compilador C3761](compiler-error-c3761.md)|'*función*': 'retval' solo puede aparecer en el último argumento de una función|
|[Error del compilador C3762](compiler-error-c3762.md)|no se puede procesar el atributo '*atributo*'|
|[Error del compilador C3763](compiler-error-c3763.md)|'*tipo*': 'retval' y 'out' solo puede aparecer en un tipo de puntero de datos|
|[Error del compilador C3764](compiler-error-c3764.md)|'*miembro*': no se puede invalidar el método de clase base '*miembro*'|
|[Error del compilador C3765](compiler-error-c3765.md)|'*eventos*': no se puede definir un evento en una class/struct '*tipo*' marcada como event_receiver|
|[Error del compilador C3766](compiler-error-c3766.md)|'*tipo*'debe proporcionar una implementación para el método de interfaz'*función*'|
|[Error del compilador C3767](compiler-error-c3767.md)|'*función*': las funciones de candidato no es accesibles|
|[Error del compilador C3768](compiler-error-c3768.md)|no se puede adquirir la dirección de una función vararg virtual en código administrado puro|
|[Error del compilador C3769](compiler-error-c3769.md)|'*identificador*': una clase anidada no puede tener el mismo nombre que la clase inmediatamente envolvente|
|Error del compilador C3770|'*tipo*': no es una clase base válida|
|[Error del compilador C3771](compiler-error-c3771.md)|'*identificador*': no se encuentra la declaración friend en el ámbito de espacio de nombres más próximo|
|[Error del compilador C3772](compiler-error-c3772.md)|'*identificador*': declaración de plantilla friend no válida|
|Error del compilador C3773|Por favor, use / await modificador del compilador para habilitar las corrutinas|
|Error del compilador C3774|no se puede encontrar '*ámbito*::*identificador*': Incluya *encabezado* encabezado|
|Error del compilador C3775|tipo de valor devuelto '*función*'no debe ser'*tipo*'|
|Error del compilador C3776|no se puede devolver una expresión de tipo void en una corrutina con tipo de devolución eventual distinto de void|
|Error del compilador C3777|'*función*': una corrutina no admite una lista de argumentos variables|
|Error del compilador C3778|alloca: no se puede usar en una corrutina|
|Error del compilador C3779|'*función*': una función que devuelve '*tipo*' no se puede usar antes de definirse|
|Error del compilador C3780|'*función*': conversión de una función que devuelve*tipo*' no se puede usar antes de definirse|
|Error del compilador C3781|'*palabra clave*': no puede ser un valor utilizado en una corrutina de tipo '*tipo*'. Cualquier *palabra clave* o *palabra clave* debe estar presente en el elemento promise_type asociado|
|Error del compilador C3782|*tipo*: una promesa de corrutina no puede contener ambas *palabra clave* y *palabra clave*|
|Error del compilador C3783|'*identificador*': no puede ser una corrutina|
|Error del compilador C3784|*palabra clave* expresión no puede aparecer en este contexto|
|Error del compilador C3785|el primer argumento de plantilla para 'std:: integer_sequence' debe ser un tipo entero|
|Error del compilador C3786|el segundo argumento de plantilla para 'std:: make_integer_sequence' debe ser una constante entera mayor o igual a cero.|
|Error del compilador C3787|no se puede deducir el tipo de valor devuelto de esta corrutina|
|Error del compilador C3788|Obsoleto.|
|Error del compilador C3789|Obsoleto.|
|Error del compilador C3790|Obsoleto.|
|Error del compilador C3791|Obsoleto.|
|Error del compilador C3792|Obsoleto.|
|Error del compilador C3793|Obsoleto.|
|Error del compilador C3794|Obsoleto.|
|Error del compilador C3795|Obsoleto.|
|Error del compilador C3796|Obsoleto.|
|[Error del compilador C3797](compiler-error-c3797.md)|'*palabra clave*': declaración de evento no puede tener el especificador de invalidación (en su lugar se debe colocar en métodos add, remove o raise)|
|[Error del compilador C3798](compiler-error-c3798.md)|'*palabra clave*': declaración de propiedad no puede tener el especificador de invalidación (debe colocarse en la propiedad en su lugar los métodos get/set)|
|[Error del compilador C3799](compiler-error-c3799.md)|la propiedad indizada no puede tener una lista de parámetros vacía|
|[Error del compilador C3800](compiler-error-c3800.md)|'*declaración*': no se pueden mezclar propiedades y eventos|
|Error del compilador C3801|'*atributo*': atributo no puede tener una cláusula de argumento|
|Error del compilador C3802|Obsoleto.|
|[Error del compilador C3803](compiler-error-c3803.md)|'*propiedad*': propiedad tiene un tipo que no es compatible con uno de sus descriptores de acceso*descriptor de acceso*'|
|[Error del compilador C3804](compiler-error-c3804.md)|'*miembro*': los métodos de descriptor de acceso de una propiedad debe ser estáticos o no estáticos|
|[Error del compilador C3805](compiler-error-c3805.md)|*token*': token inesperado, se esperaba '} 'o','|
|Error del compilador C3806|'*token*': token inesperado, se esperaba una ' {' o un inicializador de miembro|
|[Error del compilador C3807](compiler-error-c3807.md)|'*tipo*': una clase con el atributo ComImport no puede derivar de '*tipo*', se permite solo la implementación de interfaz|
|[Error del compilador C3808](compiler-error-c3808.md)|'*tipo*': una clase con el atributo ComImport no puede definir el miembro '*miembro*', solo abstracta o se permiten funciones dllimport|
|[Error del compilador C3809](compiler-error-c3809.md)|'*tipo*': un tipo administrado o WinRT no puede tener cualquier funciones, clase o interfaz friend|
|Error del compilador C3810|Obsoleto.|
|Error del compilador C3811|Obsoleto.|
|[Error del compilador C3812](compiler-error-c3812.md)|'__property' debe ser el primer símbolo (token) en una declaración de propiedad|
|[Error del compilador C3813](compiler-error-c3813.md)|una declaración de propiedad solo puede aparecer dentro de la definición de un tipo administrado o WinRT|
|Error del compilador C3814|Obsoleto.|
|[Error del compilador C3815](compiler-error-c3815.md)|tipo del método de valor devuelto '*miembro*' debe coincidir con el tipo del último parámetro de un establecedor|
|[Error del compilador C3816](compiler-error-c3816.md)|' clase/estructura *miembro*' se ha declarado previamente o que se define con un modificador administrado o WinRT diferente|
|[Error del compilador C3817](compiler-error-c3817.md)|'*declaración*': sólo puede aplicarse a una función de propiedad|
|[Error del compilador C3818](compiler-error-c3818.md)|declaración de propiedad de matriz '*propiedad*'no debe sobrecargar una propiedad index'*propiedad*'|
|Error del compilador C3819|Obsoleto.|
|[Error del compilador C3820](compiler-error-c3820.md)|'*identificador*': los inicializadores deben administrarse.|
|[Error del compilador C3821](compiler-error-c3821.md)|'*función*': función o tipo administrado no se puede usar en una función no administrada|
|Error del compilador C3822|Obsoleto.|
|Error del compilador C3823|Obsoleto.|
|[Error del compilador C3824](compiler-error-c3824.md)|'*tipo*': este tipo no puede aparecer en este contexto (parámetro de función, tipo de valor devuelto o un miembro estático)|
|[Error del compilador C3825](compiler-error-c3825.md)|'*tipo*': una clase administrada o WinRT solo puede admitir eventos administrados o WinRT|
|Error del compilador C3826|Obsoleto.|
|Error del compilador C3827|atributo estándar 'deprecated' puede tener ningún argumento o una cadena literal que describe el motivo|
|[Error del compilador C3828](compiler-error-c3828.md)|no se puede especificar argumentos de ubicación de un '*palabra clave*'expresión para el tipo'*tipo*'|
|Error del compilador C3829|atributo estándar 'noreturn' sólo puede aplicarse a las funciones|
|[Error del compilador C3830](compiler-error-c3830.md)|'*type1*': no puede heredar de '*type2*', los tipos de valor solo pueden heredar de clases interface|
|[Error del compilador C3831](compiler-error-c3831.md)|'*identificador*': '*tipo*' no puede tener un miembro de datos anclado o una función miembro devuelve un puntero anclado|
|[Error del compilador C3832](compiler-error-c3832.md)|'*typelib*': parece que la biblioteca tipo como si se ha generado para punteros de 32 bits; cambie el calificador 'ptrsize'|
|[Error del compilador C3833](compiler-error-c3833.md)|'*tipo*': tipo de destino no válido para *identificador*|
|[Error del compilador C3834](compiler-error-c3834.md)|conversión de tipo explícita a un puntero anclado; Use una variable local anclada en su lugar|
|Error del compilador C3835|Obsoleto.|
|[Error del compilador C3836](compiler-error-c3836.md)|un constructor estático no puede tener una lista de inicializadores de miembro|
|Error del compilador C3837|no se permiten atributos en este contexto|
|[Error del compilador C3838](compiler-error-c3838.md)|no puede heredar de '*tipo*'|
|[Error del compilador C3839](compiler-error-c3839.md)|no se puede cambiar la alineación en un tipo administrado o WinRT|
|Error del compilador C3840|Obsoleto.|
|Error del compilador C3841|Obsoleto.|
|[Error del compilador C3842](compiler-error-c3842.md)|'*identificador*': no se admiten calificadores 'const' y 'volatile' en funciones miembro de tipos administrados o WinRT|
|Error del compilador C3843|'*identificador*': no se admiten calificadores de referencia en funciones miembro de tipos administrados o WinRT|
|Error del compilador error C3844|'*identificador*': no se puede importar un símbolo desde '*origen*': como*identificador*' ya existe en el ámbito actual|
|Error del compilador C3845|Obsoleto.|
|[Error del compilador C3846](compiler-error-c3846.md)|'*identificador*': no se puede importar un símbolo desde '*origen*': como*identificador*'ya se importó desde otro ensamblado'*ensamblado*'|
|Error del compilador C3847|Obsoleto.|
|[Error del compilador C3848](compiler-error-c3848.md)|expresión de tipo '*tipo*'perdería algunos calificadores const y volatile para poder llamar a'*identificador*'|
|[Error del compilador C3849](compiler-error-c3849.md)|llamada de estilo de función en una expresión de tipo '*tipo*' perdería los calificadores const y volatile para todos los *número* sobrecargas de operador disponibles|
|[Error del compilador C3850](compiler-error-c3850.md)|'*token*': un nombre de carácter universal especifica un carácter no válido|
|[Error del compilador C3851](compiler-error-c3851.md)|'*token*': un nombre de carácter universal no puede designar un carácter en el juego de caracteres básico|
|[Error del compilador C3852](compiler-error-c3852.md)|'*miembro*'que tienen el tipo'*tipo*': inicialización de agregado no pudo inicializar este miembro|
|[Error del compilador C3853](compiler-error-c3853.md)|'=': volver a inicializar una referencia o asignación a través de una referencia a la función no es válido|
|[Error del compilador C3854](compiler-error-c3854.md)|expresión a la izquierda de '=' se evalúa como una función. No se puede asignar a una función (una función no es un valor l)|
|[Error del compilador C3855](compiler-error-c3855.md)|'*función*': parámetro de plantilla o genérico '*identificador*' no es compatible con la declaración|
|[Error del compilador C3856](compiler-error-c3856.md)|'*clase*': clase no es una plantilla de clase/generic|
|[Error del compilador C3857](compiler-error-c3857.md)|'*plantilla*': no se permiten varias listas de parámetros de plantilla o genérico|
|[Error del compilador C3858](compiler-error-c3858.md)|'*identificador*': no se puede volver a declarar en el ámbito actual|
|[Error del compilador C3859](compiler-error-c3859.md)|intervalo de memoria virtual para PCH superado; Vuelva a compilarlo con una opción de línea de comandos de '-Zm*número*' o superior|
|[Error del compilador C3860](compiler-error-c3860.md)|lista de argumentos de plantilla o genérico sigue al nombre de plantilla o genérico de la clase debe enumerar los parámetros en el orden utilizado en la lista de parámetros de plantilla o genérico|
|[Error del compilador C3861](compiler-error-c3861.md)|'*identificador*': no se encontró el identificador|
|[Error del compilador C3862](compiler-error-c3862.md)|'*función*': no se puede compilar una función no administrada con/CLR: pure o/CLR: safe|
|Error del compilador C3863|tipo de matriz '*tipo*' no es asignable|
|Error del compilador C3864|Obsoleto.|
|[Error del compilador C3865](compiler-error-c3865.md)|'*palabra clave*': solo puede usarse en funciones miembro nativas|
|[Error del compilador C3866](compiler-error-c3866.md)|Falta lista de argumentos de la llamada a un destructor/finalizador|
|[Error del compilador C3867](compiler-error-c3867.md)|'*función*': sintaxis no estándar; utilice '&' para crear un puntero a miembro|
|[Error del compilador C3868](compiler-error-c3868.md)|'*tipo*': las restricciones del parámetro genérico '*parámetro*' difieren de las de la declaración|
|[Error del compilador C3869](compiler-error-c3869.md)|la restricción gcnew no tiene lista de parámetros vacía '()'|
|Error del compilador C3870|'*parámetro*': ' __declspec (*especificador*)' solo se puede aplicar a parámetros de tipo entero|
|Error del compilador C3871|'*parámetro*': '__declspec(guard(overflow))' solo se admite en los primeros 64 parámetros de una función|
|[Error del compilador C3872](compiler-error-c3872.md)|' 0 x*valor*': este carácter no se permite en un identificador|
|[Error del compilador C3873](compiler-error-c3873.md)|' 0 x*valor*': este carácter no se permite como primer carácter de un identificador|
|[Error del compilador C3874](compiler-error-c3874.md)|tipo de valor devuelto '*identificador*'debe ser'*type1*'en lugar de'*type2*'|
|Error del compilador C3875|llamada de función miembro no estática que falta la lista de argumentos|
|Error del compilador C3876|Obsoleto.|
|Error del compilador C3877|Obsoleto.|
|Error del compilador C3878|Obsoleto.|
|Error del compilador C3879|'*miembro*': no puede ser un miembro de datos initonly|
|[Error del compilador C3880](compiler-error-c3880.md)|'*miembro*': no puede ser un miembro de datos literal|
|Error del compilador C3881|solo puede heredar un constructor de una base directa|
|Error del compilador C3882|'*clase*': constructor ya se ha heredado de '*clase*'|
|Error del compilador C3883|'*miembro*': debe inicializarse un miembro de datos estático initonly|
|Error del compilador C3884|'*tipo*': Una matriz de tamaño desconocido no puede ser el valor inicializado|
|Error del compilador C3885|'*tipo*': No se puede inicializar una matriz de tamaño desconocido con una lista de inicializadores vacía|
|[Error del compilador C3886](compiler-error-c3886.md)|'*miembro*': debe inicializarse un miembro de datos literal|
|[Error del compilador C3887](compiler-error-c3887.md)|'*miembro*': el inicializador de un miembro de datos literal debe ser una expresión constante|
|[Error del compilador C3888](compiler-error-c3888.md)|'*miembro*': no se admite la expresión const asociada con este miembro de datos literal C / c++ / CLI|
|Error del compilador C3889|Obsoleto.|
|[Error del compilador C3890](compiler-error-c3890.md)|'*miembro*': no puede tomar la dirección de un miembro de datos literal|
|[Error del compilador C3891](compiler-error-c3891.md)|'*miembro*': un miembro de datos literal no puede usarse como un valor l|
|[Error del compilador C3892](compiler-error-c3892.md)|'*variable*': no se puede asignar a una variable constante|
|[Error del compilador C3893](compiler-error-c3893.md)|'*miembro*': uso de valor l del miembro de datos initonly solamente se permite en un constructor de instancia de la clase*clase*'|
|[Error del compilador C3894](compiler-error-c3894.md)|'*miembro*': uso de valor l del miembro de datos estático initonly solamente se permite en el constructor de clase de la clase*clase*'|
|[Error del compilador C3895](compiler-error-c3895.md)|'*miembro*': *tipo* los miembros de datos no pueden ser 'volatile'|
|[Error del compilador C3896](compiler-error-c3896.md)|'*miembro*': inicializador inadecuado: este miembro de datos literal solamente se puede inicializar con 'nullptr'|
|Error del compilador C3897|Obsoleto.|
|[Error del compilador C3898](compiler-error-c3898.md)|'*miembro*': *tipo* los miembros de datos solo pueden ser miembros de tipos administrados|
|[Error del compilador C3899](compiler-error-c3899.md)|'*miembro*': no se permite el uso de valor l del miembro de datos initonly directamente dentro de una región paralela en la clase*clase*'|
|[Error del compilador C3900](compiler-error-c3900.md)|'*miembro*': no se permite en el ámbito actual|
|[Error del compilador C3901](compiler-error-c3901.md)|'*función*': debe tener el tipo de valor devuelto '*tipo*'|
|[Error del compilador C3902](compiler-error-c3902.md)|'*función*': tipo del último parámetro debe ser '*tipo*'|
|[Error del compilador C3903](compiler-error-c3903.md)|'*propiedad*': does no ha establecido o get (método)|
|[Error del compilador C3904](compiler-error-c3904.md)|'*propiedad*': debe especificar *número* parámetros|
|Error del compilador C3905|no se admiten accesos desalineados para el tipo intrínseco '*tipo*'|
|Error del compilador C3906|tipo intrínseco '*tipo*' no es un tipo de valor devuelto o argumento admitido para funciones vararg o sin prototipo|
|Error del compilador C3907|Obsoleto.|
|[Error del compilador C3908](compiler-error-c3908.md)|menos restrictivo que el de nivel de acceso '*identificador*'|
|[Error del compilador C3909](compiler-error-c3909.md)|una declaración de evento administrado o WinRT debe producirse en un tipo administrado o WinRT|
|[Error del compilador C3910](compiler-error-c3910.md)|'*eventos*': debe definir el miembro '*miembro*'|
|[Error del compilador C3911](compiler-error-c3911.md)|'*miembro*': función debe tener el tipo '*tipo*'|
|[Error del compilador C3912](compiler-error-c3912.md)|'*eventos*': tipo de evento debe ser un tipo delegado|
|[Error del compilador C3913](compiler-error-c3913.md)|una propiedad predeterminada debe estar indizada|
|[Error del compilador C3914](compiler-error-c3914.md)|una propiedad predeterminada no puede ser estática|
|[Error del compilador C3915](compiler-error-c3915.md)|'*identificador*' tiene ningún valor predeterminado indizadas propiedad (indizador de clase)|
|Error del compilador C3916|Obsoleto.|
|[Error del compilador C3917](compiler-error-c3917.md)|'*token*': obsoleto *construir* estilo de declaración (¿pretendía utilizar ' [' ']' en su lugar?)|
|[Error del compilador C3918](compiler-error-c3918.md)|requiere el uso de '*identificador*' sea un miembro de datos|
|[Error del compilador C3919](compiler-error-c3919.md)|'*función*': función debe tener el tipo '*return_type* (*tipo*)'|
|[Error del compilador C3920](compiler-error-c3920.md)|'*operador*': no se puede definir un incremento y decremento operador CLR o WinRT llamada postfijo operador CLR o WinRT llamará el prefijo correspondiente CLR o WinRT pero (op_Increment/op_Decrement), operador postfijo semántica|
|Error del compilador C3921|Obsoleto.|
|Error del compilador C3922|Obsoleto.|
|[Error del compilador C3923](compiler-error-c3923.md)|'*miembro*': clase local, struct o unión definiciones no se permiten en una función miembro de una clase administrada o WinRT|
|Error del compilador C3924|Error en el argumento #*número* de llamada al constructor delegado '*constructor*':|
|Error del compilador C3925|se esperaba un bucle (for, while o do) siguiente '*directiva*' directiva|
|Error del compilador C3926|constante no válida en la directiva 'parallel'|
|Error del compilador C3927|'->': no se permite el tipo de valor devuelto final después de un declarador de función no|
|Error del compilador C3928|'->': no se permite el tipo de valor devuelto final después de un declarador entre paréntesis|
|Error del compilador C3929|Obsoleto.|
|Error del compilador C3930|'*función*': ninguna función sobrecargada tiene especificadores de restricción que son compatibles con el contexto del ambiente '*contexto*'|
|Error del compilador C3931|'*tipo*': no se puede llamar a una función con especificadores de restricción que no son compatibles con el contexto del ambiente|
|Error del compilador C3932|Obsoleto.|
|Error del compilador C3933|'*clase*': los especificadores de restricción del destructor deben cubrir la unión de las restricciones a todos los constructores|
|Error del compilador C3934|una función que se encuentra en cualquier forma de 'main' no puede tener especificadores de restricción distintos de Restrict (CPU)|
|Error del compilador C3935|'*identificador*': nueva definición; especificadores de restricción superpuestos|
|Error del compilador C3936|'*identificador*': especificador de restricción no reconocido|
|Error del compilador C3937|no se permite el especificador de restricción vacío|
|Error del compilador C3938|'*identificador*': no se admiten varios especificadores de restricción en las funciones \042C\042 extern|
|Error del compilador C3939|'*identificador*': puntero a las funciones miembro, punteros de función, no se permiten las referencias a funciones con especificador de restricción "amp"|
|Error del compilador C3940|'*identificador*': identificador no encontrado: posible error de coincidencia entre versiones de la biblioteca y el compilador. Asegúrese de coincidencia vccorlib.h/.lib, vccorlib120.dll y c1xx.dll|
|Error del compilador C3941|'*condición*': requiere ' / clr' opción de línea de comandos|
|Error del compilador C3942|Obsoleto.|
|Error del compilador C3943|Obsoleto.|
|Error del compilador C3944|Obsoleto.|
|Error del compilador C3945|'*tipo*': no se puede producir o detectar un objeto winrt derivado de Platform:: Exception|
|Error del compilador C3946|'*tipo*': typeid no se puede aplicar a este tipo|
|Error del compilador C3947|'*typeid*': typeid no se puede aplicar a una expansión del paquete|
|Error del compilador C3948|'*palabra clave*': una expansión del paquete no puede aparecer en este contexto|
|Error del compilador C3949|una expansión del paquete, '...', no puede aparecer en un declarador abstracto entre paréntesis|
|Error del compilador C3950|Obsoleto.|
|Error del compilador C3951|No se puede usar un puntero a miembro de tipo proyectado de WinRT '*tipo*'. Use un delegado en su lugar.|
|Error del compilador C3952|'*tipo*': WinRT no admite ' in/out' matrices. Use ' const Array<T>^' para 'in' y ' WriteOnlyArray<T>' o ' matriz<T>^ *' para 'out' en las API públicas|
|Error del compilador C3953|No se puede usar la clase administrada*tipo*' en el módulo WinRT.|
|Error del compilador C3954|'*tipo*': Una matriz devuelta desde un método publicado en un tipo WinRT debe usar el formato ' matriz<T>^'|
|Error del compilador C3955|'*tipo*': Un constructor público no puede contener un parámetro 'out' o ' WriteOnlyArray<T>'|
|Error del compilador C3956|'*tipo*': Tipo está marcado como Exclusiveto '*tipo*'y no se puede usar como una base de'*derived_type*'|
|Error del compilador C3957|'*tipo*': no se puede utilizar 'new' en un WinRT tipo; use 'ref new' en su lugar|
|Error del compilador C3958|'*tipo*': no se puede usar 'gcnew' en un WinRT tipo; use 'ref new' en su lugar|
|Error del compilador C3959|'ref new' solo puede usarse para crear un objeto con tipo WinRT|
|Error del compilador C3960|Obsoleto.|
|Error del compilador C3961|no se admite el constructor estático|
|Error del compilador C3962|no se admite la clase genérica|
|Error del compilador C3963|no se admite una matriz multidimensional|
|Error del compilador C3964|no se admite una matriz escalonada|
|Error del compilador C3965|matriz de parámetros no se admite|
|Error del compilador C3966|'*función*': no se admite la función genérica|
|Error del compilador C3967|Error al importar '*identificador*'del módulo'*módulo*'|
|Error del compilador C3968|el token '*token*' no es válido como separador de nombre de módulo; use punto ('. ') en su lugar|
|Error del compilador C3969|nombres de módulos incoherentes: '*module1*'y'*module1*'|
|Error del compilador C3970|'*identificador*': '*palabra clave*' solo se puede aplicar a 'ref class' o 'ref struct' en el ámbito global o de espacio de nombres|
|Error del compilador C3971|'*tipo*': no pueden aparecer definiciones parciales tras definiciones completas|
|Error del compilador C3972|'*tipo*': 'partial' solo se puede aplicar a definiciones o declaraciones de clase|
|Error del compilador C3973|Obsoleto.|
|Error del compilador C3974|Obsoleto.|
|Error del compilador C3975|' clase/estructura *identificador*' se ha declarado previamente o que se define con un modificador diferente|
|Error del compilador C3976|'*identificador1*'debe declararse como 'public' para poder usar'*identificador2*'|
|Error del compilador C3977|Uso requiere una referencia a un ensamblado que define '*identificador*'|
|Error del compilador C3978|'*identificador*': no se permite una propiedad estática como miembro de un tipo de valor o la interfaz de WinRT|
|Error del compilador C3979|'*tipo*': usar el atributo '*atributo*'en lugar de'*valor*'|
|Error del compilador C3980|'*tipo*' no se emiten en metadatos|
|Error del compilador C3981|'*tipo*': un tipo de valor no puede tener los miembros de los datos estáticos*identificador*'|
|Error del compilador C3982|'*tipo*': un tipo de valor no puede tener ningún miembro de datos no públicos*identificador*'|
|Error del compilador C3983|'*tipo*': un tipo de valor no puede tener los miembros de datos no públicos*identificador*'|
|Error del compilador C3984|'*tipo*': un tipo que no son de valor no puede tener ningún miembro de datos públicos*identificador*'|
|Error del compilador C3985|'*identificador*': signatura del miembro público contiene un tipo privado '*miembro*'|
|Error del compilador C3986|'*identificador*': signatura del miembro público contiene el tipo nativo '*miembro*'|
|Error del compilador C3987|'*identificador*': signatura del miembro público contiene el tipo nativo '*tipo*'|
|Error del compilador C3988|'*tipo*': un tipo nativo no puede ser público|
|Error del compilador C3989|'*tipo*': un tipo anidado no puede ser público|
|Error del compilador C3990|'*tipo*': atributo '*atributo*' no puede ser privado o anidado|
|Error del compilador C3991|'*tipo*': no se puede implementar una interfaz no pública o anidada '*interfaz*'|
|Error del compilador C3992|'*identificador*': signatura del miembro público contiene el tipo no válido '*tipo*'|
|Error del compilador C3993|'*tipo*': un tipo de valor debe contener al menos un campo público|
|Error del compilador C3994|'*tipo*': un tipo de valor no puede implementar interfaces ni tener funciones virtuales|
|Error del compilador C3995|'*tipo*': un tipo de valor no puede tener ningún miembro de evento*identificador*'|
|Error del compilador C3996|Obsoleto.|
|Error del compilador C3998|' c ++*versión*': C++ versión no compatible; se usará ' c ++*versión*'|
|Error del compilador C3999|ERROR DESCONOCIDO Elija el comando soporte técnico en el menú Ayuda de Visual C++, o abra el archivo de Ayuda de soporte técnico para obtener más información|

## <a name="see-also"></a>Vea también

[C /C++ herramientas errores y advertencias de compilación y el compilador](../compiler-errors-1/c-cpp-build-errors.md) \
[Errores del compilador de C2000 - C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
